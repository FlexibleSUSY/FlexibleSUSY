// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

/**
 * @file @ModelName@_l_to_3l.cpp
 *
 * This file was generated at @DateAndTime@ with FlexibleSUSY
 * @FlexibleSUSYVersion@ and SARAH @SARAHVersion@
 */

#include <valarray>
#include <complex>

#include "@ModelName@_mass_eigenstates.hpp"
#include "cxx_qft/@ModelName@_qft.hpp"

#include "@ModelName@_l_to_3l.hpp"
#include "@ModelName@_FFV_form_factors.hpp"

#include "wrappers.hpp"

#define NPF(name) name(model, \
   std::array<int,4>{nI, nO, nA, nA}, \
   std::array<Eigen::Vector4d, 0>{})

@npf_headers@

namespace flexiblesusy {

namespace @ModelName@_cxx_diagrams {
namespace npointfunctions {

@npf_definitions@

std::array<std::complex<double>,10> zero(
   const @ModelName@_mass_eigenstates&,
   const std::array<int,4>&,
   const std::array<Eigen::Vector4d,0>&){
   std::array<std::complex<double>,10> res{};
   return res;
}

} // namespace npointfunctions
} // namespace @ModelName@_cxx_diagrams

using namespace @ModelName@_cxx_diagrams;
using namespace @ModelName@_FFV_form_factors;

namespace @ModelName@_l_to_3l {

/**
 * @tparam    Lepton type of a lepton field
 * @tparam    Photon type of a photon field
 * @param[in] model  mass eigenstates
 * @param[in] nA     generation index
 * @return left part of ffv coupling, multiplied by -i
 */
template <class Lepton, class Photon>
std::complex<double> left(const @ModelName@_mass_eigenstates& model, int nA) {
    context_base context {model};
    using vertex = Vertex<typename Lepton::lorentz_conjugate, Lepton, Photon>;
    std::array<int, 2> indices {nA, nA};
    const auto value =  vertex::evaluate(indices, context);
    return value.left();
}

/**
 * @tparam    Lepton type of a lepton field
 * @tparam    Photon type of a photon field
 * @param[in] model  mass eigenstates
 * @param[in] nA     generation index
 * @return right part of ffv coupling, multiplied by -i
 */
template <class Lepton, class Photon>
std::complex<double> right(const @ModelName@_mass_eigenstates& model, int nA) {
    context_base context {model};
    using vertex = Vertex<typename Lepton::lorentz_conjugate, Lepton, Photon>;
    std::array<int, 2> indices {nA, nA};
    const auto value =  vertex::evaluate(indices, context);
    return value.right();
}

typedef std::valarray<std::complex<double>> (*ffv)(
   int, int, const @ModelName@_mass_eigenstates&, bool);

typedef std::array<std::complex<double>,10> (*npf)(
   const @ModelName@_mass_eigenstates&,
   const std::array<int,4>&,
   const std::array<Eigen::Vector4d,0>&);

/**
 * @tparam    A      type of input sets of coefficients
 * @param[in] photon t-coefficients of all penguins
 * @param[in] res    t-coefficients of all penguins
 * @param[in] boxes  coefficients of all boxes
 * @return Wilson coefficients of four fermion operators
 */
template<class A>
Eigen::Array<std::complex<double>,10,1> fierz(A photon, A rest, A box) {
   A sum = photon + rest;
   sum << sum[0]/2 - 6*sum[8],   sum[1] - 2*sum[5],
          sum[2] - 2*sum[6],     sum[3]/2 - 6*sum[9],
          2*sum[4],              sum[5] - sum[1]/2,
          sum[6] - sum[2]/2,     2*sum[7],
          1.5*sum[8] - sum[0]/8, 1.5*sum[9] - sum[3]/8;
   sum = sum + box;
   A res{};
   res << 2*sum[0], 0,      0,      2*sum[3],
          sum[4]/2, sum[5], sum[6], sum[7]/2,
          0,        0;
   return res;
}

/**
 * @tparam    Lepton type of a lepton field
 * @tparam    Photon type of a photon field
 * @tparam    photon function name for photon t-penguins
 * @tparam    rest   function name for other t-penguins
 * @tparam    boxes  function name for all box diagrams
 * @param[in] nI     generation of decaying lepton
 * @param[in] nO     generation of lepton, which can be separated from pair
 * @param[in] nA     generation of lepton and antilepton
 * @param[in] model  mass eigenstates
 * @param[in] qedqcd reference to low-enregy data
 * @return observable value and Wilson coefficients used to derive it
 */
template<class Lepton, class Photon, ffv photon, npf rest, npf boxes>
Eigen::Array<std::complex<double>,13,1> forge(int nI, int nO, int nA,
   const @ModelName@_mass_eigenstates& model, const softsusy::QedQcd& qedqcd) {

   context_base context {model};

   // @todo check
   const auto massless = photon(nI, nO, model, false);
   const auto D_L = 0.5 * massless[2];
   const auto D_R = 0.5 * massless[3];

   const auto L = left<Lepton, Photon>(model, nA);
   const auto R = right<Lepton, Photon>(model, nA);
   Eigen::Array<std::complex<double>,10,1> photon_amp{};
   photon_amp[4] = massless[0] * L;
   photon_amp[5] = massless[0] * R;
   photon_amp[6] = massless[1] * L;
   photon_amp[7] = massless[1] * R;
   // need to check what is above @todo

   // Full amplitude is calculated with the following convention (for the case
   // 4!=3, otherwise Fierz transformations should be used hep-ph/0412245, note
   // the half for every sigma-sigma summation in eqs. 40 and 42):
   //    <out:4,3| T exp(i L_full dx) |in:2,1> = i * npf,
   // which means, that it has to be matched with -1 * C_XY, because
   //    <out:4,3| T exp(i L_low dx) |in:2,1> = -i * C_XY [3 X 1]*[4 Y 2].
   Eigen::Array<std::complex<double>,10,1> penguin_amp(NPF(rest).data());
   Eigen::Array<std::complex<double>,10,1> box_amp(NPF(boxes).data());

   // For coefficients we use sigmas, but in the basis from meta code we have
   // only anticommutation, so we need to fix it for tensor coefficients.
   penguin_amp[8] = -penguin_amp[8];
   penguin_amp[9] = -penguin_amp[9];
   box_amp[8] = -box_amp[8];
   box_amp[9] = -box_amp[9];

   // If final leptons are the same, then we need to add u-penguins as well
   // not, then we can just sum them (we always calculate all boxes in npf).
   auto coeffs = (nO == nA) ? fierz(photon_amp, penguin_amp, box_amp)
                            : photon_amp + penguin_amp + box_amp;

   Eigen::Array<std::complex<double>,13,1> res;

   res << 0.0,
          D_L,
          D_R,
          coeffs[0],
          coeffs[1],
          coeffs[2],
          coeffs[3],
          coeffs[4],
          coeffs[5],
          coeffs[6],
          coeffs[7],
          coeffs[8],
          coeffs[9];

   return res;
}

@calc_definitions@

} // namespace @ModelName@_l_to_3l
} // namespace flexiblesusy
