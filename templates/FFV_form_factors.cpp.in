// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

/**
 * @file @ModelName@_FFV_form_factors.cpp
 *
 * This file was generated with FlexibleSUSY @FlexibleSUSYVersion@ and SARAH @SARAHVersion@ .
 */

#include <complex>
#include <valarray>

#include "@ModelName@_mass_eigenstates.hpp"
#include "concatenate.hpp"
#include "cxx_qft/@ModelName@_qft.hpp"

#include "dilog.hpp"
#include "wrappers.hpp"

using namespace flexiblesusy;
using namespace @ModelName@_cxx_diagrams;
using namespace @ModelName@_cxx_diagrams::fields;

namespace {

static constexpr double oneOver32PiSqr = 0.5*oneOver16PiSqr;

/**
 * @class FFV_SSF
 * @brief A template that calculate contributions to the FFV form
 *        factors of a given particles in a one loop diagram
 *        specified by a vector emitters and an exchange particle.
 * @tparam Args Specifies in order the field of which to
 *              calculate the electric dipole moment,
 *              the photon emitter and the exchange particle
 *              in a one-loop diagram where the photon emitter
 *              is a scalar and the exchange particle a fermion.
 *
 * This template evaluates the contribution to the electric
 * dipole moment of a one loop diagram with fields given by
 * \a Args.
 */
template <class Fj, class Fi, class V, class S1, class S2, class F>
struct FFV_SSF {
   static std::valarray<std::complex<double>>
   value(const typename field_indices<Fj>::type& indices_in,
         const typename field_indices<Fi>::type& indices_out,
         context_base const& context,
         bool discard_SM_contributions);
};

/**
* @class FFV_FFS
* @brief A template that calculate contributions to the FFV form
*        factors of a given particle in a one loop diagram
*        specified by a vector emitters and an exchange particle.
* @tparam Args Specifies in order the field of which to
*              calculate the electric dipole moment,
*              the photon emitter and the exchange particle
*              in a one-loop diagram where the photon emitter
*              is a fermion and the exchange particle a scalar.
*
* This template evaluates the contribution to the electric
* dipole moment of a one loop diagram with fields given by
* \a Args.
*/
template <class Fj, class Fi, class V, class F1, class F2, class S>
struct FFV_FFS {
   static std::valarray<std::complex<double>>
   value(const typename field_indices<Fj>::type& indices_in,
         const typename field_indices<Fi>::type& indices_out,
         context_base const& context,
         bool discard_SM_contributions);
};

/**
 * @class FFV_VVF
 * @brief A template that calculates contributions to the FFV form
 *          factors of a given particle in a one loop diagram
 *          specified by a vector emitter and an exchange particle.
 * @tparam Args Specifies in order the field of which to
 *              calculate the electric dipole moment, 
 *              the photon emitter and the exchange particle 
 *              in a one-loop diagram where the photon emitter 
 *              is a vector and the exchange particle a fermion.
 *
 * This template evaluates the contribution to the electric
 * dipole moment of a one loop diagram with fields given by
 * \a Args.
 */
template <class Fj, class Fi, class P, class V1, class V2, class F>
struct FFV_VVF {
    static std::valarray<std::complex<double>>
    value(const typename field_indices<Fj>::type& indices_in,
          const typename field_indices<Fi>::type& indices_out,
          context_base const& context,
          bool discard_SM_contributions);
};

/**
 * @class FFV_FFV
 * @brief A template that calculates contributions to the FFV form
 *        factors of a given particle in a one loop diagram
 *        specified by a vector emitter and an exchange particle.
 * @tparam Args Specifies in order the field of which to
 *              calculate the electric dipole moment,
 *              the photon emitter and the exchange particle
 *              in a one-loop diagram where the photon emitter
 *              is a fermion and the exchange particle a vector.
 *
 * This template evaluates the contribution to the electric
 * dipole moment of a one loop diagram with fields given by
 * \a Args.
 */
template <class Fj, class Fi, class P, class F1, class F2, class V>
struct FFV_FFV {
    static std::valarray<std::complex<double>>
    value(const typename field_indices<Fj>::type& indices_in,
          const typename field_indices<Fi>::type& indices_out,
          context_base const& context,
          bool discard_SM_contributions);
};

/**
 * @class FFV_VGF
 * @brief A template that calculates contributions to the FFV form
 *        factors of a given particle in a one loop diagram
 *        specified by a vector emitter and an exchange particle.
 * @tparam Args Specifies in order the field of which to
 *         calculate the electric dipole moment,
 *         the photon emitter and the exchange particle
 *         in a one-loop diagram where the photon is emitted
 *         from a vector-goldstone vertex and the exchange
 *         particle is a fermion.
 *
 * This template evaluates the contribution to the electric
 * dipole moment of a one loop diagram with fields given by
 * \a Args.
 */
template <class Fj, class Fi, class P, class V1, class G2, class F>
struct FFV_VSF {
    static std::valarray<std::complex<double>>
    value(const typename field_indices<Fj>::type& indices_in,
          const typename field_indices<Fi>::type& indices_out,
          context_base const& context,
          bool discard_SM_contributions);
};

/**
 * @class FFV_GVF
 * @brief A template that calculates contributions to the FFV form
 *        factors of a given particle in a one loop diagram
 *        specified by a vector emitter and an exchange particle.
 * @tparam Args Specifies in order the field of which to
 *              calculate the electric dipole moment,
 *              the photon emitter and the exchange particle
 *              in a one-loop diagram where the photon is emitted
 *              from a goldstone-vector vertex and the exchange
 *              particle is a fermion.
 *
 * This template evaluates the contribution to the electric
 * dipole moment of a one loop diagram with fields given by
 * \a Args.
 */
template <class Fj, class Fi, class P, class G1, class V2, class F>
struct FFV_SVF {
    static std::valarray<std::complex<double>>
    value(const typename field_indices<Fj>::type& indices_in,
          const typename field_indices<Fi>::type& indices_out,
          context_base const& context,
          bool discard_SM_contributions);
};

} // anonymous namespace

namespace flexiblesusy {
namespace @ModelName@_FFV_form_factors {
@FFVFormFactors_InterfaceDefinitions@
}
} // namespace flexiblesusy

namespace {
/**
* @defgroup LoopFunctions Loop functions
* @brief The loop functions necessary for the Fe_I -> Fe_J gamma one-loop calculations.
*
* These are OneLoopFunctionA(), OneLoopFunctionB()
* as specified in arXiv:0808.1819
*/

//  TODO:  Several fixes still needed, 1/r is not helpful when r is infinite, 
//  may need to just input mF and mS\mV and then calculate the ratios in-house.

// Cutoff for standard literature one loop functions.  
const double approx_limit = 100.;
// Cutoff for using simplified one loop functions.  
const double ratio_limit = 0.00001;

// function from eq. 15 of hep-ph/9510309
double OneLoopFunctionA(double r)
{
   if (is_zero(1.0 - r)) {
      return 1.5;
   } else if (is_zero(r)) {
      return 2.0;
   } else if (1./r < Power3(ratio_limit)) {
      // Loop function is about 10^-13, treat as reaching the 0 limit
      return 0.;
   } else if (1./r < ratio_limit) {
      // Expand about 0 to 1st order
      return r*(-11.-6.*std::log(r));
   } else {
      return (2.0 - 9.0 * r + 18.0 * r * r - 11.0 * r * r * r +
              6.0 * r * r * r * std::log(r)) /
             Power4(1.0 - r);
   }
}

// function from eq. 16 of hep-ph/9510309
double OneLoopFunctionB(double r)
{
   const double y = r - 1.0;
   if (is_zero(r)) {
      return 2.0;
   } else if (std::abs(y) < 0.23) {
      // error around x=1 is <= 10^-12 on an intel i7
      return (1.0000000000000000000 -
              0.4000000000000000000  * y +
              0.2000000000000000000  * y * y -
              0.11428571428571428571 * y * y * y +
              0.07142857142857142857 * y * y * y * y -
              0.04761904761904761905 * y * y * y * y * y +
              0.03333333333333333333 * y * y * y * y * y * y -
              0.02424242424242424242 * y * y * y * y * y * y * y +
              0.0181818181818181818  * y * y * y * y * y * y * y * y -
              0.01398601398601398601 * y * y * y * y * y * y * y * y * y +
              0.01098901098901098901 * y * y * y * y * y * y * y * y * y * y -
              0.0087912087912087912  * y * y * y * y * y * y * y * y * y * y * y +
              0.00714285714285714286 * y * y * y * y * y * y * y * y * y * y * y * y -
              0.0058823529411764706  * y * y * y * y * y * y * y * y * y * y * y * y * y +
              0.0049019607843137255  * y * y * y * y * y * y * y * y * y * y * y * y * y * y -
              0.0041279669762641899  * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y);
   } else if (1./r < ratio_limit) {
      // Expand about 0 to 1st order
      return 4.*r;
   } else {
      return 2. *
             (1.0 - 6.0 * r + 3.0 * r * r + 2.0 * r * r * r -
              6.0 * r * r * std::log(r)) /
             Power4(1.0 - r);
   }
}

// function from eq. 16 of hep-ph/9510309
double OneLoopFunctionC(double r)
{
   const double y = r - 1.0;
   if (is_zero(r)) {
      return 3.0;
   } else if (std::isinf(r)) {
      return 3.0;
   } else if (std::abs(y) < 0.185) {
      // error around x=1 is <= 10^-13 on an intel i7
      return (1.0000000000000000000 -
              0.50000000000000000000 * y +
              0.30000000000000000000 * y * y -
              0.2000000000000000000  * y * y * y +
              0.14285714285714285714 * y * y * y * y -
              0.10714285714285714286 * y * y * y * y * y +
              0.08333333333333333333 * y * y * y * y * y * y -
              0.06666666666666666667 * y * y * y * y * y * y * y +
              0.05454545454545454545 * y * y * y * y * y * y * y * y -
              0.0454545454545454545  * y * y * y * y * y * y * y * y * y +
              0.0384615384615384615  * y * y * y * y * y * y * y * y * y * y -
              0.03296703296703296703 * y * y * y * y * y * y * y * y * y * y * y +
              0.0285714285714285714  * y * y * y * y * y * y * y * y * y * y * y * y -
              0.02500000000000000000 * y * y * y * y * y * y * y * y * y * y * y * y * y +
              0.0220588235294117647  * y * y * y * y * y * y * y * y * y * y * y * y * y * y -
              0.0196078431372549020  * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y);
   } else if (1./r < ratio_limit) {
      // Expand about 0 to 1st order
      return 3.*r;
   } else {
      return 3. * (1.0 - r * r + 2.0 * r * std::log(r)) / Power3(1.0 - r);
   }
}

// function from eq. 17 of hep-ph/9510309
double OneLoopFunctionD(double r)
{
   if (std::isinf(r)) {
      return 0.0;
   } else if (is_zero(1.0 - r)) {
      return -4.5;
   } else if (1./r < ratio_limit) {
      // Expand about 0 to 1st order
      return -7.*r;
   } else {
      return (16.0 - 45.0 * r + 36.0 * r * r - 7.0 * r * r * r +
              6.0 * (2.0 - 3.0 * r) * std::log(r)) /
             Power4(1.0 - r);
   }
}

// function from eq. 18 of hep-ph/9510309
double OneLoopFunctionE(double r)
{
   const double y = r - 1.0;
   if (is_zero(r)) {
      return 12.0;
   } else if (std::abs(y) < 0.21) {
      // error around x=1 is <= 10^-12 on an intel i7
      return (1.0000000000000000000 -
              0.60000000000000000000  * y +
              0.40000000000000000000  * y * y -
              0.28571428571428571429  * y * y * y +
              0.21428571428571428571  * y * y * y * y -
              0.16666666666666666667  * y * y * y * y * y +
              0.13333333333333333333  * y * y * y * y * y * y -
              0.10909090909090909091  * y * y * y * y * y * y * y +
              0.090909090909090909091 * y * y * y * y * y * y * y * y -
              0.076923076923076923077 * y * y * y * y * y * y * y * y * y +
              0.065934065934065934066 * y * y * y * y * y * y * y * y * y * y -
              0.057142857142857142857 * y * y * y * y * y * y * y * y * y * y * y +
              0.050000000000000000000 * y * y * y * y * y * y * y * y * y * y * y * y -
              0.044117647058823529412 * y * y * y * y * y * y * y * y * y * y * y * y * y +
              0.039215686274509803922 * y * y * y * y * y * y * y * y * y * y * y * y * y * y -
              0.035087719298245614035 * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y);
   } else if (1./r < ratio_limit) {
      // Expand about 0 to 1st order
      return 2.*r;
   } else {
      return 2. *
             (2.0 + 3.0 * r - 6.0 * r * r + r * r * r + 6.0 * r * std::log(r)) /
             Power4(1.0 - r);
   }
}

// function from eq. 18 of hep-ph/9510309
double OneLoopFunctionF(double r)
{
   const double y = r - 1.0;
   if (std::abs(y) < 0.155) {
      // error around x=1 is <= 10^-13 on an intel i7
      return (1.0 - 
              0.75 * y + 
              0.6 * y * y -
              0.50000000000000000000 * y * y * y +
              0.4285714285714285714  * y * y * y * y -
              0.37500000000000000000 * y * y * y * y * y +
              0.33333333333333333333 * y * y * y * y * y * y -
              0.3000000000000000000  * y * y * y * y * y * y * y +
              0.2727272727272727273  * y * y * y * y * y * y * y * y -
              0.2500000000000000000  * y * y * y * y * y * y * y * y * y +
              0.23076923076923076923 * y * y * y * y * y * y * y * y * y * y -
              0.21428571428571428571 * y * y * y * y * y * y * y * y * y * y * y +
              0.2000000000000000000  * y * y * y * y * y * y * y * y * y * y * y * y -
              0.1875000000000000000  * y * y * y * y * y * y * y * y * y * y * y * y * y +
              0.1764705882352941176  * y * y * y * y * y * y * y * y * y * y * y * y * y * y -
              0.16666666666666666667 * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y);
   } else if (1./r < ratio_limit) {
      // Expand about 0 to 1st order
      return 1.5*r;
   } else {
      return 3. / 2. * (-3.0 + 4.0 * r - r * r - 2.0 * std::log(r)) /
             Power3(1.0 - r);
   }
}

//  One loop function for the form factor F1 which is the coefficient
//  of ubar(pp,mj) \gamma^\mu u(p,mi), for the FFV_VVF contribution.  
double OneLoopFunctionH(double r)
{
   if (is_zero(r)) {
      return 5.0;
   } else if (is_zero(1.0 - r)){
      return 0.0;
   } else if (1./r < Power3(ratio_limit)) {
      // Loop function is about 10^-13, treat as reaching the 0 limit
      return 0.;
   } else if (1./r < ratio_limit) {
      // Expand about 0 to 1st order
      return r*(-5.-6.*std::log(r));
   } else {
      return (5.0 - 27.0 * r + 27.0 * r * r - 5.0 * r * r * r + 6.0 * (r - 3.0) * r * r * std::log(r)) /
              Power4(1.0 - r);
   }
}

//  One loop function for the form factor F1 which is the coefficient
//  of ubar(pp,mj) \gamma^\mu u(p,mi), for the FFV_VVF contribution.  
double OneLoopFunctionI(double r)
{
   if (is_zero(r)) {
      return 1.0;
   } else if (is_zero(1.0 - r)){
      return 0.5;
   } else if (1./r < Power3(ratio_limit)) {
      // Loop function is about 10^-13, treat as reaching the 0 limit
      return 0.;
   } else if (1./r < ratio_limit) {
      // Expand about 0 to 1st order
      return r*(-1.-1.*std::log(r));
   } else {
      return (1.0 - r + r * std::log(r)) / Power2(1.0 - r);
   }
}

// function from eq. 78 of hep-ph/2104.03691
double OneLoopFunctionJ(double r)
{
   if (is_zero(r)) {
      return 7.0;
   } else if (is_zero(1.0 - r)){
      return 5.0;
   } else if (1./r < Power3(ratio_limit)) {
      // Loop function is about 10^-13, treat as reaching the 0 limit
      return 0.;
   } else if (1./r < ratio_limit) {
      // Expand about 0 to 1st order
      return r*(-31.-18.*std::log(r));
   } else {
      return (7.0 - 33.0 * r + 57.0 * r * r - 31.0 * r * r * r + 6.0 * r * r * (3.0 * r - 1.0)
                   * std::log(r)) / Power4(1.0 - r);
   }
}

// function from eq. 79 of hep-ph/2104.03691
double OneLoopFunctionK(double r)
{
   if (is_zero(r)) {
      return 1.0;
   } else if (is_zero(1.0 - r)){
      return 2.0 / 3.0;
   } else if (1./r < Power3(ratio_limit)) {
      // Loop function is about 10^-13, treat as reaching the 0 limit
      return 0.;
   } else if (1./r < ratio_limit) {
      // Expand about 0 to 1st order
      return r*(-3.-2.*std::log(r));
   } else {   
      return (1.0 - 4.0 * r + 3.0 * r * r - 2 * r * r * std::log(r)) / Power3(1.0 - r);
   }
}

//  One loop function for the form factor F1 which is the coefficient
//  of ubar(pp,mj) \gamma^\mu u(p,mi), for the FFV_FFV contribution.  
double OneLoopFunctionL(double r)
{  
   if (is_zero(r)) {
      return -10.0;
   } else if (is_zero(1.0 - r)){
      return 10.5;
   } else if (1./r < ratio_limit) {
      // Expand about 0 to 1st order
      return 25.*r;
   } else {
      return (2.0 + 27.0 * r - 54.0 * r * r + 25.0 * r * r * r - 6.0 * (2.0 - 9.0 * r + 6.0 * r * r)
                 * std::log(r)) / Power4(1.0 - r);
   }
}

// function from eq. 80 of hep-ph/2104.03691
double OneLoopFunctionM(double r)
{
   if (is_zero(r)) {
      return 4.0;
   } else if (is_zero(1.0 - r)){
      return 1.5;
   } else if (1./r < ratio_limit) {
      // Expand about 0 to 1st order
      return 5.*r;
   } else {
      return (4.0 - 9.0 * r + 5.0 * r * r * r + 6.0 * (1.0 - 2.0 * r) * r * std::log(r)) / 
              Power4(1.0 - r);
   }
}

// function from eq. 81 of hep-ph/2104.03691
double OneLoopFunctionN(double r, double s)
{
   if (is_zero(r - s)) {
      if (is_zero(r)) {
         return 1.0;
      } else if (is_zero(1.0 - r)){
         return 2.0 / 3.0;
      } else {
         return (1.0 - 4.0 * r + 3 * r * r - 2 * r * r * std::log(r)) / 2.0 / Power3(1.0 - r);
      }
   } else if (1./s < ratio_limit) {
      // Expand s about 0 to 1st order
      return (1.0 - r * r * s + r * (s - 1.0) + r * (s + 1.0) * std::log(r)) / Power2(r - 1.0);
   } else {
      return s * (r * Power2(r - s) * std::log(r) + (r - 1.0) * ((r - s) * (s - 1.0) - (r - 1.0)
                              * r * std::log(r/s))) / Power2(1.0 - r) / Power2(r - s) / (s - 1.0);
   }
}


template<typename T>
T KallenLambda(T m1, T m2, T m3)
{
   return Power2(m1-m2-m3) - 4*m2*m3;
}

double KallenLambdasqrt(double m1, double m2, double m3)
{
    return std::sqrt(KallenLambda(m1,m2,m3));
}

double DiscontinuityB(double m12, double m2, double m3)
{
    return KallenLambdasqrt(m12,Power2(m2),Power2(m3)) 
               * std::log((Power2(m2)+Power2(m3)-m12+KallenLambdasqrt(m12,Power2(m2),Power2(m3)))/(2.*m2*m3)) / m12;
}

/**
 * @brief dilog function which performs branch cut using the sign of a if x > 1.
 *
 * Returns a dilog, but performs the branch cut depending on the sign of a.  If x<=1, then 
 * this is just a simple dilog.  However if x > 1, then the sign of the branch cut is the 
 * sign of a.
 * From Mathematica PackageX, DiLog[].  
 */
double signed_dilog(double x, double a)
{
    if (a > 0.)
    {
        return -1./2. * Power2(std::log(1./(1.-x))) - dilog(x/(x-1.));
    } else if (a < 0.) {
        return dilog(x);
    }
}

// function from eq. 2.9 of hep-ph/1105.4319
/**
 * @brief C0 Passarino-Veltman function with M12=0.  
 *
 * Standard C0 Passarino-Veltman function with first mass entry
 * set to 0 (note the missing M12).
 */
double ScalarC0(double M22, double M32, double m1, double m2, double m3)
{
    const double m12 = Power2(m1);
    const double m22 = Power2(m2);
    const double m32 = Power2(m3);
    if (is_zero(M22 - M32))
    {
        if (is_zero(m1 - m2))
        {
            return (m12-M22-m32) * DiscontinuityB(M22,m1,m3)
                    / KallenLambda(m12,M22,m32) + std::log(m3/m1) / M22;
        } else {
            return (M22*(DiscontinuityB(M22,m1,m3)-DiscontinuityB(M22,m2,m3)-std::log(m1/m2))
                    + m32*std::log(m1/m2) + m22*std::log(m2/m3) + m12*std::log(m3/m1))
                    / ((m1-m2) * (m1+m2) * M22);
        }
    } else {
       const double dilog1 = signed_dilog(2.*(m12*M22-m22*M32+m32*(M32-M22)) 
                        / (-2.*m22*M32+m12*(M22+M32)+(M22-M32)*(-m32+M32)+(M22-M32)*KallenLambdasqrt(m12,m32,M32)),
                        -(M22-M32)*M32*(m12*M22-m22*M32+m32*(-M22+M32)));
       const double dilog2 = signed_dilog((2.*m12*M22-2.*m22*M32+2.*(M22-M32)*(-m32+M32)) 
                        / (-2.*m22*M32+m12*(M22+M32)+(M22-M32)*(-m32+M32)+(M22-M32)*KallenLambdasqrt(m12,m32,M32)),
                        -(M22-M32)*M32*(m12*M22-m22*M32+(M22-M32)*(-m32+M32)));
       const double dilog3 = signed_dilog((2.*(m12*M22-m22*M32+m32*(-M22+M32))) 
                        / (-2.*m22*M32+m12*(M22+M32)+(M22-M32)*(-m32+M32)+(-M22+M32)*KallenLambdasqrt(m12,m32,M32)),
                        (M22-M32)*M32*(m12*M22-m22*M32+m32*(-M22+M32)));
       const double dilog4 = signed_dilog((2.*m12*M22-2.*m22*M32+2.*(M22-M32)*(-m32+M32)) 
                        / (-2.*m22*M32+m12*(M22+M32)+(M22-M32)*(-m32+M32)+(-M22+M32)*KallenLambdasqrt(m12,m32,M32)),
                        (M22-M32)*M32*(m12*M22-m22*M32+(M22-M32)*(-m32+M32)));
       const double dilog5 = signed_dilog((2.*m12*M22+2.*(M22-m32)*(M22-M32)-2.*m22*M32) 
                        / (2.*m12*M22+(M22-m32)*(M22-M32)-m22*(M22+M32)+(M22-M32)*KallenLambdasqrt(m22,M22,m32)),
                        -M22*(M22-M32)*(m12*M22+(M22-m32)*(M22-M32)-m22*M32));
       const double dilog6 = signed_dilog((2.*(m12*M22-m22*M32+m32*(-M22+M32))) 
                        / (2.*m12*M22+(M22-m32)*(M22-M32)-m22*(M22+M32)+(M22-M32)*KallenLambdasqrt(m22,M22,m32)),
                        -M22*(M22-M32)*(m12*M22-m22*M32+m32*(-M22+M32)));
       const double dilog7 = signed_dilog((2.*m12*M22+2.*(M22-m32)*(M22-M32)-2.*m22*M32) 
                        / (2.*m12*M22+(M22-m32)*(M22-M32)-m22*(M22+M32)+(-M22+M32)*KallenLambdasqrt(m22,M22,m32)),
                        M22*(M22-M32)*(m12*M22+(M22-m32)*(M22-M32)-m22*M32));
       const double dilog8 = signed_dilog((2.*(m12*M22-m22*M32+m32*(-M22+M32))) 
                       / (2.*m12*M22+(M22-m32)*(M22-M32)-m22*(M22+M32)+(-M22+M32)*KallenLambdasqrt(m22,M22,m32)),
                       M22*(M22-M32)*(m12*M22-m22*M32+m32*(-M22+M32)));
       const double polylog1 = ((m1-m2)*(m1+m2)*(m12*M22+(M22-m32)*(M22-M32)-m22*M32)) 
                         / (Power4(m1)*M22+m22*(M22-M32)*(m32-M32)+Power4(m2)*M32+m12*((M22-m32)*(M22-M32)-m22*(M22+M32)));
       const double polylog2 = ((m1-m2)*(m1+m2)*(m12*M22-m22*M32+(M22-M32)*(-m32+M32))) 
                         / (Power4(m1)*M22+m22*(M22-M32)*(m32-M32)+Power4(m2)*M32+m12*((M22-m32)*(M22-M32)-m22*(M22+M32)));
       return (-dilog1+dilog2-dilog3+dilog4-dilog5+dilog6-dilog7+dilog8+polylog1-polylog2) / (M22-M32); 
    }
}


std::complex<double> FFV_SSF_A1L(double mi, double mj, double mF, double mS, auto SFin, auto SFout)
{
  const double mi2=Power2(mi);
  const double mi3=Power3(mi);
  const double mi4=Power4(mi);
  const double mi6=Power6(mi);
  const double mj2=Power2(mj);
  const double mj3=Power3(mj);
  const double mj4=Power4(mj);
  const double mj6=Power6(mj);
  const double mF2=Power2(mF);
  const double mF4=Power4(mF);
  const double mF6=Power6(mF);
  const double mS2=Power2(mS);
  const double mS4=Power4(mS);
  const double mS6=Power6(mS);
  const double pi2=Power2(M_PI);
  if (is_zero(mF)) {
    const auto r = Power2(mF/mS);
    if (mS > approx_limit * std::max(mi,mj)) {
      // eq. 15 of hep-ph/9510309 (possibly with different sign)
      return - 1./18. * SFout.right() * SFin.left() * OneLoopFunctionA(r) / mS2;
    } else {
      if (is_zero(mi-mj)) {
        if (is_zero(mi-mS)) {
          return -(SFin.right()*SFout.left())/(6.*mi) + (SFin.left()*SFout.right())/(6.*mi);
        } else {
          return (SFin.right()*SFout.left()*(-3*mi4 + 2*mi2*mS2 - 2*Power2(mi2 - mS2)*std::log(mS2/(-mi2 + mS2))))/(6.*Power5(mi)) + (SFin.left()*SFout.right()*(3*mi4 - 2*mi2*mS2 + 2*Power2(mi2 - mS2)*std::log(mS2/(-mi2 + mS2))))/(6.*Power5(mi));
        }
      } else {
        if (is_zero(mi-mS)) {
          return (mi*SFin.right()*SFout.left()*(4*mi4*mj2*(-9 + pi2) + 7*mi2*mj4*pi2 + mj6*(36 + pi2) + 6*(4*mi4*mj2 + 7*mi2*mj4 + mj6)*dilog(mj2/(-mi2 + mj2)) + 3*mj2*(4*mi4 + 7*mi2*mj2 + mj4)*Power2(std::log(mi2/(mi2 - mj2))) + 3*(-mi + mj)*(mi + mj)*(mi4 + 16*mi2*mj2 + 7*mj4)*std::log(mi2/(mi2 - mj2))))/(3.*mj2*Power3(-mi2 + mj2)) + (SFin.left()*SFout.right()*(-(mi6*mj2) + 3*mi4*mj4*(-7 + pi2) + mi2*mj6*(21 + pi2) + 6*mi2*(3*mi2 + mj2)*mj4*dilog(mj2/(-mi2 + mj2)) + Power8(mj) + mi2*std::log(mi2/(mi2 - mj2))*(mi6 - 9*mi4*mj2 - 9*mi2*mj4 + 17*mj6 + 3*(3*mi2*mj4 + mj6)*std::log(mi2/(mi2 - mj2)))))/(mj3*Power3(mi2 - mj2));
        } else if (is_zero(mj-mS)) {
          return (SFin.right()*SFout.left()*(-(mi2*mj6) + 3*mi4*mj4*(-7 + pi2) + mi6*mj2*(21 + pi2) + 6*mi4*mj2*(mi2 + 3*mj2)*dilog(mi2/(mi2 - mj2)) + Power8(mi) + mj2*std::log(mj2/(-mi2 + mj2))*(17*mi6 - 9*mi4*mj2 - 9*mi2*mj4 + mj6 + 3*(mi6 + 3*mi4*mj2)*std::log(mj2/(-mi2 + mj2)))))/Power3(mi3 - mi*mj2) - (mj*SFin.left()*SFout.right()*(4*mi2*mj4*(-9 + pi2) + 7*mi4*mj2*pi2 + mi6*(36 + pi2) + 6*(mi6 + 7*mi4*mj2 + 4*mi2*mj4)*dilog(mi2/(mi2 - mj2)) + 3*std::log(mj2/(-mi2 + mj2))*((mi - mj)*(mi + mj)*(7*mi4 + 16*mi2*mj2 + mj4) + (mi6 + 7*mi4*mj2 + 4*mi2*mj4)*std::log(mj2/(-mi2 + mj2)))))/(3.*mi2*Power3(mi - mj)*Power3(mi + mj));
        } else {
          return (SFin.right()*SFout.left()*(-2*mi4*(mi - mj)*(mi + mj)*mj2*(mj4 + 6*mj2*mS2 + mi2*(mj2 + 2*mS2) + 2*mS4)*ScalarC0(mi2,mj2,mS,mS,mF2) + mj2*(mi2*(-mi + mj)*(mi + mj)*(mi4 + mj2*mS2 + 11*mi2*(mj2 + mS2)) - (mi - mS)*(mi + mS)*(3*mi2*mj2*(3*mi2 + mj2) + (8*mi4 + 5*mi2*mj2 - mj4)*mS2)*std::log(mS2/(-mi2 + mS2))) + mi4*(mj - mS)*(mj + mS)*(7*mj4 + 11*mj2*mS2 + mi2*(5*mj2 + mS2))*std::log(mS2/(-mj2 + mS2))))/(mj2*Power3(-mi3 + mi*mj2)) + (SFin.left()*SFout.right()*(-2*mi2*(mi - mj)*(mi + mj)*mj4*(mi4 + 2*mS2*(mj2 + mS2) + mi2*(mj2 + 6*mS2))*ScalarC0(mi2,mj2,mS,mS,mF2) - mj4*(mi - mS)*(mi + mS)*(7*mi4 + mj2*mS2 + mi2*(5*mj2 + 11*mS2))*std::log(mS2/(-mi2 + mS2)) + mi2*(mj2*(-mi2 + mj2)*(mj4 + 11*mj2*mS2 + mi2*(11*mj2 + mS2)) + (mj - mS)*(mj + mS)*(3*mi2*mj2*(mi2 + 3*mj2) + (-mi4 + 5*mi2*mj2 + 8*mj4)*mS2)*std::log(mS2/(-mj2 + mS2)))))/(mi2*mj3*Power3(mi - mj)*Power3(mi + mj));
        }
      }
    }
  } else {
    const auto r = Power2(mF/mS);
    if (std::max(mS,mF) > approx_limit * std::max(mi,mj)) {
      // eq. 15 of hep-ph/9510309 (possibly with different sign)
      return - 1./18. * SFout.right() * SFin.left() * OneLoopFunctionA(r) / mS2;
    } else {
      if (is_zero(mi-mj)) {
        return (SFin.left()*SFout.right()*(mi2*(2*mF2 + 3*mi2 - 2*mS2) + (2*mi2*DiscontinuityB(mi2,mF,mS)*(mF6 - 3*mF4*mS2 + 3*mF2*mS2*(-mi2 + mS2) + Power3(mi2 - mS2)))/KallenLambda(mF2,mi2,mS2) - (mF4 + mF2*(mi2 - 2*mS2) + Power2(mi2 - mS2))*std::log(r)))/(6.*Power5(mi)) + (SFin.right()*SFout.left()*(mi2*(-2*mF2 - 3*mi2 + 2*mS2) - (2*mi2*DiscontinuityB(mi2,mF,mS)*(mF6 - 3*mF4*mS2 + 3*mF2*mS2*(-mi2 + mS2) + Power3(mi2 - mS2)))/KallenLambda(mF2,mi2,mS2) + (mF4 + mF2*(mi2 - 2*mS2) + Power2(mi2 - mS2))*std::log(r)))/(6.*Power5(mi));
      } else {
        return (mF*SFin.left()*SFout.left()*(-2*mi2*mj2*(3*mi2 + mj2)*DiscontinuityB(mi2,mF,mS) + 2*mi2*mj2*(mi2 + 3*mj2)*DiscontinuityB(mj2,mF,mS) + (mi - mj)*(mi + mj)*(-8*mi2*mj2 - 2*mi2*mj2*(-2*mF2 + mi2 + mj2 + 2*mS2)*ScalarC0(mi2,mj2,mS,mS,mF) + (2*mi2*mj2 - mF2*(mi2 + mj2) + (mi2 + mj2)*mS2)*std::log(r))))/(mi2*mj2*Power2(mi2 - mj2)) - (SFin.left()*SFout.right()*(2*mi2*mj4*(7*mi4 - mF2*(11*mi2 + mj2) + mj2*mS2 + mi2*(5*mj2 + 11*mS2))*DiscontinuityB(mi2,mF,mS) - 2*mi2*mj2*(3*mi2*mj2*(mi2 + 3*mj2) + mF2*(mi4 - 5*mi2*mj2 - 8*mj4) + (-mi4 + 5*mi2*mj2 + 8*mj4)*mS2)*DiscontinuityB(mj2,mF,mS) + (mi - mj)*(mi + mj)*(2*mi2*mj2*(-(mF2*(mi2 + 11*mj2)) + mj4 + 11*mj2*mS2 + mi2*(11*mj2 + mS2)) + 4*mi2*mj4*(2*mF4 + mi4 + 2*mS2*(mj2 + mS2) - mF2*(3*mi2 + mj2 + 4*mS2) + mi2*(mj2 + 6*mS2))*ScalarC0(mi2,mj2,mS,mS,mF) + (mF4*(mi4 - 4*mi2*mj2 - mj4) - 4*mi2*mj2*mS2*(3*mj2 + mS2) + 2*mF2*(mi4*(mj - mS)*(mj + mS) + mj4*mS2 + mi2*(3*mj4 + 4*mj2*mS2)) - mj4*mS4 + mi4*(-4*mj4 - 4*mj2*mS2 + mS4))*std::log(r))))/(2.*mi2*mj3*Power3(mi - mj)*Power3(mi + mj)) + (SFin.right()*SFout.left()*(2*mi2*mj2*(mF2*(-8*mi4 - 5*mi2*mj2 + mj4) - mj4*mS2 + mi4*(9*mj2 + 8*mS2) + mi2*(3*mj4 + 5*mj2*mS2))*DiscontinuityB(mi2,mF,mS) - 2*mi4*mj2*(-(mF2*(mi2 + 11*mj2)) + 7*mj4 + 11*mj2*mS2 + mi2*(5*mj2 + mS2))*DiscontinuityB(mj2,mF,mS) + (mi2 - mj2)*(2*mi2*mj2*(mi4 - mF2*(11*mi2 + mj2) + mj2*mS2 + 11*mi2*(mj2 + mS2)) + 4*mi4*mj2*(2*mF4 + mj4 + 6*mj2*mS2 + mi2*(mj2 + 2*mS2) - mF2*(mi2 + 3*mj2 + 4*mS2) + 2*mS4)*ScalarC0(mi2,mj2,mS,mS,mF) - (mF4*(mi4 + 4*mi2*mj2 - mj4) + 4*mi2*mj2*mS2*(mj2 + mS2) - 2*mF2*(-(mj4*mS2) + mi4*(3*mj2 + mS2) + mi2*(mj4 + 4*mj2*mS2)) - mj4*mS4 + mi4*(4*mj4 + 12*mj2*mS2 + mS4))*std::log(r))))/(2.*mj2*Power3(mi3 - mi*mj2));
      }
    }
  }
}

std::complex<double> FFV_SSF_A1R(double mi, double mj, double mF, double mS, auto SFin, auto SFout)
{
  const double mi2=Power2(mi);
  const double mi3=Power3(mi);
  const double mi4=Power4(mi);
  const double mi6=Power6(mi);
  const double mj2=Power2(mj);
  const double mj3=Power3(mj);
  const double mj4=Power4(mj);
  const double mj6=Power6(mj);
  const double mF2=Power2(mF);
  const double mF4=Power4(mF);
  const double mF6=Power6(mF);
  const double mS2=Power2(mS);
  const double mS4=Power4(mS);
  const double mS6=Power6(mS);
  const double pi2=Power2(M_PI);
  if (is_zero(mF)) {
    const auto r = Power2(mF/mS);
    if (mS > approx_limit * std::max(mi,mj)) {
      // eq. 15 of hep-ph/9510309 after replacement L <-> R (possibly with different sign)
      return - 1./18. * SFout.left() * SFin.right() * OneLoopFunctionA(r) / mS2;
    } else {
      if (is_zero(mi-mj)) {
        if (is_zero(mi-mS)) {
          return (SFin.right()*SFout.left())/(6.*mi) - (SFin.left()*SFout.right())/(6.*mi);
        } else {
          return (SFin.left()*SFout.right()*(-3*mi4 + 2*mi2*mS2 - 2*Power2(mi2 - mS2)*std::log(mS2/(-mi2 + mS2))))/(6.*Power5(mi)) + (SFin.right()*SFout.left()*(3*mi4 - 2*mi2*mS2 + 2*Power2(mi2 - mS2)*std::log(mS2/(-mi2 + mS2))))/(6.*Power5(mi));
        }
      } else {
        if (is_zero(mi-mS)) {
          return (mi*SFin.left()*SFout.right()*(4*mi4*mj2*(-9 + pi2) + 7*mi2*mj4*pi2 + mj6*(36 + pi2) + 6*(4*mi4*mj2 + 7*mi2*mj4 + mj6)*dilog(mj2/(-mi2 + mj2)) + 3*mj2*(4*mi4 + 7*mi2*mj2 + mj4)*Power2(std::log(mi2/(mi2 - mj2))) + 3*(-mi + mj)*(mi + mj)*(mi4 + 16*mi2*mj2 + 7*mj4)*std::log(mi2/(mi2 - mj2))))/(3.*mj2*Power3(-mi2 + mj2)) + (SFin.right()*SFout.left()*(-(mi6*mj2) + 3*mi4*mj4*(-7 + pi2) + mi2*mj6*(21 + pi2) + 6*mi2*(3*mi2 + mj2)*mj4*dilog(mj2/(-mi2 + mj2)) + Power8(mj) + mi2*std::log(mi2/(mi2 - mj2))*(mi6 - 9*mi4*mj2 - 9*mi2*mj4 + 17*mj6 + 3*(3*mi2*mj4 + mj6)*std::log(mi2/(mi2 - mj2)))))/(mj3*Power3(mi2 - mj2));
        } else if (is_zero(mj-mS)) {
          return (SFin.left()*SFout.right()*(-(mi2*mj6) + 3*mi4*mj4*(-7 + pi2) + mi6*mj2*(21 + pi2) + 6*mi4*mj2*(mi2 + 3*mj2)*dilog(mi2/(mi2 - mj2)) + Power8(mi) + mj2*std::log(mj2/(-mi2 + mj2))*(17*mi6 - 9*mi4*mj2 - 9*mi2*mj4 + mj6 + 3*(mi6 + 3*mi4*mj2)*std::log(mj2/(-mi2 + mj2)))))/Power3(mi3 - mi*mj2) - (mj*SFin.right()*SFout.left()*(4*mi2*mj4*(-9 + pi2) + 7*mi4*mj2*pi2 + mi6*(36 + pi2) + 6*(mi6 + 7*mi4*mj2 + 4*mi2*mj4)*dilog(mi2/(mi2 - mj2)) + 3*std::log(mj2/(-mi2 + mj2))*((mi - mj)*(mi + mj)*(7*mi4 + 16*mi2*mj2 + mj4) + (mi6 + 7*mi4*mj2 + 4*mi2*mj4)*std::log(mj2/(-mi2 + mj2)))))/(3.*mi2*Power3(mi - mj)*Power3(mi + mj));
        } else {
          return (SFin.left()*SFout.right()*(-2*mi4*(mi - mj)*(mi + mj)*mj2*(mj4 + 6*mj2*mS2 + mi2*(mj2 + 2*mS2) + 2*mS4)*ScalarC0(mi2,mj2,mS,mS,mF2) + mj2*(mi2*(-mi + mj)*(mi + mj)*(mi4 + mj2*mS2 + 11*mi2*(mj2 + mS2)) - (mi - mS)*(mi + mS)*(3*mi2*mj2*(3*mi2 + mj2) + (8*mi4 + 5*mi2*mj2 - mj4)*mS2)*std::log(mS2/(-mi2 + mS2))) + mi4*(mj - mS)*(mj + mS)*(7*mj4 + 11*mj2*mS2 + mi2*(5*mj2 + mS2))*std::log(mS2/(-mj2 + mS2))))/(mj2*Power3(-mi3 + mi*mj2)) + (SFin.right()*SFout.left()*(-2*mi2*(mi - mj)*(mi + mj)*mj4*(mi4 + 2*mS2*(mj2 + mS2) + mi2*(mj2 + 6*mS2))*ScalarC0(mi2,mj2,mS,mS,mF2) - mj4*(mi - mS)*(mi + mS)*(7*mi4 + mj2*mS2 + mi2*(5*mj2 + 11*mS2))*std::log(mS2/(-mi2 + mS2)) + mi2*(mj2*(-mi2 + mj2)*(mj4 + 11*mj2*mS2 + mi2*(11*mj2 + mS2)) + (mj - mS)*(mj + mS)*(3*mi2*mj2*(mi2 + 3*mj2) + (-mi4 + 5*mi2*mj2 + 8*mj4)*mS2)*std::log(mS2/(-mj2 + mS2)))))/(mi2*mj3*Power3(mi - mj)*Power3(mi + mj));
        }
      }
    }
  } else {
    const auto r = Power2(mF/mS);
    if (std::max(mS,mF) > approx_limit * std::max(mi,mj)) {
      // eq. 15 of hep-ph/9510309 after replacement L <-> R (possibly with different sign)
      return - 1./18. * SFout.left() * SFin.right() * OneLoopFunctionA(r) / mS2;
    } else {
      if (is_zero(mi-mj)) {
        return (SFin.right()*SFout.left()*(mi2*(2*mF2 + 3*mi2 - 2*mS2) + (2*mi2*DiscontinuityB(mi2,mF,mS)*(mF6 - 3*mF4*mS2 + 3*mF2*mS2*(-mi2 + mS2) + Power3(mi2 - mS2)))/KallenLambda(mF2,mi2,mS2) - (mF4 + mF2*(mi2 - 2*mS2) + Power2(mi2 - mS2))*std::log(r)))/(6.*Power5(mi)) + (SFin.left()*SFout.right()*(mi2*(-2*mF2 - 3*mi2 + 2*mS2) - (2*mi2*DiscontinuityB(mi2,mF,mS)*(mF6 - 3*mF4*mS2 + 3*mF2*mS2*(-mi2 + mS2) + Power3(mi2 - mS2)))/KallenLambda(mF2,mi2,mS2) + (mF4 + mF2*(mi2 - 2*mS2) + Power2(mi2 - mS2))*std::log(r)))/(6.*Power5(mi));
      } else {
        return (mF*SFin.right()*SFout.right()*(-2*mi2*mj2*(3*mi2 + mj2)*DiscontinuityB(mi2,mF,mS) + 2*mi2*mj2*(mi2 + 3*mj2)*DiscontinuityB(mj2,mF,mS) + (mi - mj)*(mi + mj)*(-8*mi2*mj2 - 2*mi2*mj2*(-2*mF2 + mi2 + mj2 + 2*mS2)*ScalarC0(mi2,mj2,mS,mS,mF) + (2*mi2*mj2 - mF2*(mi2 + mj2) + (mi2 + mj2)*mS2)*std::log(r))))/(mi2*mj2*Power2(mi2 - mj2)) - (SFin.right()*SFout.left()*(2*mi2*mj4*(7*mi4 - mF2*(11*mi2 + mj2) + mj2*mS2 + mi2*(5*mj2 + 11*mS2))*DiscontinuityB(mi2,mF,mS) - 2*mi2*mj2*(3*mi2*mj2*(mi2 + 3*mj2) + mF2*(mi4 - 5*mi2*mj2 - 8*mj4) + (-mi4 + 5*mi2*mj2 + 8*mj4)*mS2)*DiscontinuityB(mj2,mF,mS) + (mi - mj)*(mi + mj)*(2*mi2*mj2*(-(mF2*(mi2 + 11*mj2)) + mj4 + 11*mj2*mS2 + mi2*(11*mj2 + mS2)) + 4*mi2*mj4*(2*mF4 + mi4 + 2*mS2*(mj2 + mS2) - mF2*(3*mi2 + mj2 + 4*mS2) + mi2*(mj2 + 6*mS2))*ScalarC0(mi2,mj2,mS,mS,mF) + (mF4*(mi4 - 4*mi2*mj2 - mj4) - 4*mi2*mj2*mS2*(3*mj2 + mS2) + 2*mF2*(mi4*(mj - mS)*(mj + mS) + mj4*mS2 + mi2*(3*mj4 + 4*mj2*mS2)) - mj4*mS4 + mi4*(-4*mj4 - 4*mj2*mS2 + mS4))*std::log(r))))/(2.*mi2*mj3*Power3(mi - mj)*Power3(mi + mj)) + (SFin.left()*SFout.right()*(2*mi2*mj2*(mF2*(-8*mi4 - 5*mi2*mj2 + mj4) - mj4*mS2 + mi4*(9*mj2 + 8*mS2) + mi2*(3*mj4 + 5*mj2*mS2))*DiscontinuityB(mi2,mF,mS) - 2*mi4*mj2*(-(mF2*(mi2 + 11*mj2)) + 7*mj4 + 11*mj2*mS2 + mi2*(5*mj2 + mS2))*DiscontinuityB(mj2,mF,mS) + (mi2 - mj2)*(2*mi2*mj2*(mi4 - mF2*(11*mi2 + mj2) + mj2*mS2 + 11*mi2*(mj2 + mS2)) + 4*mi4*mj2*(2*mF4 + mj4 + 6*mj2*mS2 + mi2*(mj2 + 2*mS2) - mF2*(mi2 + 3*mj2 + 4*mS2) + 2*mS4)*ScalarC0(mi2,mj2,mS,mS,mF) - (mF4*(mi4 + 4*mi2*mj2 - mj4) + 4*mi2*mj2*mS2*(mj2 + mS2) - 2*mF2*(-(mj4*mS2) + mi4*(3*mj2 + mS2) + mi2*(mj4 + 4*mj2*mS2)) - mj4*mS4 + mi4*(4*mj4 + 12*mj2*mS2 + mS4))*std::log(r))))/(2.*mj2*Power3(mi3 - mi*mj2));
      }
    }
  }
}

std::complex<double> FFV_SSF_A2L(double mi, double mj, double mF, double mS, auto SFin, auto SFout)
{
  const double mi2=Power2(mi);
  const double mi3=Power3(mi);
  const double mi4=Power4(mi);
  const double mi6=Power6(mi);
  const double mj2=Power2(mj);
  const double mj3=Power3(mj);
  const double mj4=Power4(mj);
  const double mj6=Power6(mj);
  const double mF2=Power2(mF);
  const double mF4=Power4(mF);
  const double mF6=Power6(mF);
  const double mS2=Power2(mS);
  const double mS4=Power4(mS);
  const double mS6=Power6(mS);
  const double pi2=Power2(M_PI);
  if (is_zero(mF)) {
    const auto r = Power2(mF/mS);
    if (mS > approx_limit * std::max(mi,mj)) {
      // eq. 16 of hep-ph/9510309 (possibly with different sign)
      return - SFout.left() * SFin.right() * OneLoopFunctionB(r)/12. / mS2
             - SFout.left() * SFin.left() * mF/mj * OneLoopFunctionC(r)/3. / mS2
             - mi/mj * SFout.right() * SFin.left() * OneLoopFunctionB(r)/12. / mS2; 
    } else {
      if (is_zero(mi-mj)) {
        if (is_zero(mi-mS)) {
          return -(SFin.right()*SFout.left())/(2.*mi2) - (SFin.left()*SFout.right())/(2.*mi2);
        } else {
          return (SFin.right()*SFout.left()*(mi4 - 2*mi2*mS2 + 2*(-mi + mS)*(mi + mS)*mS2*std::log(mS2/(-mi2 + mS2))))/(2.*mi6) + (SFin.left()*SFout.right()*(mi4 - 2*mi2*mS2 + 2*(-mi + mS)*(mi + mS)*mS2*std::log(mS2/(-mi2 + mS2))))/(2.*mi6);
        }
      } else {
        if (is_zero(mi-mS)) {
          return -(SFin.right()*SFout.left()*(6*mj4 + mi2*mj2*(-6 + pi2) + 6*mi2*mj2*dilog(mj2/(-mi2 + mj2)) + 3*std::log(mi2/(mi2 - mj2))*(-mi4 + mj4 + mi2*mj2*std::log(mi2/(mi2 - mj2)))))/(3.*Power2(-(mi2*mj) + mj3)) + (SFin.left()*SFout.right()*(-3*mi4*mj2 + 3*mj6 + mi2*mj4*pi2 + 6*mi2*mj4*dilog(mj2/(-mi2 + mj2)) + 3*mi2*std::log(mi2/(mi2 - mj2))*(mi4 - 4*mi2*mj2 + 3*mj4 + mj4*std::log(mi2/(mi2 - mj2)))))/(3.*mi*mj3*Power2(mi2 - mj2));
        } else if (is_zero(mj-mS)) {
          return (SFin.right()*SFout.left()*(3*mi6 - 3*mi2*mj4 + mi4*mj2*pi2 + 6*mi4*mj2*dilog(mi2/(mi2 - mj2)) + 3*mj2*std::log(mj2/(-mi2 + mj2))*(3*mi4 - 4*mi2*mj2 + mj4 + mi4*std::log(mj2/(-mi2 + mj2)))))/(3.*mi4*Power2(mi2 - mj2)) - (mj*SFin.left()*SFout.right()*(6*mi4 + mi2*mj2*(-6 + pi2) + 6*mi2*mj2*dilog(mi2/(mi2 - mj2)) + 3*std::log(mj2/(-mi2 + mj2))*(mi4 - mj4 + mi2*mj2*std::log(mj2/(-mi2 + mj2)))))/(3.*mi3*Power2(mi2 - mj2));
        } else {
          return (SFin.right()*SFout.left()*(2*mi4*(mi - mj)*(mi + mj)*mj2*mS2*ScalarC0(mi2,mj2,mS,mS,mF2) + mj2*(mi2*(mi - mj)*(mi + mj)*(mi2 + mS2) + (mi - mS)*(mi + mS)*(-(mj2*mS2) + mi2*(mj2 + 2*mS2))*std::log(mS2/(-mi2 + mS2))) + mi4*(-mj4 + mS4)*std::log(mS2/(-mj2 + mS2))))/(mi4*mj2*Power2(mi2 - mj2)) + (SFin.left()*SFout.right()*(2*mi2*(-mi2 + mj2)*mj4*mS2*ScalarC0(mi2,mj2,mS,mS,mF2) + mj4*(-mi4 + mS4)*std::log(mS2/(-mi2 + mS2)) + mi2*((-mi + mj)*(mi + mj)*mj2*(mj2 + mS2) + (mj - mS)*(mj + mS)*(mi2*(mj - mS)*(mj + mS) + 2*mj2*mS2)*std::log(mS2/(-mj2 + mS2)))))/(mi3*mj3*Power2(mi2 - mj2));
        }
      }
    }
  } else {
    const auto r = Power2(mF/mS);
    if (std::max(mS,mF) > approx_limit * std::max(mi,mj)) {
      // eq. 16 of hep-ph/9510309 (possibly with different sign)
      return - SFout.left() * SFin.right() * OneLoopFunctionB(r)/12. / mS2
             - SFout.left() * SFin.left() * mF/mj * OneLoopFunctionC(r)/3. / mS2
             - mi/mj * SFout.right() * SFin.left() * OneLoopFunctionB(r)/12. / mS2; 
    } else {
      if (is_zero(mi-mj)) {
        return (mF*SFin.left()*SFout.left()*(2*mi2 + (2*mi2*(mF4 - mi2*mS2 - mF2*(mi2 + 2*mS2) + mS4)*DiscontinuityB(mi2,mF,mS))/KallenLambda(mF2,mi2,mS2) + (-mF2 + mS2)*std::log(r)))/Power5(mi) + (SFin.right()*SFout.left()*(mi2*(2*mF2 + mi2 - 2*mS2) - (2*mi2*DiscontinuityB(mi2,mF,mS)*(-mF6 + mF2*(mi2 - 3*mS2)*mS2 + mF4*(mi2 + 3*mS2) + Power2(-(mi2*mS) + Power(mS,3))))/KallenLambda(mF2,mi2,mS2) - (mF4 - (2*mF2 + mi2)*mS2 + mS4)*std::log(r)))/(2.*mi6) + (SFin.left()*SFout.right()*(mi2*(2*mF2 + mi2 - 2*mS2) - (2*mi2*DiscontinuityB(mi2,mF,mS)*(-mF6 + mF2*(mi2 - 3*mS2)*mS2 + mF4*(mi2 + 3*mS2) + Power2(-(mi2*mS) + Power(mS,3))))/KallenLambda(mF2,mi2,mS2) - (mF4 - (2*mF2 + mi2)*mS2 + mS4)*std::log(r)))/(2.*mi6);
      } else {
        return (mF*SFin.left()*SFout.left()*((2*mi2*(-DiscontinuityB(mi2,mF,mS) + DiscontinuityB(mj2,mF,mS)))/((mi - mj)*(mi + mj)) + ((-mF2 + mS2)*std::log(r))/mj2))/mi3 - (SFin.left()*SFout.right()*(2*mi2*mj4*(-mF2 + mi2 + mS2)*DiscontinuityB(mi2,mF,mS) - 2*mi2*mj2*(mF2*(mi2 - 2*mj2) + mi2*(mj - mS)*(mj + mS) + 2*mj2*mS2)*DiscontinuityB(mj2,mF,mS) + (mi - mj)*(mi + mj)*(2*mi2*mj2*(-mF2 + mj2 + mS2) + 4*mi2*mj4*mS2*ScalarC0(mi2,mj2,mS,mS,mF) + (mF4*(mi - mj)*(mi + mj) - 2*(mF2*(mi - mj)*(mi + mj) + mi2*mj2)*mS2 + (mi - mj)*(mi + mj)*mS4)*std::log(r))))/(2.*mi3*mj3*Power2(mi - mj)*Power2(mi + mj)) + (SFin.right()*SFout.left()*(2*mi2*mj2*(mF2*(-2*mi2 + mj2) - mj2*mS2 + mi2*(mj2 + 2*mS2))*DiscontinuityB(mi2,mF,mS) - 2*mi4*mj2*(-mF2 + mj2 + mS2)*DiscontinuityB(mj2,mF,mS) + (mi - mj)*(mi + mj)*(2*mi2*mj2*(-mF2 + mi2 + mS2) + 4*mi4*mj2*mS2*ScalarC0(mi2,mj2,mS,mS,mF) + (mF4*(-mi2 + mj2) + 2*(mF2*mi2 - (mF2 + mi2)*mj2)*mS2 + (-mi2 + mj2)*mS4)*std::log(r))))/(2.*mi4*mj2*Power2(mi - mj)*Power2(mi + mj));
      }
    }
  }
}
  
std::complex<double> FFV_SSF_A2R(double mi, double mj, double mF, double mS, auto SFin, auto SFout)
{
  const double mi2=Power2(mi);
  const double mi3=Power3(mi);
  const double mi4=Power4(mi);
  const double mi6=Power6(mi);
  const double mj2=Power2(mj);
  const double mj3=Power3(mj);
  const double mj4=Power4(mj);
  const double mj6=Power6(mj);
  const double mF2=Power2(mF);
  const double mF4=Power4(mF);
  const double mF6=Power6(mF);
  const double mS2=Power2(mS);
  const double mS4=Power4(mS);
  const double mS6=Power6(mS);
  const double pi2=Power2(M_PI);
  if (is_zero(mF)) {
    const auto r = Power2(mF/mS);
    if (mS > approx_limit * std::max(mi,mj)) {
      // eq. 15 of hep-ph/9510309 after replacement L <-> R (possibly with different sign)
      return - SFout.right() * SFin.left() * OneLoopFunctionB(r)/12. / mS2
             - SFout.right() * SFin.right() * mF/mj * OneLoopFunctionC(r)/3. / mS2
             - mi/mj * SFout.left() * SFin.right() * OneLoopFunctionB(r)/12. / mS2; 
    } else {
      if (is_zero(mi-mj)) {
        if (is_zero(mi-mS)) {
          return -(SFin.right()*SFout.left())/(2.*mi2) - (SFin.left()*SFout.right())/(2.*mi2);
        } else {
          return (SFin.right()*SFout.left()*(mi4 - 2*mi2*mS2 + 2*(-mi + mS)*(mi + mS)*mS2*std::log(mS2/(-mi2 + mS2))))/(2.*mi6) + (SFin.left()*SFout.right()*(mi4 - 2*mi2*mS2 + 2*(-mi + mS)*(mi + mS)*mS2*std::log(mS2/(-mi2 + mS2))))/(2.*mi6);
        }
      } else {
        if (is_zero(mi-mS)) {
          return -(SFin.left()*SFout.right()*(6*mj4 + mi2*mj2*(-6 + pi2) + 6*mi2*mj2*dilog(mj2/(-mi2 + mj2)) + 3*std::log(mi2/(mi2 - mj2))*(-mi4 + mj4 + mi2*mj2*std::log(mi2/(mi2 - mj2)))))/(3.*Power2(-(mi2*mj) + mj3)) + (SFin.right()*SFout.left()*(-3*mi4*mj2 + 3*mj6 + mi2*mj4*pi2 + 6*mi2*mj4*dilog(mj2/(-mi2 + mj2)) + 3*mi2*std::log(mi2/(mi2 - mj2))*(mi4 - 4*mi2*mj2 + 3*mj4 + mj4*std::log(mi2/(mi2 - mj2)))))/(3.*mi*mj3*Power2(mi2 - mj2));
        } else if (is_zero(mj-mS)) {
          return (SFin.left()*SFout.right()*(3*mi6 - 3*mi2*mj4 + mi4*mj2*pi2 + 6*mi4*mj2*dilog(mi2/(mi2 - mj2)) + 3*mj2*std::log(mj2/(-mi2 + mj2))*(3*mi4 - 4*mi2*mj2 + mj4 + mi4*std::log(mj2/(-mi2 + mj2)))))/(3.*mi4*Power2(mi2 - mj2)) - (mj*SFin.right()*SFout.left()*(6*mi4 + mi2*mj2*(-6 + pi2) + 6*mi2*mj2*dilog(mi2/(mi2 - mj2)) + 3*std::log(mj2/(-mi2 + mj2))*(mi4 - mj4 + mi2*mj2*std::log(mj2/(-mi2 + mj2)))))/(3.*mi3*Power2(mi2 - mj2));
        } else {
          return (SFin.left()*SFout.right()*(2*mi4*(mi - mj)*(mi + mj)*mj2*mS2*ScalarC0(mi2,mj2,mS,mS,mF2) + mj2*(mi2*(mi - mj)*(mi + mj)*(mi2 + mS2) + (mi - mS)*(mi + mS)*(-(mj2*mS2) + mi2*(mj2 + 2*mS2))*std::log(mS2/(-mi2 + mS2))) + mi4*(-mj4 + mS4)*std::log(mS2/(-mj2 + mS2))))/(mi4*mj2*Power2(mi2 - mj2)) + (SFin.right()*SFout.left()*(2*mi2*(-mi2 + mj2)*mj4*mS2*ScalarC0(mi2,mj2,mS,mS,mF2) + mj4*(-mi4 + mS4)*std::log(mS2/(-mi2 + mS2)) + mi2*((-mi + mj)*(mi + mj)*mj2*(mj2 + mS2) + (mj - mS)*(mj + mS)*(mi2*(mj - mS)*(mj + mS) + 2*mj2*mS2)*std::log(mS2/(-mj2 + mS2)))))/(mi3*mj3*Power2(mi2 - mj2));
        }
      }
    }
  } else {
    const auto r = Power2(mF/mS);
    if (std::max(mS,mF) > approx_limit * std::max(mi,mj)) {
      // eq. 15 of hep-ph/9510309 after replacement L <-> R (possibly with different sign)
      return - SFout.right() * SFin.left() * OneLoopFunctionB(r)/12. / mS2
             - SFout.right() * SFin.right() * mF/mj * OneLoopFunctionC(r)/3. / mS2
             - mi/mj * SFout.left() * SFin.right() * OneLoopFunctionB(r)/12. / mS2; 
    } else {
      if (is_zero(mi-mj)) {
        return (mF*SFin.right()*SFout.right()*(2*mi2 + (2*mi2*(mF4 - mi2*mS2 - mF2*(mi2 + 2*mS2) + mS4)*DiscontinuityB(mi2,mF,mS))/KallenLambda(mF2,mi2,mS2) + (-mF2 + mS2)*std::log(r)))/Power5(mi) + (SFin.right()*SFout.left()*(mi2*(2*mF2 + mi2 - 2*mS2) - (2*mi2*DiscontinuityB(mi2,mF,mS)*(-mF6 + mF2*(mi2 - 3*mS2)*mS2 + mF4*(mi2 + 3*mS2) + Power2(-(mi2*mS) + Power(mS,3))))/KallenLambda(mF2,mi2,mS2) - (mF4 - (2*mF2 + mi2)*mS2 + mS4)*std::log(r)))/(2.*mi6) + (SFin.left()*SFout.right()*(mi2*(2*mF2 + mi2 - 2*mS2) - (2*mi2*DiscontinuityB(mi2,mF,mS)*(-mF6 + mF2*(mi2 - 3*mS2)*mS2 + mF4*(mi2 + 3*mS2) + Power2(-(mi2*mS) + Power(mS,3))))/KallenLambda(mF2,mi2,mS2) - (mF4 - (2*mF2 + mi2)*mS2 + mS4)*std::log(r)))/(2.*mi6);
      } else {
        return (mF*SFin.right()*SFout.right()*((2*mi2*(-DiscontinuityB(mi2,mF,mS) + DiscontinuityB(mj2,mF,mS)))/((mi - mj)*(mi + mj)) + ((-mF2 + mS2)*std::log(r))/mj2))/mi3 - (SFin.right()*SFout.left()*(2*mi2*mj4*(-mF2 + mi2 + mS2)*DiscontinuityB(mi2,mF,mS) - 2*mi2*mj2*(mF2*(mi2 - 2*mj2) + mi2*(mj - mS)*(mj + mS) + 2*mj2*mS2)*DiscontinuityB(mj2,mF,mS) + (mi - mj)*(mi + mj)*(2*mi2*mj2*(-mF2 + mj2 + mS2) + 4*mi2*mj4*mS2*ScalarC0(mi2,mj2,mS,mS,mF) + (mF4*(mi - mj)*(mi + mj) - 2*(mF2*(mi - mj)*(mi + mj) + mi2*mj2)*mS2 + (mi - mj)*(mi + mj)*mS4)*std::log(r))))/(2.*mi3*mj3*Power2(mi - mj)*Power2(mi + mj)) + (SFin.left()*SFout.right()*(2*mi2*mj2*(mF2*(-2*mi2 + mj2) - mj2*mS2 + mi2*(mj2 + 2*mS2))*DiscontinuityB(mi2,mF,mS) - 2*mi4*mj2*(-mF2 + mj2 + mS2)*DiscontinuityB(mj2,mF,mS) + (mi - mj)*(mi + mj)*(2*mi2*mj2*(-mF2 + mi2 + mS2) + 4*mi4*mj2*mS2*ScalarC0(mi2,mj2,mS,mS,mF) + (mF4*(-mi2 + mj2) + 2*(mF2*mi2 - (mF2 + mi2)*mj2)*mS2 + (-mi2 + mj2)*mS4)*std::log(r))))/(2.*mi4*mj2*Power2(mi - mj)*Power2(mi + mj));
      }
    }
  }
}


std::complex<double> FFV_FFS_A1L(double mi, double mj, double mF, double mS, auto SFin, auto SFout)
{
  const double mi2=Power2(mi);
  const double mi3=Power3(mi);
  const double mi4=Power4(mi);
  const double mi6=Power6(mi);
  const double mj2=Power2(mj);
  const double mj3=Power3(mj);
  const double mj4=Power4(mj);
  const double mj6=Power6(mj);
  const double mF2=Power2(mF);
  const double mF4=Power4(mF);
  const double mF6=Power6(mF);
  const double mS2=Power2(mS);
  const double mS4=Power4(mS);
  const double mS6=Power6(mS);
  const double pi2=Power2(M_PI);
  if (is_zero(mS)) {
    if (is_zero(mi-mj)) {
      if (is_zero(mi-mF)) {
        return (5*SFin.right()*SFout.left())/(6.*mi) - \
(5*SFin.left()*SFout.right())/(6.*mi);
      } else {
        return (SFin.right()*SFout.left()*(2*mF2*mi2 + 3*mi4 - 2*(mF4 + \
mF2*mi2 - 2*mi4)*std::log(mF2/(mF2 - mi2))))/(6.*Power5(mi)) + \
(SFin.left()*SFout.right()*(-2*mF2*mi2 - 3*mi4 + 2*(mF4 + mF2*mi2 - \
2*mi4)*std::log(mF2/(mF2 - mi2))))/(6.*Power5(mi));
      }
    } else {
      if (is_zero(mi-mF)) {
        return (mi*SFin.left()*SFout.left()*(-3*mi2*mj2*(-8 + pi2) - \
mj4*(24 + pi2) - 6*(3*mi2*mj2 + mj4)*dilog(mj2/(-mi2 + mj2)) - \
3*mj2*(3*mi2 + mj2)*Power2(std::log(mi2/(mi2 - mj2))) + 6*(mi4 + \
2*mi2*mj2 - 3*mj4)*std::log(mi2/(mi2 - mj2))))/(3.*Power2(-(mi2*mj) + \
mj3)) + (mi*SFin.right()*SFout.left()*(24*mj6 + mi4*mj2*(-48 + 5*pi2) + \
mi2*mj4*(24 + 7*pi2) + 6*(5*mi4*mj2 + 7*mi2*mj4)*dilog(mj2/(-mi2 + \
mj2)) + 3*mi2*mj2*(5*mi2 + 7*mj2)*Power2(std::log(mi2/(mi2 - mj2))) + \
3*(-mi + mj)*(mi + mj)*(mi4 + 20*mi2*mj2 + 3*mj4)*std::log(mi2/(mi2 - \
mj2))))/(3.*mj2*Power3(-mi2 + mj2)) + \
(SFin.left()*SFout.right()*(-3*mi6*mj2 + mi2*mj6*(39 + 5*pi2) + \
mi4*mj4*(-51 + 7*pi2) + 6*(7*mi4*mj4 + 5*mi2*mj6)*dilog(mj2/(-mi2 + \
mj2)) + 15*Power8(mj) + 3*std::log(mi2/(mi2 - mj2))*(-7*mi6*mj2 - \
11*mi4*mj4 + 15*mi2*mj6 + Power8(mi) + 2*Power8(mj) + (7*mi4*mj4 + \
5*mi2*mj6)*std::log(mi2/(mi2 - mj2)))))/(3.*mj3*Power3(mi2 - mj2));
      } else if (is_zero(mj-mF)) {
        return (mj*SFin.left()*SFout.left()*(3*mi2*mj2*(-8 + pi2) + \
mi4*(24 + pi2) + 6*(mi4 + 3*mi2*mj2)*dilog(mi2/(mi2 - mj2)) + \
3*mi2*(mi2 + 3*mj2)*Power2(std::log(mj2/(-mi2 + mj2))) + 6*(mi - \
mj)*(mi + mj)*(3*mi2 + mj2)*std::log(mj2/(-mi2 + mj2))))/(3.*Power2(mi3 \
- mi*mj2)) + (SFin.right()*SFout.left()*(-3*mi2*mj6 + mi6*mj2*(39 + \
5*pi2) + mi4*mj4*(-51 + 7*pi2) + 6*(5*mi6*mj2 + \
7*mi4*mj4)*dilog(mi2/(mi2 - mj2)) + 15*Power8(mi) + \
3*std::log(mj2/(-mi2 + mj2))*(15*mi6*mj2 - 11*mi4*mj4 - 7*mi2*mj6 + \
2*Power8(mi) + Power8(mj) + mi4*mj2*(5*mi2 + 7*mj2)*std::log(mj2/(-mi2 \
+ mj2)))))/(3.*Power3(mi3 - mi*mj2)) - \
(mj*SFin.left()*SFout.right()*(24*mi6 + mi2*mj4*(-48 + 5*pi2) + \
mi4*mj2*(24 + 7*pi2) + 6*(7*mi4*mj2 + 5*mi2*mj4)*dilog(mi2/(mi2 - \
mj2)) + 3*std::log(mj2/(-mi2 + mj2))*((mi - mj)*(mi + mj)*(3*mi4 + \
20*mi2*mj2 + mj4) + (7*mi4*mj2 + 5*mi2*mj4)*std::log(mj2/(-mi2 + \
mj2)))))/(3.*mi2*Power3(mi - mj)*Power3(mi + mj));
      } else {
        return (2*mF*SFin.left()*SFout.left()*(mi2*(mi - mj)*(mi + \
mj)*mj2*(2*mF2 + mi2 + mj2)*ScalarC0(mi2,mj2,mF,mF,mS2) + \
mj2*(4*mi2*(mi - mj)*(mi + mj) + (-mF + mi)*(mF + mi)*(3*mi2 + \
mj2)*std::log(mF2/(mF2 - mi2))) + mi2*(mF - mj)*(mF + mj)*(mi2 + \
3*mj2)*std::log(mF2/(mF2 - mj2))))/(mi2*mj2*Power2(mi - mj)*Power2(mi + \
mj)) + (SFin.right()*SFout.left()*(-2*mi4*(mi - mj)*(mi + \
mj)*mj2*(2*mF4 + 2*mi2*mj2 + mF2*(3*mi2 + \
5*mj2))*ScalarC0(mi2,mj2,mF,mF,mS2) + mj2*(mi2*(-mi + mj)*(mi + \
mj)*(5*mi4 + 7*mi2*mj2 + mF2*(11*mi2 + mj2)) + (mF - mi)*(mF + \
mi)*(mF2*(8*mi4 + 5*mi2*mj2 - mj4) + mi2*(2*mi4 + 9*mi2*mj2 + \
mj4))*std::log(mF2/(mF2 - mi2))) + mi4*(-mF + mj)*(mF + \
mj)*(3*mj2*(3*mi2 + mj2) + mF2*(mi2 + 11*mj2))*std::log(mF2/(mF2 - \
mj2))))/(mj2*Power3(-mi3 + mi*mj2)) + \
(SFin.left()*SFout.right()*(-2*mi2*(mi - mj)*(mi + mj)*(2*mF4 + \
2*mi2*mj2 + mF2*(5*mi2 + 3*mj2))*mj4*ScalarC0(mi2,mj2,mF,mF,mS2) + \
(mF - mi)*(mF + mi)*(mF2*(11*mi2 + mj2) + 3*mi2*(mi2 + \
3*mj2))*mj4*std::log(mF2/(mF2 - mi2)) + mi2*(mj2*(-mi2 + \
mj2)*(7*mi2*mj2 + mF2*(mi2 + 11*mj2) + 5*mj4) + (-mF + mj)*(mF + \
mj)*(mj2*(mi4 + 9*mi2*mj2 + 2*mj4) + mF2*(-mi4 + 5*mi2*mj2 + \
8*mj4))*std::log(mF2/(mF2 - mj2)))))/(mi2*mj3*Power3(mi - mj)*Power3(mi \
+ mj));
      }
    }
  } else {
    const auto r = Power2(mF/mS);
    if (std::max(mF,mS) > approx_limit * std::max(mi,mj)) {
      // eq. 18 of hep-ph/9510309 (possibly with different sign)
      return - 1./18. * SFout.right() * SFin.left() * OneLoopFunctionD(r) / mS2;
    } else {
      if (is_zero(mi-mj)) {
        return (SFin.right()*SFout.left()*(mi2*(2*mF2 + 3*mi2 - 2*mS2) \
+ (2*mi2*(mF6 - 3*mF2*mi4 + 2*mi6 - 3*mF2*(mF2 + mi2)*mS2 + 3*(mF2 + \
mi2)*mS4 - mS6)*DiscontinuityB(mi2,mF,mS))/KallenLambda(mF2,mi2,mS2) \
- (mF4 + mF2*mi2 - 2*mi4 - 2*(mF2 + mi2)*mS2 + \
mS4)*std::log(r)))/(6.*Power5(mi)) + \
(SFin.left()*SFout.right()*(mi2*(-2*mF2 - 3*mi2 + 2*mS2) + (2*mi2*(-mF6 \
+ 3*mF2*mi4 - 2*mi6 + 3*mF2*(mF2 + mi2)*mS2 - 3*(mF2 + mi2)*mS4 + \
mS6)*DiscontinuityB(mi2,mF,mS))/KallenLambda(mF2,mi2,mS2) + (mF4 + \
mF2*mi2 - 2*mi4 - 2*(mF2 + mi2)*mS2 + mS4)*std::log(r)))/(6.*Power5(mi));
      } else {
        return (mF*SFin.left()*SFout.left()*(2*mi2*mj2*(3*mi2 + \
mj2)*DiscontinuityB(mi2,mF,mS) - 2*mi2*mj2*(mi2 + \
3*mj2)*DiscontinuityB(mj2,mF,mS) + (mi - mj)*(mi + mj)*(8*mi2*mj2 + \
2*mi2*mj2*(2*mF2 + mi2 + mj2 - 2*mS2)*ScalarC0(mi2,mj2,mF,mF,mS) + \
(2*mi2*mj2 + mF2*(mi2 + mj2) - (mi2 + \
mj2)*mS2)*std::log(r))))/(mi2*mj2*Power2(mi2 - mj2)) + \
(SFin.right()*SFout.left()*(2*mi2*mj2*(mF2*(8*mi4 + 5*mi2*mj2 - mj4) + \
mi2*(2*mi4 + 9*mi2*mj2 + mj4) + (-8*mi4 - 5*mi2*mj2 + \
mj4)*mS2)*DiscontinuityB(mi2,mF,mS) - 2*mi4*mj2*(3*mj2*(3*mi2 + mj2) \
+ mF2*(mi2 + 11*mj2) - (mi2 + 11*mj2)*mS2)*DiscontinuityB(mj2,mF,mS) \
+ (mi - mj)*(mi + mj)*(2*mi2*mj2*(5*mi4 + 7*mi2*mj2 + mF2*(11*mi2 + \
mj2) - (11*mi2 + mj2)*mS2) + 4*mi4*mj2*(2*mF4 + 2*(mi - mS)*(mj - \
mS)*(mi + mS)*(mj + mS) + mF2*(3*mi2 + 5*mj2 - \
4*mS2))*ScalarC0(mi2,mj2,mF,mF,mS) + (2*mi4*mj2*(mi2 + mj2) + \
mF4*(mi4 + 4*mi2*mj2 - mj4) - 8*mi4*mj2*mS2 + 2*mF2*(mi2*mj2*(7*mi2 + \
mj2) + (-mi4 - 4*mi2*mj2 + mj4)*mS2) + (mi4 + 4*mi2*mj2 - \
mj4)*mS4)*std::log(r))))/(2.*mi3*mj2*Power3(mi - mj)*Power3(mi + mj)) - \
(SFin.left()*SFout.right()*(2*mi2*mj4*(mF2*(11*mi2 + mj2) + 3*mi2*(mi2 \
+ 3*mj2) - (11*mi2 + mj2)*mS2)*DiscontinuityB(mi2,mF,mS) - \
2*mi2*mj2*(mj2*(mi4 + 9*mi2*mj2 + 2*mj4) + mF2*(-mi4 + 5*mi2*mj2 + \
8*mj4) + (mi4 - 5*mi2*mj2 - 8*mj4)*mS2)*DiscontinuityB(mj2,mF,mS) + \
(mi - mj)*(mi + mj)*(2*mi2*mj2*(7*mi2*mj2 + mF2*(mi2 + 11*mj2) + \
5*mj4 - (mi2 + 11*mj2)*mS2) + 4*mi2*mj4*(2*mF4 + 2*(mi - mS)*(mj - \
mS)*(mi + mS)*(mj + mS) + mF2*(5*mi2 + 3*mj2 - \
4*mS2))*ScalarC0(mi2,mj2,mF,mF,mS) + (2*mi2*(mi2 + mj2)*mj4 + \
mF4*(-mi4 + 4*mi2*mj2 + mj4) - 8*mi2*mj4*mS2 + 2*mF2*(mi2*mj2*(mi2 + \
7*mj2) + (mi4 - 4*mi2*mj2 - mj4)*mS2) + (-mi4 + 4*mi2*mj2 + \
mj4)*mS4)*std::log(r))))/(2.*mi2*mj3*Power3(mi - mj)*Power3(mi + mj));
      }
    }
  }  
}

std::complex<double> FFV_FFS_A1R(double mi, double mj, double mF, double mS, auto SFin, auto SFout)
{
  const double mi2=Power2(mi);
  const double mi3=Power3(mi);
  const double mi4=Power4(mi);
  const double mi6=Power6(mi);
  const double mj2=Power2(mj);
  const double mj3=Power3(mj);
  const double mj4=Power4(mj);
  const double mj6=Power6(mj);
  const double mF2=Power2(mF);
  const double mF4=Power4(mF);
  const double mF6=Power6(mF);
  const double mS2=Power2(mS);
  const double mS4=Power4(mS);
  const double mS6=Power6(mS);
  const double pi2=Power2(M_PI);
  if (is_zero(mS)) {
    if (is_zero(mi-mj)) {
      if (is_zero(mi-mF)) {
        return (-5*SFin.right()*SFout.left())/(6.*mi) + \
(5*SFin.left()*SFout.right())/(6.*mi);
      } else {
        return (SFin.left()*SFout.right()*(2*mF2*mi2 + 3*mi4 - 2*(mF4 + \
mF2*mi2 - 2*mi4)*std::log(mF2/(mF2 - mi2))))/(6.*Power5(mi)) + \
(SFin.right()*SFout.left()*(-2*mF2*mi2 - 3*mi4 + 2*(mF4 + mF2*mi2 - \
2*mi4)*std::log(mF2/(mF2 - mi2))))/(6.*Power5(mi));
      }
    } else {
      if (is_zero(mi-mF)) {
        return (mi*SFin.right()*SFout.right()*(-3*mi2*mj2*(-8 + pi2) - \
mj4*(24 + pi2) - 6*(3*mi2*mj2 + mj4)*dilog(mj2/(-mi2 + mj2)) - \
3*mj2*(3*mi2 + mj2)*Power2(std::log(mi2/(mi2 - mj2))) + 6*(mi4 + \
2*mi2*mj2 - 3*mj4)*std::log(mi2/(mi2 - mj2))))/(3.*Power2(-(mi2*mj) + \
mj3)) + (mi*SFin.left()*SFout.right()*(24*mj6 + mi4*mj2*(-48 + 5*pi2) + \
mi2*mj4*(24 + 7*pi2) + 6*(5*mi4*mj2 + 7*mi2*mj4)*dilog(mj2/(-mi2 + \
mj2)) + 3*mi2*mj2*(5*mi2 + 7*mj2)*Power2(std::log(mi2/(mi2 - mj2))) + \
3*(-mi + mj)*(mi + mj)*(mi4 + 20*mi2*mj2 + 3*mj4)*std::log(mi2/(mi2 - \
mj2))))/(3.*mj2*Power3(-mi2 + mj2)) + \
(SFin.right()*SFout.left()*(-3*mi6*mj2 + mi2*mj6*(39 + 5*pi2) + \
mi4*mj4*(-51 + 7*pi2) + 6*(7*mi4*mj4 + 5*mi2*mj6)*dilog(mj2/(-mi2 + \
mj2)) + 15*Power8(mj) + 3*std::log(mi2/(mi2 - mj2))*(-7*mi6*mj2 - \
11*mi4*mj4 + 15*mi2*mj6 + Power8(mi) + 2*Power8(mj) + (7*mi4*mj4 + \
5*mi2*mj6)*std::log(mi2/(mi2 - mj2)))))/(3.*mj3*Power3(mi2 - mj2));
      } else if (is_zero(mj-mF)) {
        return (mj*SFin.right()*SFout.right()*(3*mi2*mj2*(-8 + pi2) + \
mi4*(24 + pi2) + 6*(mi4 + 3*mi2*mj2)*dilog(mi2/(mi2 - mj2)) + \
3*mi2*(mi2 + 3*mj2)*Power2(std::log(mj2/(-mi2 + mj2))) + 6*(mi - \
mj)*(mi + mj)*(3*mi2 + mj2)*std::log(mj2/(-mi2 + mj2))))/(3.*Power2(mi3 \
- mi*mj2)) + (SFin.left()*SFout.right()*(-3*mi2*mj6 + mi6*mj2*(39 + \
5*pi2) + mi4*mj4*(-51 + 7*pi2) + 6*(5*mi6*mj2 + \
7*mi4*mj4)*dilog(mi2/(mi2 - mj2)) + 15*Power8(mi) + \
3*std::log(mj2/(-mi2 + mj2))*(15*mi6*mj2 - 11*mi4*mj4 - 7*mi2*mj6 + \
2*Power8(mi) + Power8(mj) + mi4*mj2*(5*mi2 + 7*mj2)*std::log(mj2/(-mi2 \
+ mj2)))))/(3.*Power3(mi3 - mi*mj2)) - \
(mj*SFin.right()*SFout.left()*(24*mi6 + mi2*mj4*(-48 + 5*pi2) + \
mi4*mj2*(24 + 7*pi2) + 6*(7*mi4*mj2 + 5*mi2*mj4)*dilog(mi2/(mi2 - \
mj2)) + 3*std::log(mj2/(-mi2 + mj2))*((mi - mj)*(mi + mj)*(3*mi4 + \
20*mi2*mj2 + mj4) + (7*mi4*mj2 + 5*mi2*mj4)*std::log(mj2/(-mi2 + \
mj2)))))/(3.*mi2*Power3(mi - mj)*Power3(mi + mj));
      } else {
        return (2*mF*SFin.right()*SFout.right()*(mi2*(mi - mj)*(mi + \
mj)*mj2*(2*mF2 + mi2 + mj2)*ScalarC0(mi2,mj2,mF,mF,mS2) + \
mj2*(4*mi2*(mi - mj)*(mi + mj) + (-mF + mi)*(mF + mi)*(3*mi2 + \
mj2)*std::log(mF2/(mF2 - mi2))) + mi2*(mF - mj)*(mF + mj)*(mi2 + \
3*mj2)*std::log(mF2/(mF2 - mj2))))/(mi2*mj2*Power2(mi - mj)*Power2(mi + \
mj)) + (SFin.left()*SFout.right()*(-2*mi4*(mi - mj)*(mi + \
mj)*mj2*(2*mF4 + 2*mi2*mj2 + mF2*(3*mi2 + \
5*mj2))*ScalarC0(mi2,mj2,mF,mF,mS2) + mj2*(mi2*(-mi + mj)*(mi + \
mj)*(5*mi4 + 7*mi2*mj2 + mF2*(11*mi2 + mj2)) + (mF - mi)*(mF + \
mi)*(mF2*(8*mi4 + 5*mi2*mj2 - mj4) + mi2*(2*mi4 + 9*mi2*mj2 + \
mj4))*std::log(mF2/(mF2 - mi2))) + mi4*(-mF + mj)*(mF + \
mj)*(3*mj2*(3*mi2 + mj2) + mF2*(mi2 + 11*mj2))*std::log(mF2/(mF2 - \
mj2))))/(mj2*Power3(-mi3 + mi*mj2)) + \
(SFin.right()*SFout.left()*(-2*mi2*(mi - mj)*(mi + mj)*(2*mF4 + \
2*mi2*mj2 + mF2*(5*mi2 + 3*mj2))*mj4*ScalarC0(mi2,mj2,mF,mF,mS2) + \
(mF - mi)*(mF + mi)*(mF2*(11*mi2 + mj2) + 3*mi2*(mi2 + \
3*mj2))*mj4*std::log(mF2/(mF2 - mi2)) + mi2*(mj2*(-mi2 + \
mj2)*(7*mi2*mj2 + mF2*(mi2 + 11*mj2) + 5*mj4) + (-mF + mj)*(mF + \
mj)*(mj2*(mi4 + 9*mi2*mj2 + 2*mj4) + mF2*(-mi4 + 5*mi2*mj2 + \
8*mj4))*std::log(mF2/(mF2 - mj2)))))/(mi2*mj3*Power3(mi - mj)*Power3(mi \
+ mj));
      }
    }
  } else {
    const auto r = Power2(mF/mS);
    if (std::max(mF,mS) > approx_limit * std::max(mi,mj)) {
      // eq. 18 of hep-ph/9510309 after replacement L <-> R (possibly with different sign)
      return - 1./18. * SFout.left() * SFin.right() * OneLoopFunctionD(r) / mS2;  
    } else {
      if (is_zero(mi-mj)) {
        return (SFin.left()*SFout.right()*(mi2*(2*mF2 + 3*mi2 - 2*mS2) \
+ (2*mi2*(mF6 - 3*mF2*mi4 + 2*mi6 - 3*mF2*(mF2 + mi2)*mS2 + 3*(mF2 + \
mi2)*mS4 - mS6)*DiscontinuityB(mi2,mF,mS))/KallenLambda(mF2,mi2,mS2) \
- (mF4 + mF2*mi2 - 2*mi4 - 2*(mF2 + mi2)*mS2 + \
mS4)*std::log(r)))/(6.*Power5(mi)) + \
(SFin.right()*SFout.left()*(mi2*(-2*mF2 - 3*mi2 + 2*mS2) + (2*mi2*(-mF6 \
+ 3*mF2*mi4 - 2*mi6 + 3*mF2*(mF2 + mi2)*mS2 - 3*(mF2 + mi2)*mS4 + \
mS6)*DiscontinuityB(mi2,mF,mS))/KallenLambda(mF2,mi2,mS2) + (mF4 + \
mF2*mi2 - 2*mi4 - 2*(mF2 + mi2)*mS2 + mS4)*std::log(r)))/(6.*Power5(mi));
      } else {
        return (mF*SFin.right()*SFout.right()*(2*mi2*mj2*(3*mi2 + \
mj2)*DiscontinuityB(mi2,mF,mS) - 2*mi2*mj2*(mi2 + \
3*mj2)*DiscontinuityB(mj2,mF,mS) + (mi - mj)*(mi + mj)*(8*mi2*mj2 + \
2*mi2*mj2*(2*mF2 + mi2 + mj2 - 2*mS2)*ScalarC0(mi2,mj2,mF,mF,mS) + \
(2*mi2*mj2 + mF2*(mi2 + mj2) - (mi2 + \
mj2)*mS2)*std::log(r))))/(mi2*mj2*Power2(mi2 - mj2)) + \
(SFin.left()*SFout.right()*(2*mi2*mj2*(mF2*(8*mi4 + 5*mi2*mj2 - mj4) + \
mi2*(2*mi4 + 9*mi2*mj2 + mj4) + (-8*mi4 - 5*mi2*mj2 + \
mj4)*mS2)*DiscontinuityB(mi2,mF,mS) - 2*mi4*mj2*(3*mj2*(3*mi2 + mj2) \
+ mF2*(mi2 + 11*mj2) - (mi2 + 11*mj2)*mS2)*DiscontinuityB(mj2,mF,mS) \
+ (mi - mj)*(mi + mj)*(2*mi2*mj2*(5*mi4 + 7*mi2*mj2 + mF2*(11*mi2 + \
mj2) - (11*mi2 + mj2)*mS2) + 4*mi4*mj2*(2*mF4 + 2*(mi - mS)*(mj - \
mS)*(mi + mS)*(mj + mS) + mF2*(3*mi2 + 5*mj2 - \
4*mS2))*ScalarC0(mi2,mj2,mF,mF,mS) + (2*mi4*mj2*(mi2 + mj2) + \
mF4*(mi4 + 4*mi2*mj2 - mj4) - 8*mi4*mj2*mS2 + 2*mF2*(mi2*mj2*(7*mi2 + \
mj2) + (-mi4 - 4*mi2*mj2 + mj4)*mS2) + (mi4 + 4*mi2*mj2 - \
mj4)*mS4)*std::log(r))))/(2.*mi3*mj2*Power3(mi - mj)*Power3(mi + mj)) - \
(SFin.right()*SFout.left()*(2*mi2*mj4*(mF2*(11*mi2 + mj2) + 3*mi2*(mi2 \
+ 3*mj2) - (11*mi2 + mj2)*mS2)*DiscontinuityB(mi2,mF,mS) - \
2*mi2*mj2*(mj2*(mi4 + 9*mi2*mj2 + 2*mj4) + mF2*(-mi4 + 5*mi2*mj2 + \
8*mj4) + (mi4 - 5*mi2*mj2 - 8*mj4)*mS2)*DiscontinuityB(mj2,mF,mS) + \
(mi - mj)*(mi + mj)*(2*mi2*mj2*(7*mi2*mj2 + mF2*(mi2 + 11*mj2) + \
5*mj4 - (mi2 + 11*mj2)*mS2) + 4*mi2*mj4*(2*mF4 + 2*(mi - mS)*(mj - \
mS)*(mi + mS)*(mj + mS) + mF2*(5*mi2 + 3*mj2 - \
4*mS2))*ScalarC0(mi2,mj2,mF,mF,mS) + (2*mi2*(mi2 + mj2)*mj4 + \
mF4*(-mi4 + 4*mi2*mj2 + mj4) - 8*mi2*mj4*mS2 + 2*mF2*(mi2*mj2*(mi2 + \
7*mj2) + (mi4 - 4*mi2*mj2 - mj4)*mS2) + (-mi4 + 4*mi2*mj2 + \
mj4)*mS4)*std::log(r))))/(2.*mi2*mj3*Power3(mi - mj)*Power3(mi + mj));
      }
    }
  } 
}

std::complex<double> FFV_FFS_A2L(double mi, double mj, double mF, double mS, auto SFin, auto SFout)
{
  const double mi2=Power2(mi);
  const double mi3=Power3(mi);
  const double mi4=Power4(mi);
  const double mi6=Power6(mi);
  const double mj2=Power2(mj);
  const double mj3=Power3(mj);
  const double mj4=Power4(mj);
  const double mj6=Power6(mj);
  const double mF2=Power2(mF);
  const double mF4=Power4(mF);
  const double mF6=Power6(mF);
  const double mS2=Power2(mS);
  const double mS4=Power4(mS);
  const double mS6=Power6(mS);
  const double pi2=Power2(M_PI);
  if (is_zero(mS)) {
    if (is_zero(mi-mj)) {
      if (is_zero(mi-mF)) {
        return (-2*SFin.left()*SFout.left())/mi2 - \
(SFin.right()*SFout.left())/(2.*mi2) - \
(SFin.left()*SFout.right())/(2.*mi2);
      } else {
        return (2*mF*SFin.left()*SFout.left()*(-mi2 + (mF - mi)*(mF + \
mi)*std::log(mF2/(mF2 - mi2))))/Power5(mi) + \
(SFin.right()*SFout.left()*(-2*mF2*mi2 + mi4 + 2*mF2*(mF - mi)*(mF + \
mi)*std::log(mF2/(mF2 - mi2))))/(2.*mi6) + \
(SFin.left()*SFout.right()*(-2*mF2*mi2 + mi4 + 2*mF2*(mF - mi)*(mF + \
mi)*std::log(mF2/(mF2 - mi2))))/(2.*mi6);
      }
    } else {
      if (is_zero(mi-mF)) {
        return (SFin.left()*SFout.left()*(mj2*pi2 + \
6*mj2*dilog(mj2/(-mi2 + mj2)) + 3*mj2*Power2(std::log(mi2/(mi2 - mj2))) \
+ 6*(-mi + mj)*(mi + mj)*std::log(mi2/(mi2 - mj2))))/(3.*mj2*(-mi2 + \
mj2)) - (SFin.right()*SFout.left()*(6*mj4 + mi2*mj2*(-6 + pi2) + \
6*mi2*mj2*dilog(mj2/(-mi2 + mj2)) + 3*std::log(mi2/(mi2 - mj2))*(-mi4 + \
mj4 + mi2*mj2*std::log(mi2/(mi2 - mj2)))))/(3.*Power2(-(mi2*mj) + mj3)) \
+ (SFin.left()*SFout.right()*(-3*mi4*mj2 + 3*mj6 + mi2*mj4*pi2 + \
6*mi2*mj4*dilog(mj2/(-mi2 + mj2)) + 3*mi2*std::log(mi2/(mi2 - \
mj2))*(mi4 - 4*mi2*mj2 + 3*mj4 + mj4*std::log(mi2/(mi2 - \
mj2)))))/(3.*mi*mj3*Power2(mi2 - mj2));
      } else if (is_zero(mj-mF)) {
        return (mj*SFin.left()*SFout.left()*(mi2*pi2 + \
6*mi2*dilog(mi2/(mi2 - mj2)) + 3*mi2*Power2(std::log(mj2/(-mi2 + mj2))) \
+ 6*(mi2 - mj2)*std::log(mj2/(-mi2 + mj2))))/(3.*mi3*(mi2 - mj2)) + \
(SFin.right()*SFout.left()*(3*mi6 - 3*mi2*mj4 + mi4*mj2*pi2 + \
6*mi4*mj2*dilog(mi2/(mi2 - mj2)) + 3*mj2*std::log(mj2/(-mi2 + \
mj2))*(3*mi4 - 4*mi2*mj2 + mj4 + mi4*std::log(mj2/(-mi2 + \
mj2)))))/(3.*mi4*Power2(mi2 - mj2)) - \
(mj*SFin.left()*SFout.right()*(6*mi4 + mi2*mj2*(-6 + pi2) + \
6*mi2*mj2*dilog(mi2/(mi2 - mj2)) + 3*std::log(mj2/(-mi2 + mj2))*(mi4 - \
mj4 + mi2*mj2*std::log(mj2/(-mi2 + mj2)))))/(3.*mi3*Power2(mi2 - mj2));
      } else {
        return (2*mF*SFin.left()*SFout.left()*(mi2*(mi - mj)*(mi + \
mj)*mj2*ScalarC0(mi2,mj2,mF,mF,mS2) + (-mF2 + \
mi2)*mj2*std::log(mF2/(mF2 - mi2)) + mi2*(mF - mj)*(mF + \
mj)*std::log(mF2/(mF2 - mj2))))/(mi3*(mi - mj)*(mi + mj)*mj2) + \
(SFin.right()*SFout.left()*(2*mF2*mi4*(mi - mj)*(mi + \
mj)*mj2*ScalarC0(mi2,mj2,mF,mF,mS2) + mj2*(mi2*(mF2 + mi2)*(mi - \
mj)*(mi + mj) + (-mF + mi)*(mF + mi)*(2*mF2*mi2 + (-mF2 + \
mi2)*mj2)*std::log(mF2/(mF2 - mi2))) + mi4*(mF4 - mj4)*std::log(mF2/(mF2 \
- mj2))))/(mi4*mj2*Power2(mi2 - mj2)) + \
(SFin.left()*SFout.right()*(2*mF2*mi2*(-mi2 + \
mj2)*mj4*ScalarC0(mi2,mj2,mF,mF,mS2) + (mF4 - \
mi4)*mj4*std::log(mF2/(mF2 - mi2)) + mi2*(mj2*(mF2 + mj2)*(-mi2 + mj2) \
+ (-mF + mj)*(mF + mj)*(-(mF2*mi2) + (2*mF2 + \
mi2)*mj2)*std::log(mF2/(mF2 - mj2)))))/(mi3*mj3*Power2(mi2 - mj2));
      }
    }
  } else {
    const auto r = Power2(mF/mS);
    if (std::max(mF,mS) > approx_limit * std::max(mi,mj)) {
      // eq. 19 of hep-ph/9510309 (possibly with different sign)
      return - SFout.left() * SFin.right() * OneLoopFunctionE(r)/12.0 / mS2
             - SFout.left() * SFin.left() * mF/mj * OneLoopFunctionF(r) * 2./3. / mS2
             - mi/mj * SFout.right() * SFin.left() * OneLoopFunctionE(r)/12.0 / mS2;  
    } else {
      if (is_zero(mi-mj)) {
        return (mF*SFin.left()*SFout.left()*(-2*mi2 - (2*mi2*(mF4 + mi4 \
- 2*mF2*(mi2 + mS2) + \
mS4)*DiscontinuityB(mi2,mF,mS))/KallenLambda(mF2,mi2,mS2) - (-mF2 + \
mi2 + mS2)*std::log(r)))/Power5(mi) + \
(SFin.right()*SFout.left()*(mi2*(-2*mF2 + mi2 + 2*mS2) - \
(2*mi2*DiscontinuityB(mi2,mF,mS)*(mF2*(-3*mF2 + mi2)*mS2 + (3*mF2 + \
mi2)*mS4 - mS6 + Power2(Power3(mF) - \
mF*mi2)))/KallenLambda(mF2,mi2,mS2) + (mF4 - mF2*(mi2 + 2*mS2) + \
mS4)*std::log(r)))/(2.*mi6) + (SFin.left()*SFout.right()*(mi2*(-2*mF2 + \
mi2 + 2*mS2) - (2*mi2*DiscontinuityB(mi2,mF,mS)*(mF2*(-3*mF2 + \
mi2)*mS2 + (3*mF2 + mi2)*mS4 - mS6 + Power2(Power3(mF) - \
mF*mi2)))/KallenLambda(mF2,mi2,mS2) + (mF4 - mF2*(mi2 + 2*mS2) + \
mS4)*std::log(r)))/(2.*mi6);
      } else {
        return \
(mF*SFin.left()*SFout.left()*(2*mi2*mj2*DiscontinuityB(mi2,mF,mS) - \
2*mi2*mj2*DiscontinuityB(mj2,mF,mS) + (mi - mj)*(mi + \
mj)*(2*mi2*mj2*ScalarC0(mi2,mj2,mF,mF,mS) + (mF - mS)*(mF + \
mS)*std::log(r))))/(mi3*(mi - mj)*(mi + mj)*mj2) + \
(SFin.right()*SFout.left()*(2*mi2*mj2*(mF2*(2*mi2 - mj2) + mi2*(mj2 - \
2*mS2) + mj2*mS2)*DiscontinuityB(mi2,mF,mS) - 2*mi4*mj2*(mF2 + mj2 - \
mS2)*DiscontinuityB(mj2,mF,mS) + (mi - mj)*(mi + mj)*(2*mi2*mj2*(mF2 \
+ mi2 - mS2) + 4*mF2*mi4*mj2*ScalarC0(mi2,mj2,mF,mF,mS) + (mF4*(mi - \
mj)*(mi + mj) + 2*mF2*(mi2*(mj - mS)*(mj + mS) + mj2*mS2) + (mi - \
mj)*(mi + mj)*mS4)*std::log(r))))/(2.*mi4*mj2*Power2(mi - mj)*Power2(mi \
+ mj)) - (SFin.left()*SFout.right()*(2*mi2*mj4*(mF2 + mi2 - \
mS2)*DiscontinuityB(mi2,mF,mS) - 2*mi2*mj2*(-(mF2*(mi2 - 2*mj2)) - \
2*mj2*mS2 + mi2*(mj2 + mS2))*DiscontinuityB(mj2,mF,mS) + (mi2 - \
mj2)*(2*mi2*mj2*(mF2 + mj2 - mS2) + \
4*mF2*mi2*mj4*ScalarC0(mi2,mj2,mF,mF,mS) + (mF4*(-mi2 + mj2) + \
2*mF2*(-(mj2*mS2) + mi2*(mj2 + mS2)) + (-mi2 + \
mj2)*mS4)*std::log(r))))/(2.*mi3*mj3*Power2(mi2 - mj2));
      }
    }
  }
}

std::complex<double> FFV_FFS_A2R(double mi, double mj, double mF, double mS, auto SFin, auto SFout)
{
  const double mi2=Power2(mi);
  const double mi3=Power3(mi);
  const double mi4=Power4(mi);
  const double mi6=Power6(mi);
  const double mj2=Power2(mj);
  const double mj3=Power3(mj);
  const double mj4=Power4(mj);
  const double mj6=Power6(mj);
  const double mF2=Power2(mF);
  const double mF4=Power4(mF);
  const double mF6=Power6(mF);
  const double mS2=Power2(mS);
  const double mS4=Power4(mS);
  const double mS6=Power6(mS);
  const double pi2=Power2(M_PI);
  if (is_zero(mS)) {
    if (is_zero(mi-mj)) {
      if (is_zero(mi-mF)) {
        return -(SFin.right()*SFout.left())/(2.*mi2) - \
(SFin.left()*SFout.right())/(2.*mi2) - (2*SFin.right()*SFout.right())/mi2;
      } else {
        return (2*mF*SFin.right()*SFout.right()*(-mi2 + (mF - mi)*(mF + \
mi)*std::log(mF2/(mF2 - mi2))))/Power5(mi) + \
(SFin.right()*SFout.left()*(-2*mF2*mi2 + mi4 + 2*mF2*(mF - mi)*(mF + \
mi)*std::log(mF2/(mF2 - mi2))))/(2.*mi6) + \
(SFin.left()*SFout.right()*(-2*mF2*mi2 + mi4 + 2*mF2*(mF - mi)*(mF + \
mi)*std::log(mF2/(mF2 - mi2))))/(2.*mi6);
      }
    } else {
      if (is_zero(mi-mF)) {
        return (SFin.right()*SFout.right()*(mj2*pi2 + \
6*mj2*dilog(mj2/(-mi2 + mj2)) + 3*mj2*Power2(std::log(mi2/(mi2 - mj2))) \
+ 6*(-mi + mj)*(mi + mj)*std::log(mi2/(mi2 - mj2))))/(3.*mj2*(-mi2 + \
mj2)) - (SFin.left()*SFout.right()*(6*mj4 + mi2*mj2*(-6 + pi2) + \
6*mi2*mj2*dilog(mj2/(-mi2 + mj2)) + 3*std::log(mi2/(mi2 - mj2))*(-mi4 + \
mj4 + mi2*mj2*std::log(mi2/(mi2 - mj2)))))/(3.*Power2(-(mi2*mj) + mj3)) \
+ (SFin.right()*SFout.left()*(-3*mi4*mj2 + 3*mj6 + mi2*mj4*pi2 + \
6*mi2*mj4*dilog(mj2/(-mi2 + mj2)) + 3*mi2*std::log(mi2/(mi2 - \
mj2))*(mi4 - 4*mi2*mj2 + 3*mj4 + mj4*std::log(mi2/(mi2 - \
mj2)))))/(3.*mi*mj3*Power2(mi2 - mj2));
      } else if (is_zero(mj-mF)) {
        return (mj*SFin.right()*SFout.right()*(mi2*pi2 + \
6*mi2*dilog(mi2/(mi2 - mj2)) + 3*mi2*Power2(std::log(mj2/(-mi2 + mj2))) \
+ 6*(mi2 - mj2)*std::log(mj2/(-mi2 + mj2))))/(3.*mi3*(mi2 - mj2)) + \
(SFin.left()*SFout.right()*(3*mi6 - 3*mi2*mj4 + mi4*mj2*pi2 + \
6*mi4*mj2*dilog(mi2/(mi2 - mj2)) + 3*mj2*std::log(mj2/(-mi2 + \
mj2))*(3*mi4 - 4*mi2*mj2 + mj4 + mi4*std::log(mj2/(-mi2 + \
mj2)))))/(3.*mi4*Power2(mi2 - mj2)) - \
(mj*SFin.right()*SFout.left()*(6*mi4 + mi2*mj2*(-6 + pi2) + \
6*mi2*mj2*dilog(mi2/(mi2 - mj2)) + 3*std::log(mj2/(-mi2 + mj2))*(mi4 - \
mj4 + mi2*mj2*std::log(mj2/(-mi2 + mj2)))))/(3.*mi3*Power2(mi2 - mj2));
      } else {
        return (2*mF*SFin.right()*SFout.right()*(mi2*(mi - mj)*(mi + \
mj)*mj2*ScalarC0(mi2,mj2,mF,mF,mS2) + (-mF2 + \
mi2)*mj2*std::log(mF2/(mF2 - mi2)) + mi2*(mF - mj)*(mF + \
mj)*std::log(mF2/(mF2 - mj2))))/(mi3*(mi - mj)*(mi + mj)*mj2) + \
(SFin.left()*SFout.right()*(2*mF2*mi4*(mi - mj)*(mi + \
mj)*mj2*ScalarC0(mi2,mj2,mF,mF,mS2) + mj2*(mi2*(mF2 + mi2)*(mi - \
mj)*(mi + mj) + (-mF + mi)*(mF + mi)*(2*mF2*mi2 + (-mF2 + \
mi2)*mj2)*std::log(mF2/(mF2 - mi2))) + mi4*(mF4 - mj4)*std::log(mF2/(mF2 \
- mj2))))/(mi4*mj2*Power2(mi2 - mj2)) + \
(SFin.right()*SFout.left()*(2*mF2*mi2*(-mi2 + \
mj2)*mj4*ScalarC0(mi2,mj2,mF,mF,mS2) + (mF4 - \
mi4)*mj4*std::log(mF2/(mF2 - mi2)) + mi2*(mj2*(mF2 + mj2)*(-mi2 + mj2) \
+ (-mF + mj)*(mF + mj)*(-(mF2*mi2) + (2*mF2 + \
mi2)*mj2)*std::log(mF2/(mF2 - mj2)))))/(mi3*mj3*Power2(mi2 - mj2));
      }
    }
  } else {
    const auto r = Power2(mF/mS);
    if (std::max(mF,mS) > approx_limit * std::max(mi,mj)) {
      // eq. 19 of hep-ph/9510309 after replacement L <-> R (possibly with different sign)
      return - SFout.right() * SFin.left() * OneLoopFunctionE(r)/12.0 / mS2 
             - SFout.right() * SFin.right() * mF/mj * OneLoopFunctionF(r) * 2./3. / mS2
             - mi/mj * SFout.left() * SFin.right() * OneLoopFunctionE(r)/12.0 / mS2; 
    } else {
      if (is_zero(mi-mj)) {
        return (mF*SFin.right()*SFout.right()*(-2*mi2 - (2*mi2*(mF4 + \
mi4 - 2*mF2*(mi2 + mS2) + \
mS4)*DiscontinuityB(mi2,mF,mS))/KallenLambda(mF2,mi2,mS2) - (-mF2 + \
mi2 + mS2)*std::log(r)))/Power5(mi) + \
(SFin.right()*SFout.left()*(mi2*(-2*mF2 + mi2 + 2*mS2) - \
(2*mi2*DiscontinuityB(mi2,mF,mS)*(mF2*(-3*mF2 + mi2)*mS2 + (3*mF2 + \
mi2)*mS4 - mS6 + Power2(Power3(mF) - \
mF*mi2)))/KallenLambda(mF2,mi2,mS2) + (mF4 - mF2*(mi2 + 2*mS2) + \
mS4)*std::log(r)))/(2.*mi6) + (SFin.left()*SFout.right()*(mi2*(-2*mF2 + \
mi2 + 2*mS2) - (2*mi2*DiscontinuityB(mi2,mF,mS)*(mF2*(-3*mF2 + \
mi2)*mS2 + (3*mF2 + mi2)*mS4 - mS6 + Power2(Power3(mF) - \
mF*mi2)))/KallenLambda(mF2,mi2,mS2) + (mF4 - mF2*(mi2 + 2*mS2) + \
mS4)*std::log(r)))/(2.*mi6);
      } else {
        return \
(mF*SFin.right()*SFout.right()*(2*mi2*mj2*DiscontinuityB(mi2,mF,mS) - \
2*mi2*mj2*DiscontinuityB(mj2,mF,mS) + (mi - mj)*(mi + \
mj)*(2*mi2*mj2*ScalarC0(mi2,mj2,mF,mF,mS) + (mF - mS)*(mF + \
mS)*std::log(r))))/(mi3*(mi - mj)*(mi + mj)*mj2) + \
(SFin.left()*SFout.right()*(2*mi2*mj2*(mF2*(2*mi2 - mj2) + mi2*(mj2 - \
2*mS2) + mj2*mS2)*DiscontinuityB(mi2,mF,mS) - 2*mi4*mj2*(mF2 + mj2 - \
mS2)*DiscontinuityB(mj2,mF,mS) + (mi - mj)*(mi + mj)*(2*mi2*mj2*(mF2 \
+ mi2 - mS2) + 4*mF2*mi4*mj2*ScalarC0(mi2,mj2,mF,mF,mS) + (mF4*(mi - \
mj)*(mi + mj) + 2*mF2*(mi2*(mj - mS)*(mj + mS) + mj2*mS2) + (mi - \
mj)*(mi + mj)*mS4)*std::log(r))))/(2.*mi4*mj2*Power2(mi - mj)*Power2(mi \
+ mj)) - (SFin.right()*SFout.left()*(2*mi2*mj4*(mF2 + mi2 - \
mS2)*DiscontinuityB(mi2,mF,mS) - 2*mi2*mj2*(-(mF2*(mi2 - 2*mj2)) - \
2*mj2*mS2 + mi2*(mj2 + mS2))*DiscontinuityB(mj2,mF,mS) + (mi2 - \
mj2)*(2*mi2*mj2*(mF2 + mj2 - mS2) + \
4*mF2*mi2*mj4*ScalarC0(mi2,mj2,mF,mF,mS) + (mF4*(-mi2 + mj2) + \
2*mF2*(-(mj2*mS2) + mi2*(mj2 + mS2)) + (-mi2 + \
mj2)*mS4)*std::log(r))))/(2.*mi3*mj3*Power2(mi2 - mj2));
      }
    }
  }        
}


std::complex<double> FFV_VVF_A1L(double mi, double mj, double mF, double mV, auto VFin, auto VFout)
{
  const double mi2=Power2(mi);
  const double mi3=Power3(mi);
  const double mi4=Power4(mi);
  const double mi6=Power6(mi);
  const double mj2=Power2(mj);
  const double mj3=Power3(mj);
  const double mj4=Power4(mj);
  const double mj6=Power6(mj);
  const double mF2=Power2(mF);
  const double mF4=Power4(mF);
  const double mF6=Power6(mF);
  const double mV2=Power2(mV);
  const double mV4=Power4(mV);
  const double mV6=Power6(mV);
  const double pi2=Power2(M_PI);
  if (is_zero(mF)) {
    const auto r = Power2(mF/mV);
    if (mV > approx_limit * std::max(mi,mj)) {
        return - 8. * mF/mj * VFin.right() * VFout.left() * OneLoopFunctionI(r) / mV2
               + mi/mj * VFin.left() * VFout.left() * OneLoopFunctionH(r) / 18. / mV2;
    } else {
      if (is_zero(mi-mj)) {
        if (is_zero(mi-mV)) {
          return (-14*VFin.left()*VFout.left())/(3.*mi) + (2*VFin.right()*VFout.right())/(3.*mi);
        } else {
          return ((-2*mi2*(6*mi2 + mV2) + (-13*mi4 + 11*mi2*mV2 + 2*mV4)*std::log(mV2/(-mi2 + mV2)))*VFin.left()*VFout.left())/(3.*Power5(mi)) + ((2*mi2*mV2 + (mi4 + mi2*mV2 - 2*mV4)*std::log(mV2/(-mi2 + mV2)))*VFin.right()*VFout.right())/(3.*Power5(mi));
        }
      } else {
        if (is_zero(mi-mV)) {
          return -((-6*mi6*mj2 + 2*mi2*mj6*(27 + 7*pi2) + mi4*mj4*(-90 + 11*pi2) + dilog(mj2/(-mi2 + mj2))*(66*mi4*mj4 + 84*mi2*mj6 - 6*Power8(mj)) - (-42 + pi2)*Power8(mj) + 3*std::log(mi2/(mi2 - mj2))*(2*(-5*mi6*mj2 - 15*mi4*mj4 + 17*mi2*mj6 + Power8(mi) + 2*Power8(mj)) + (11*mi4*mj4 + 14*mi2*mj6 - Power8(mj))*std::log(mi2/(mi2 - mj2))))*VFin.left()*VFout.left())/(3.*Power3(-(mi2*mj) + mj3)) + (2*mi*(4*mi2*mj2*(3 - 2*pi2) - 3*mi4*(-10 + pi2) - mj4*(42 + pi2) - 6*(3*mi4 + 8*mi2*mj2 + mj4)*dilog(mj2/(-mi2 + mj2)) + 3*std::log(mi2/(mi2 - mj2))*(8*(mi - mj)*(mi + mj)*(2*mi2 + mj2) - (3*mi4 + 8*mi2*mj2 + mj4)*std::log(mi2/(mi2 - mj2))))*VFin.right()*VFout.right())/(3.*Power3(mi2 - mj2));
        } else if (is_zero(mj-mV)) {
          return (2*mj*(-(mi4*(-18 + pi2)) + 4*mi2*mj2*(9 + 2*pi2) + mj4*(-54 + 5*pi2) - 6*(mi4 - 8*mi2*mj2 - 5*mj4)*dilog(mi2/(mi2 - mj2)) - 3*(mi4 - 8*mi2*mj2 - 5*mj4)*Power2(std::log(mj2/(-mi2 + mj2))) + 72*(mi - mj)*(mi + mj)*mj2*std::log(mj2/(-mi2 + mj2)))*VFin.left()*VFout.left())/(3.*Power3(-mi2 + mj2)) - ((6*mi2*mj6 - 6*mi6*mj2*(25 + pi2) - mi4*mj4*(-138 + 19*pi2) + (6 + pi2)*Power8(mi) + 6*dilog(mi2/(mi2 - mj2))*(-6*mi6*mj2 - 19*mi4*mj4 + Power8(mi)) + 3*Power2(std::log(mj2/(-mi2 + mj2)))*(-6*mi6*mj2 - 19*mi4*mj4 + Power8(mi)) + 6*(mi - mj)*(mi + mj)*(2*mi2 + mj2)*(mi4 - 10*mi2*mj2 + mj4)*std::log(mj2/(-mi2 + mj2)))*VFin.right()*VFout.right())/(3.*Power3(mi3 - mi*mj2));
        } else {
          return (2*(mi2*(mi - mj)*(mi + mj)*mj4*(2*mi4 + mj4 - 7*mj2*mV2 - mi2*(7*mj2 + 9*mV2) - 4*mV4)*ScalarC0(mi2,mj2,mV,mV,mF2) + mj4*(mi - mV)*(mi + mV)*(-13*mi2*mj2 + mj4 - (11*mi2 + mj2)*mV2)*std::log(mV2/(-mi2 + mV2)) + mi2*(mj2*(-mi2 + mj2)*(7*mj4 + 11*mj2*mV2 + mi2*(5*mj2 + mV2)) + (mj - mV)*(mj + mV)*(-(mi4*(mj2 + mV2)) + 2*mj4*(mj2 + 4*mV2) + mi2*(11*mj4 + 5*mj2*mV2))*std::log(mV2/(-mj2 + mV2))))*VFin.left()*VFout.left())/(mi2*mj3*Power3(mi - mj)*Power3(mi + mj)) + (2*(mi4*(mi - mj)*(mi + mj)*mj2*(mi4 - 2*mj4 - 13*mj2*mV2 - 3*mi2*(mj2 + mV2) - 4*mV4)*ScalarC0(mi2,mj2,mV,mV,mF2) + mj2*(mi2*(mi - mj)*(mi + mj)*(mi4 - 13*mi2*mj2 - (11*mi2 + mj2)*mV2) + (mi - mV)*(mi + mV)*(2*mi6 + mj4*mV2 - mi4*(11*mj2 + 8*mV2) - mi2*(3*mj4 + 5*mj2*mV2))*std::log(mV2/(-mi2 + mV2))) + mi4*(mj - mV)*(mj + mV)*(-mi4 + 8*mj4 + 11*mj2*mV2 + mi2*(5*mj2 + mV2))*std::log(mV2/(-mj2 + mV2)))*VFin.right()*VFout.right())/(mj2*Power3(-mi3 + mi*mj2));
        }
      }
    }
  } else {
    const auto r = Power2(mF/mV);
    if (std::max(mV,mF) > approx_limit * std::max(mi,mj)) {
        return - 8. * mF/mj * VFin.right() * VFout.left() * OneLoopFunctionI(r) / mV2
               + mi/mj * VFin.left() * VFout.left() * OneLoopFunctionH(r) / 18. / mV2;
    } else {
      if (is_zero(mi-mj)) {
        return ((-4*mi2*(-mF2 + 6*mi2 + mV2) - (2*mi2*DiscontinuityB(mi2,mF,mV)*(-2*mF6 + 3*mF4*(5*mi2 + 2*mV2) - 6*mF2*(4*mi2*mV2 + mV4) + (13*mi2 + 2*mV2)*Power2(mi2 - mV2)))/KallenLambda(mF2,mi2,mV2) + (-2*mF4 + 13*mF2*mi2 + 13*mi4 + (4*mF2 - 11*mi2)*mV2 - 2*mV4)*std::log(r))*VFin.left()*VFout.left())/(6.*Power5(mi)) + ((-8*mF*(mF2 + mi2 - mV2)*DiscontinuityB(mi2,mF,mV))/KallenLambda(mF2,mi2,mV2) + (4*mF*std::log(r))/mi2)*VFin.left()*VFout.right() - ((4*mi2*(mF - mV)*(mF + mV) - (2*mi2*(-2*mF6 + 3*mF4*mi2 + mi6 + 6*mF4*mV2 - 3*(2*mF2 + mi2)*mV4 + 2*mV6)*DiscontinuityB(mi2,mF,mV))/KallenLambda(mF2,mi2,mV2) + (-2*mF4 + mF2*mi2 + mi4 + (4*mF2 + mi2)*mV2 - 2*mV4)*std::log(r))*VFin.right()*VFout.right())/(6.*Power5(mi));
      } else {
        return ((2*mi2*mj4*(-13*mi2*mj2 + mF2*(11*mi2 + mj2) + mj4 - (11*mi2 + mj2)*mV2)*DiscontinuityB(mi2,mF,mV) + 2*mi2*mj2*(mF2*(mi4 - 5*mi2*mj2 - 8*mj4) - mi4*(mj2 + mV2) + 2*mj4*(mj2 + 4*mV2) + mi2*(11*mj4 + 5*mj2*mV2))*DiscontinuityB(mj2,mF,mV) + (mi - mj)*(mi + mj)*(-2*mi2*mj2*(-(mF2*(mi2 + 11*mj2)) + 7*mj4 + 11*mj2*mV2 + mi2*(5*mj2 + mV2)) + 2*mi2*mj4*(-4*mF4 + 2*mi4 + mj4 - 7*mj2*mV2 + mF2*(3*mi2 + 5*mj2 + 8*mV2) - mi2*(7*mj2 + 9*mV2) - 4*mV4)*ScalarC0(mi2,mj2,mV,mV,mF) + (mF4*(-mi4 + 4*mi2*mj2 + mj4) - mj6*mV2 + mF2*(mj6 - 2*mj4*mV2 + 2*mi4*(mj2 + mV2) - mi2*(11*mj4 + 8*mj2*mV2)) + mi4*(mj4 - mV4) + mj4*mV4 + mi2*(3*mj6 + 17*mj4*mV2 + 4*mj2*mV4))*std::log(r)))*VFin.left()*VFout.left())/(mi2*mj3*Power3(mi - mj)*Power3(mi + mj)) + (mF*(-6*mi2*mj2*(3*mi2 + mj2)*DiscontinuityB(mi2,mF,mV) + 6*mi2*mj2*(mi2 + 3*mj2)*DiscontinuityB(mj2,mF,mV) + (mi - mj)*(mi + mj)*(-24*mi2*mj2 + 2*mi2*mj2*(6*mF2 + mi2 - 7*mj2 - 6*mV2)*ScalarC0(mi2,mj2,mV,mV,mF) + 3*(2*mi2*mj2 - mF2*(mi2 + mj2) + (mi2 + mj2)*mV2)*std::log(r)))*VFin.left()*VFout.right())/(mi2*mj2*Power2(mi - mj)*Power2(mi + mj)) + ((-2*mi2*mj2*(2*mi6 + mF2*(8*mi4 + 5*mi2*mj2 - mj4) + mj4*mV2 - mi4*(11*mj2 + 8*mV2) - mi2*(3*mj4 + 5*mj2*mV2))*DiscontinuityB(mi2,mF,mV) + 2*mi4*mj2*(mi4 + mF2*(mi2 + 11*mj2) - 8*mj4 - 11*mj2*mV2 - mi2*(5*mj2 + mV2))*DiscontinuityB(mj2,mF,mV) + (mi - mj)*(mi + mj)*(-2*mi2*mj2*(mi4 - 13*mi2*mj2 + mF2*(11*mi2 + mj2) - (11*mi2 + mj2)*mV2) + 2*mi4*mj2*(4*mF4 - mi4 + 2*mj4 + 13*mj2*mV2 + 3*mi2*(mj2 + mV2) - mF2*(mi2 + 7*mj2 + 8*mV2) + 4*mV4)*ScalarC0(mi2,mj2,mV,mV,mF) + (mF4*(-mi4 - 4*mi2*mj2 + mj4) + mi6*(mj2 + mV2) - 4*mi2*mj2*mV2*(mj2 + mV2) + mF2*(-mi6 + 7*mi4*mj2 + 2*mi2*mj4 + 2*(mi4 + 4*mi2*mj2 - mj4)*mV2) + mj4*mV4 - mi4*(5*mj4 + 13*mj2*mV2 + mV4))*std::log(r)))*VFin.right()*VFout.right())/(mi3*mj2*Power3(mi - mj)*Power3(mi + mj));
      }
    }
  }
}  

std::complex<double> FFV_VVF_A1R(double mi, double mj, double mF, double mV, auto VFin, auto VFout)
{
  const double mi2=Power2(mi);
  const double mi3=Power3(mi);
  const double mi4=Power4(mi);
  const double mi6=Power6(mi);
  const double mj2=Power2(mj);
  const double mj3=Power3(mj);
  const double mj4=Power4(mj);
  const double mj6=Power6(mj);
  const double mF2=Power2(mF);
  const double mF4=Power4(mF);
  const double mF6=Power6(mF);
  const double mV2=Power2(mV);
  const double mV4=Power4(mV);
  const double mV6=Power6(mV);
  const double pi2=Power2(M_PI);
  if (is_zero(mF)) {
    const auto r = Power2(mF/mV);
    if (mV > approx_limit * std::max(mi,mj)) {
      return - 8. * mF/mj * VFin.left() * VFout.right() * OneLoopFunctionI(r) / mV2
             + mi/mj * VFin.right() * VFout.right() * OneLoopFunctionH(r) / 18. / mV2;
    } else {
      if (is_zero(mi-mj)) {
        if (is_zero(mi-mV)) {
          return (2*VFin.left()*VFout.left())/(3.*mi) - (14*VFin.right()*VFout.right())/(3.*mi);
        } else {
          return ((2*mi2*mV2 + (mi4 + mi2*mV2 - 2*mV4)*std::log(mV2/(-mi2 + mV2)))*VFin.left()*VFout.left())/(3.*Power5(mi)) + ((-2*mi2*(6*mi2 + mV2) + (-13*mi4 + 11*mi2*mV2 + 2*mV4)*std::log(mV2/(-mi2 + mV2)))*VFin.right()*VFout.right())/(3.*Power5(mi));
        }
      } else {
        if (is_zero(mi-mV)) {
          return (-2*mi*(3*mi4*(-10 + pi2) + mj4*(42 + pi2) + 4*mi2*mj2*(-3 + 2*pi2) + 6*(3*mi4 + 8*mi2*mj2 + mj4)*dilog(mj2/(-mi2 + mj2)) + 3*std::log(mi2/(mi2 - mj2))*(8*(-2*mi4 + mi2*mj2 + mj4) + (3*mi4 + 8*mi2*mj2 + mj4)*std::log(mi2/(mi2 - mj2))))*VFin.left()*VFout.left())/(3.*Power3(mi2 - mj2)) + ((6*mi6*mj2 + mi4*mj4*(90 - 11*pi2) - 2*mi2*mj6*(27 + 7*pi2) + 6*mj4*(-11*mi4 - 14*mi2*mj2 + mj4)*dilog(mj2/(-mi2 + mj2)) + (-42 + pi2)*Power8(mj) + 3*std::log(mi2/(mi2 - mj2))*(-2*(-5*mi6*mj2 - 15*mi4*mj4 + 17*mi2*mj6 + Power8(mi) + 2*Power8(mj)) + (-11*mi4*mj4 - 14*mi2*mj6 + Power8(mj))*std::log(mi2/(mi2 - mj2))))*VFin.right()*VFout.right())/(3.*Power3(-(mi2*mj) + mj3));
        } else if (is_zero(mj-mV)) {
          return ((-6*mi2*mj6 + 6*mi6*mj2*(25 + pi2) + mi4*mj4*(-138 + 19*pi2) - (6 + pi2)*Power8(mi) - 6*dilog(mi2/(mi2 - mj2))*(-6*mi6*mj2 - 19*mi4*mj4 + Power8(mi)) - 3*Power2(std::log(mj2/(-mi2 + mj2)))*(-6*mi6*mj2 - 19*mi4*mj4 + Power8(mi)) - 6*(mi - mj)*(mi + mj)*(2*mi2 + mj2)*(mi4 - 10*mi2*mj2 + mj4)*std::log(mj2/(-mi2 + mj2)))*VFin.left()*VFout.left())/(3.*Power3(mi3 - mi*mj2)) + (2*mj*(-(mi4*(-18 + pi2)) + 4*mi2*mj2*(9 + 2*pi2) + mj4*(-54 + 5*pi2) - 6*(mi4 - 8*mi2*mj2 - 5*mj4)*dilog(mi2/(mi2 - mj2)) - 3*(mi4 - 8*mi2*mj2 - 5*mj4)*Power2(std::log(mj2/(-mi2 + mj2))) + 72*(mi - mj)*(mi + mj)*mj2*std::log(mj2/(-mi2 + mj2)))*VFin.right()*VFout.right())/(3.*Power3(-mi2 + mj2));
        } else {
          return (2*(mi4*(mi - mj)*(mi + mj)*mj2*(mi4 - 2*mj4 - 13*mj2*mV2 - 3*mi2*(mj2 + mV2) - 4*mV4)*ScalarC0(mi2,mj2,mV,mV,mF2) + mj2*(mi2*(mi - mj)*(mi + mj)*(mi4 - 13*mi2*mj2 - (11*mi2 + mj2)*mV2) + (mi - mV)*(mi + mV)*(2*mi6 + mj4*mV2 - mi4*(11*mj2 + 8*mV2) - mi2*(3*mj4 + 5*mj2*mV2))*std::log(mV2/(-mi2 + mV2))) + mi4*(mj - mV)*(mj + mV)*(-mi4 + 8*mj4 + 11*mj2*mV2 + mi2*(5*mj2 + mV2))*std::log(mV2/(-mj2 + mV2)))*VFin.left()*VFout.left())/(mj2*Power3(-mi3 + mi*mj2)) + (2*(mi2*(mi - mj)*(mi + mj)*mj4*(2*mi4 + mj4 - 7*mj2*mV2 - mi2*(7*mj2 + 9*mV2) - 4*mV4)*ScalarC0(mi2,mj2,mV,mV,mF2) + mj4*(mi - mV)*(mi + mV)*(-13*mi2*mj2 + mj4 - (11*mi2 + mj2)*mV2)*std::log(mV2/(-mi2 + mV2)) + mi2*(mj2*(-mi2 + mj2)*(7*mj4 + 11*mj2*mV2 + mi2*(5*mj2 + mV2)) + (mj - mV)*(mj + mV)*(-(mi4*(mj2 + mV2)) + 2*mj4*(mj2 + 4*mV2) + mi2*(11*mj4 + 5*mj2*mV2))*std::log(mV2/(-mj2 + mV2))))*VFin.right()*VFout.right())/(mi2*mj3*Power3(mi - mj)*Power3(mi + mj));
        }
      }
    }
  } else {
    const auto r = Power2(mF/mV);
    if (std::max(mV,mF) > approx_limit * std::max(mi,mj)) {
      return - 8. * mF/mj * VFin.left() * VFout.right() * OneLoopFunctionI(r) / mV2
             + mi/mj * VFin.right() * VFout.right() * OneLoopFunctionH(r) / 18. / mV2;
    } else {
      if (is_zero(mi-mj)) {
        return ((-4*mi2*(mF - mV)*(mF + mV) + (2*mi2*(-2*mF6 + 3*mF4*mi2 + mi6 + 6*mF4*mV2 - 3*(2*mF2 + mi2)*mV4 + 2*mV6)*DiscontinuityB(mi2,mF,mV))/KallenLambda(mF2,mi2,mV2) - (-2*mF4 + mi4 + mi2*mV2 + mF2*(mi2 + 4*mV2) - 2*mV4)*std::log(r))*VFin.left()*VFout.left())/(6.*Power5(mi)) + ((-8*mF*(mF2 + mi2 - mV2)*DiscontinuityB(mi2,mF,mV))/KallenLambda(mF2,mi2,mV2) + (4*mF*std::log(r))/mi2)*VFin.right()*VFout.left() + ((-4*mi2*(-mF2 + 6*mi2 + mV2) - (2*mi2*DiscontinuityB(mi2,mF,mV)*(-2*mF6 + 3*mF4*(5*mi2 + 2*mV2) - 6*mF2*(4*mi2*mV2 + mV4) + (13*mi2 + 2*mV2)*Power2(mi2 - mV2)))/KallenLambda(mF2,mi2,mV2) + (-2*mF4 + 13*mF2*mi2 + 13*mi4 + (4*mF2 - 11*mi2)*mV2 - 2*mV4)*std::log(r))*VFin.right()*VFout.right())/(6.*Power5(mi));
      } else {
        return ((-2*mi2*mj2*(2*mi6 + mF2*(8*mi4 + 5*mi2*mj2 - mj4) + mj4*mV2 - mi4*(11*mj2 + 8*mV2) - mi2*(3*mj4 + 5*mj2*mV2))*DiscontinuityB(mi2,mF,mV) + 2*mi4*mj2*(mi4 + mF2*(mi2 + 11*mj2) - 8*mj4 - 11*mj2*mV2 - mi2*(5*mj2 + mV2))*DiscontinuityB(mj2,mF,mV) + (mi - mj)*(mi + mj)*(-2*mi2*mj2*(mi4 - 13*mi2*mj2 + mF2*(11*mi2 + mj2) - (11*mi2 + mj2)*mV2) + 2*mi4*mj2*(4*mF4 - mi4 + 2*mj4 + 13*mj2*mV2 + 3*mi2*(mj2 + mV2) - mF2*(mi2 + 7*mj2 + 8*mV2) + 4*mV4)*ScalarC0(mi2,mj2,mV,mV,mF) + (mF4*(-mi4 - 4*mi2*mj2 + mj4) + mi6*(mj2 + mV2) - 4*mi2*mj2*mV2*(mj2 + mV2) + mF2*(-mi6 + 7*mi4*mj2 + 2*mi2*mj4 + 2*(mi4 + 4*mi2*mj2 - mj4)*mV2) + mj4*mV4 - mi4*(5*mj4 + 13*mj2*mV2 + mV4))*std::log(r)))*VFin.left()*VFout.left())/(mi3*mj2*Power3(mi - mj)*Power3(mi + mj)) + (mF*(-6*mi2*mj2*(3*mi2 + mj2)*DiscontinuityB(mi2,mF,mV) + 6*mi2*mj2*(mi2 + 3*mj2)*DiscontinuityB(mj2,mF,mV) + (mi - mj)*(mi + mj)*(-24*mi2*mj2 + 2*mi2*mj2*(6*mF2 + mi2 - 7*mj2 - 6*mV2)*ScalarC0(mi2,mj2,mV,mV,mF) + 3*(2*mi2*mj2 - mF2*(mi2 + mj2) + (mi2 + mj2)*mV2)*std::log(r)))*VFin.right()*VFout.left())/(mi2*mj2*Power2(mi - mj)*Power2(mi + mj)) + ((2*mi2*mj4*(-13*mi2*mj2 + mF2*(11*mi2 + mj2) + mj4 - (11*mi2 + mj2)*mV2)*DiscontinuityB(mi2,mF,mV) + 2*mi2*mj2*(mF2*(mi4 - 5*mi2*mj2 - 8*mj4) - mi4*(mj2 + mV2) + 2*mj4*(mj2 + 4*mV2) + mi2*(11*mj4 + 5*mj2*mV2))*DiscontinuityB(mj2,mF,mV) + (mi - mj)*(mi + mj)*(-2*mi2*mj2*(-(mF2*(mi2 + 11*mj2)) + 7*mj4 + 11*mj2*mV2 + mi2*(5*mj2 + mV2)) + 2*mi2*mj4*(-4*mF4 + 2*mi4 + mj4 - 7*mj2*mV2 + mF2*(3*mi2 + 5*mj2 + 8*mV2) - mi2*(7*mj2 + 9*mV2) - 4*mV4)*ScalarC0(mi2,mj2,mV,mV,mF) + (mF4*(-mi4 + 4*mi2*mj2 + mj4) - mj6*mV2 + mF2*(mj6 - 2*mj4*mV2 + 2*mi4*(mj2 + mV2) - mi2*(11*mj4 + 8*mj2*mV2)) + mi4*(mj4 - mV4) + mj4*mV4 + mi2*(3*mj6 + 17*mj4*mV2 + 4*mj2*mV4))*std::log(r)))*VFin.right()*VFout.right())/(mi2*mj3*Power3(mi - mj)*Power3(mi + mj));
      }
    }
  }
}  

std::complex<double> FFV_VVF_A2L(double mi, double mj, double mF, double mV, auto VFin, auto VFout)
{
  const double mi2=Power2(mi);
  const double mi3=Power3(mi);
  const double mi4=Power4(mi);
  const double mi6=Power6(mi);
  const double mj2=Power2(mj);
  const double mj3=Power3(mj);
  const double mj4=Power4(mj);
  const double mj6=Power6(mj);
  const double mF2=Power2(mF);
  const double mF4=Power4(mF);
  const double mF6=Power6(mF);
  const double mV2=Power2(mV);
  const double mV4=Power4(mV);
  const double mV6=Power6(mV);
  const double pi2=Power2(M_PI);
  if (is_zero(mF)) {
    const auto r = Power2(mF/mV);
    if (mV > approx_limit * std::max(mi,mj)) {
      return   3. * mF/mj * VFin.left() * VFout.right() * OneLoopFunctionK(r) / mV2
             + mi/mj * VFin.left() * VFout.left() * OneLoopFunctionJ(r) / 6. / mV2 
             + VFin.right() * VFout.right() * OneLoopFunctionJ(r) / 6. / mV2;  
    } else {
      if (is_zero(mi-mj)) {
        if (is_zero(mi-mV)) {
          return (2*VFin.left()*VFout.left())/mi2 + (2*VFin.right()*VFout.right())/mi2;
        } else {
          return ((4*mi4 - 2*mi2*mV2 + (3*mi4 - 5*mi2*mV2 + 2*mV4)*std::log(mV2/(-mi2 + mV2)))*VFin.left()*VFout.left())/mi6 + ((4*mi4 - 2*mi2*mV2 + (3*mi4 - 5*mi2*mV2 + 2*mV4)*std::log(mV2/(-mi2 + mV2)))*VFin.right()*VFout.right())/mi6;
        }
      } else {
        if (is_zero(mi-mV)) {
          return ((-6*mi4*mj2 - mj6*(-18 + pi2) + mi2*mj4*(-12 + 5*pi2) - 6*(-5*mi2 + mj2)*mj4*dilog(mj2/(-mi2 + mj2)) - 3*(-5*mi2 + mj2)*mj4*Power2(std::log(mi2/(mi2 - mj2))) + 6*mi2*(mi4 - 6*mi2*mj2 + 5*mj4)*std::log(mi2/(mi2 - mj2)))*VFin.left()*VFout.left())/(3.*mi*mj3*Power2(mi2 - mj2)) + ((24*(mi - mj)*(mi + mj) - 2*(mi2 + mj2)*pi2 - 12*(mi2 + mj2)*dilog(mj2/(-mi2 + mj2)) - 6*(mi2 + mj2)*Power2(std::log(mi2/(mi2 - mj2))) + 24*(mi - mj)*(mi + mj)*std::log(mi2/(mi2 - mj2)))*VFin.right()*VFout.right())/(3.*Power2(mi2 - mj2));
        } else if (is_zero(mj-mV)) {
          return (-2*mj*(mj2*(-12 + pi2) + mi2*(12 + pi2) + 6*(mi2 + mj2)*dilog(mi2/(mi2 - mj2)) + 3*std::log(mj2/(-mi2 + mj2))*(4*(mi - mj)*(mi + mj) + (mi2 + mj2)*std::log(mj2/(-mi2 + mj2))))*VFin.left()*VFout.left())/(3.*mi*Power2(mi2 - mj2)) - ((6*mi2*mj4 + mi4*mj2*(12 - 5*pi2) + mi6*(-18 + pi2) + 6*(mi6 - 5*mi4*mj2)*dilog(mi2/(mi2 - mj2)) + 3*mi4*(mi2 - 5*mj2)*Power2(std::log(mj2/(-mi2 + mj2))) - 6*mj2*(5*mi4 - 6*mi2*mj2 + mj4)*std::log(mj2/(-mi2 + mj2)))*VFin.right()*VFout.right())/(3.*mi4*Power2(mi - mj)*Power2(mi + mj));
        } else {
          return (2*(-(mi2*(mi - mj)*(mi + mj)*mj4*(2*mi2 - mj2 + 3*mV2)*ScalarC0(mi2,mj2,mV,mV,mF2)) + mj4*(mi - mV)*(mi + mV)*(-4*mi2 + mj2 - mV2)*std::log(mV2/(-mi2 + mV2)) + mi2*((-mi + mj)*(mi + mj)*mj2*(3*mj2 + mV2) + (mj - mV)*(mj + mV)*(3*mi2*mj2 - (mi2 - 2*mj2)*mV2)*std::log(mV2/(-mj2 + mV2))))*VFin.left()*VFout.left())/(mi3*mj3*Power2(mi - mj)*Power2(mi + mj)) + (2*(-(mi4*(mi - mj)*(mi + mj)*mj2*(mi2 - 2*mj2 - 3*mV2)*ScalarC0(mi2,mj2,mV,mV,mF2)) + mj2*(mi2*(mi - mj)*(mi + mj)*(3*mi2 + mV2) + (mi - mV)*(mi + mV)*(3*mi2*mj2 + (2*mi2 - mj2)*mV2)*std::log(mV2/(-mi2 + mV2))) + mi4*(mj - mV)*(mj + mV)*(mi2 - 4*mj2 - mV2)*std::log(mV2/(-mj2 + mV2)))*VFin.right()*VFout.right())/(mi4*mj2*Power2(mi2 - mj2));
        }
      }
    }
  } else {
    const auto r = Power2(mF/mV);
    if (std::max(mV,mF) > approx_limit * std::max(mi,mj)) {
      return   3. * mF/mj * VFin.left() * VFout.right() * OneLoopFunctionK(r) / mV2
             + mi/mj * VFin.left() * VFout.left() * OneLoopFunctionJ(r) / 6. / mV2 
             + VFin.right() * VFout.right() * OneLoopFunctionJ(r) / 6. / mV2;  
    } else {
      if (is_zero(mi-mj)) {
        return ((4*mi2*(mF2 + 2*mi2 - mV2) + (2*mi2*(2*mF6 + mF4*mi2 + 3*mi6 - 2*(3*mF4 + 4*mF2*mi2 + 4*mi4)*mV2 + (6*mF2 + 7*mi2)*mV4 - 2*mV6)*DiscontinuityB(mi2,mF,mV))/KallenLambda(mF2,mi2,mV2) - (2*mF4 + 3*mF2*mi2 + 3*mi4 - (4*mF2 + 5*mi2)*mV2 + 2*mV4)*std::log(r))*VFin.left()*VFout.left())/(2.*mi6) + (3*mF*(2*mi2 + (2*mi2*(mF4 + mi4 - 2*(mF2 + mi2)*mV2 + mV4)*DiscontinuityB(mi2,mF,mV))/KallenLambda(mF2,mi2,mV2) - (mF2 + mi2 - mV2)*std::log(r))*VFin.left()*VFout.right())/Power5(mi) + ((2*(mF2 + 2*mi2 - mV2))/mi4 + ((2*mF6 + mF4*mi2 + 3*mi6 - 2*(3*mF4 + 4*mF2*mi2 + 4*mi4)*mV2 + (6*mF2 + 7*mi2)*mV4 - 2*mV6)*DiscontinuityB(mi2,mF,mV))/(mi4*KallenLambda(mF2,mi2,mV2)) - ((2*mF4 + 3*mF2*mi2 + 3*mi4 - (4*mF2 + 5*mi2)*mV2 + 2*mV4)*std::log(r))/(2.*mi6))*VFin.right()*VFout.right();
      } else {
        return -(((-2*mi2*mj4*(mF2 - 4*mi2 + mj2 - mV2)*DiscontinuityB(mi2,mF,mV) - 2*mi2*mj2*(mF2*(mi2 - 2*mj2) + mi2*(3*mj2 - mV2) + 2*mj2*mV2)*DiscontinuityB(mj2,mF,mV) + (mi - mj)*(mi + mj)*(2*mi2*mj2*(-mF2 + 3*mj2 + mV2) - 2*mi2*mj4*(mF2 - 2*mi2 + mj2 - 3*mV2)*ScalarC0(mi2,mj2,mV,mV,mF) + (mF4*(mi - mj)*(mi + mj) + mj2*(mj - mV)*(mj + mV)*mV2 + mF2*(-mj4 + 2*mi2*(mj - mV)*(mj + mV) + 2*mj2*mV2) + mi2*(-mj4 - 4*mj2*mV2 + mV4))*std::log(r)))*VFin.left()*VFout.left())/(mi3*mj3*Power2(mi - mj)*Power2(mi + mj))) - (3*mF*(2*mi2*mj2*DiscontinuityB(mi2,mF,mV) - 2*mi2*mj2*DiscontinuityB(mj2,mF,mV) + (mi - mj)*(mi + mj)*(2*mi2*mj2*ScalarC0(mi2,mj2,mV,mV,mF) + (mF - mV)*(mF + mV)*std::log(r)))*VFin.left()*VFout.right())/(mi3*(mi - mj)*(mi + mj)*mj2) + ((2*mi2*mj2*(mF2*(-2*mi2 + mj2) - mj2*mV2 + mi2*(3*mj2 + 2*mV2))*DiscontinuityB(mi2,mF,mV) + 2*mi4*mj2*(mF2 + mi2 - 4*mj2 - mV2)*DiscontinuityB(mj2,mF,mV) - (mi - mj)*(mi + mj)*(-2*mi2*mj2*(-mF2 + 3*mi2 + mV2) + 2*mi4*mj2*(mF2 + mi2 - 2*mj2 - 3*mV2)*ScalarC0(mi2,mj2,mV,mV,mF) + (mF4*(mi - mj)*(mi + mj) + mi4*(mj - mV)*(mj + mV) + mF2*(mi4 + 2*mj2*mV2 - 2*mi2*(mj2 + mV2)) - mj2*mV4 + mi2*(4*mj2*mV2 + mV4))*std::log(r)))*VFin.right()*VFout.right())/(mi4*mj2*Power2(mi - mj)*Power2(mi + mj));
      }
    }
  }
}  


std::complex<double> FFV_VVF_A2R(double mi, double mj, double mF, double mV, auto VFin, auto VFout)
{
  const double mi2=Power2(mi);
  const double mi3=Power3(mi);
  const double mi4=Power4(mi);
  const double mi6=Power6(mi);
  const double mj2=Power2(mj);
  const double mj3=Power3(mj);
  const double mj4=Power4(mj);
  const double mj6=Power6(mj);
  const double mF2=Power2(mF);
  const double mF4=Power4(mF);
  const double mF6=Power6(mF);
  const double mV2=Power2(mV);
  const double mV4=Power4(mV);
  const double mV6=Power6(mV);
  const double pi2=Power2(M_PI);
  if (is_zero(mF)) {
    const auto r = Power2(mF/mV);
    if (mV > approx_limit * std::max(mi,mj)) {
      return   3. * mF/mj * VFin.right() * VFout.left() * OneLoopFunctionK(r) / mV2
             + mi/mj * VFin.right() * VFout.right() * OneLoopFunctionJ(r) / 6. / mV2
             + VFin.left() * VFout.left() * OneLoopFunctionJ(r) / 6. / mV2;
    } else {
      if (is_zero(mi-mj)) {
        if (is_zero(mi-mV)) {
          return (2*VFin.left()*VFout.left())/mi2 + (2*VFin.right()*VFout.right())/mi2;
        } else {
          return ((4*mi4 - 2*mi2*mV2 + (3*mi4 - 5*mi2*mV2 + 2*mV4)*std::log(mV2/(-mi2 + mV2)))*VFin.left()*VFout.left())/mi6 + ((4*mi4 - 2*mi2*mV2 + (3*mi4 - 5*mi2*mV2 + 2*mV4)*std::log(mV2/(-mi2 + mV2)))*VFin.right()*VFout.right())/mi6;
        }
      } else {
        if (is_zero(mi-mV)) {
          return (-2*(mi2*(-12 + pi2) + mj2*(12 + pi2) + 6*(mi2 + mj2)*dilog(mj2/(-mi2 + mj2)) + 3*std::log(mi2/(mi2 - mj2))*(-4*(mi - mj)*(mi + mj) + (mi2 + mj2)*std::log(mi2/(mi2 - mj2))))*VFin.left()*VFout.left())/(3.*Power2(mi2 - mj2)) - ((6*mi4*mj2 + mi2*mj4*(12 - 5*pi2) + mj6*(-18 + pi2) + 6*(-5*mi2 + mj2)*mj4*dilog(mj2/(-mi2 + mj2)) + 3*(-5*mi2 + mj2)*mj4*Power2(std::log(mi2/(mi2 - mj2))) - 6*mi2*(mi4 - 6*mi2*mj2 + 5*mj4)*std::log(mi2/(mi2 - mj2)))*VFin.right()*VFout.right())/(3.*mi*mj3*Power2(mi - mj)*Power2(mi + mj));
        } else if (is_zero(mj-mV)) {
          return ((-6*mi2*mj4 - mi6*(-18 + pi2) + mi4*mj2*(-12 + 5*pi2) - 6*(mi6 - 5*mi4*mj2)*dilog(mi2/(mi2 - mj2)) - 3*mi4*(mi2 - 5*mj2)*Power2(std::log(mj2/(-mi2 + mj2))) + 6*mj2*(5*mi4 - 6*mi2*mj2 + mj4)*std::log(mj2/(-mi2 + mj2)))*VFin.left()*VFout.left())/(3.*mi4*Power2(mi2 - mj2)) + (2*mj*(-(mj2*(-12 + pi2)) - mi2*(12 + pi2) - 6*(mi2 + mj2)*dilog(mi2/(mi2 - mj2)) - 3*(mi2 + mj2)*Power2(std::log(mj2/(-mi2 + mj2))) + 12*(-mi + mj)*(mi + mj)*std::log(mj2/(-mi2 + mj2)))*VFin.right()*VFout.right())/(3.*mi*Power2(mi2 - mj2));
        } else {
          return (2*(-(mi4*(mi - mj)*(mi + mj)*mj2*(mi2 - 2*mj2 - 3*mV2)*ScalarC0(mi2,mj2,mV,mV,mF2)) + mj2*(mi2*(mi - mj)*(mi + mj)*(3*mi2 + mV2) + (mi - mV)*(mi + mV)*(3*mi2*mj2 + (2*mi2 - mj2)*mV2)*std::log(mV2/(-mi2 + mV2))) + mi4*(mj - mV)*(mj + mV)*(mi2 - 4*mj2 - mV2)*std::log(mV2/(-mj2 + mV2)))*VFin.left()*VFout.left())/(mi4*mj2*Power2(mi2 - mj2)) + (2*(-(mi2*(mi - mj)*(mi + mj)*mj4*(2*mi2 - mj2 + 3*mV2)*ScalarC0(mi2,mj2,mV,mV,mF2)) + mj4*(mi - mV)*(mi + mV)*(-4*mi2 + mj2 - mV2)*std::log(mV2/(-mi2 + mV2)) + mi2*((-mi + mj)*(mi + mj)*mj2*(3*mj2 + mV2) + (mj - mV)*(mj + mV)*(3*mi2*mj2 - (mi2 - 2*mj2)*mV2)*std::log(mV2/(-mj2 + mV2))))*VFin.right()*VFout.right())/(mi3*mj3*Power2(mi - mj)*Power2(mi + mj));
        }
      }
    }
  } else {
    const auto r = Power2(mF/mV);
    if (std::max(mV,mF) > approx_limit * std::max(mi,mj)) {
      return   3. * mF/mj * VFin.right() * VFout.left() * OneLoopFunctionK(r) / mV2
             + mi/mj * VFin.right() * VFout.right() * OneLoopFunctionJ(r) / 6. / mV2
             + VFin.left() * VFout.left() * OneLoopFunctionJ(r) / 6. / mV2;
    } else {
      if (is_zero(mi-mj)) {
        return ((4*mi2*(mF2 + 2*mi2 - mV2) + (2*mi2*(2*mF6 + mF4*mi2 + 3*mi6 - 2*(3*mF4 + 4*mF2*mi2 + 4*mi4)*mV2 + (6*mF2 + 7*mi2)*mV4 - 2*mV6)*DiscontinuityB(mi2,mF,mV))/KallenLambda(mF2,mi2,mV2) - (2*mF4 + 3*mF2*mi2 + 3*mi4 - (4*mF2 + 5*mi2)*mV2 + 2*mV4)*std::log(r))*VFin.left()*VFout.left())/(2.*mi6) + (3*mF*(2*mi2 + (2*mi2*(mF4 + mi4 - 2*(mF2 + mi2)*mV2 + mV4)*DiscontinuityB(mi2,mF,mV))/KallenLambda(mF2,mi2,mV2) - (mF2 + mi2 - mV2)*std::log(r))*VFin.right()*VFout.left())/Power5(mi) + ((2*(mF2 + 2*mi2 - mV2))/mi4 + ((2*mF6 + mF4*mi2 + 3*mi6 - 2*(3*mF4 + 4*mF2*mi2 + 4*mi4)*mV2 + (6*mF2 + 7*mi2)*mV4 - 2*mV6)*DiscontinuityB(mi2,mF,mV))/(mi4*KallenLambda(mF2,mi2,mV2)) - ((2*mF4 + 3*mF2*mi2 + 3*mi4 - (4*mF2 + 5*mi2)*mV2 + 2*mV4)*std::log(r))/(2.*mi6))*VFin.right()*VFout.right();
      } else {
        return -(((2*mi2*mj2*(mF2*(2*mi2 - mj2) - 3*mi2*mj2 + (-2*mi2 + mj2)*mV2)*DiscontinuityB(mi2,mF,mV) - 2*mi4*mj2*(mF2 + mi2 - 4*mj2 - mV2)*DiscontinuityB(mj2,mF,mV) + (mi - mj)*(mi + mj)*(-2*mi2*mj2*(-mF2 + 3*mi2 + mV2) + 2*mi4*mj2*(mF2 + mi2 - 2*mj2 - 3*mV2)*ScalarC0(mi2,mj2,mV,mV,mF) + (mF4*(mi - mj)*(mi + mj) + mi4*(mj - mV)*(mj + mV) + mF2*(mi4 + 2*mj2*mV2 - 2*mi2*(mj2 + mV2)) - mj2*mV4 + mi2*(4*mj2*mV2 + mV4))*std::log(r)))*VFin.left()*VFout.left())/(mi4*mj2*Power2(mi - mj)*Power2(mi + mj))) - (3*mF*(2*mi2*mj2*DiscontinuityB(mi2,mF,mV) - 2*mi2*mj2*DiscontinuityB(mj2,mF,mV) + (mi - mj)*(mi + mj)*(2*mi2*mj2*ScalarC0(mi2,mj2,mV,mV,mF) + (mF - mV)*(mF + mV)*std::log(r)))*VFin.right()*VFout.left())/(mi3*(mi - mj)*(mi + mj)*mj2) + ((2*mi2*mj4*(mF2 - 4*mi2 + mj2 - mV2)*DiscontinuityB(mi2,mF,mV) + 2*mi2*mj2*(mF2*(mi2 - 2*mj2) + mi2*(3*mj2 - mV2) + 2*mj2*mV2)*DiscontinuityB(mj2,mF,mV) - (mi - mj)*(mi + mj)*(2*mi2*mj2*(-mF2 + 3*mj2 + mV2) - 2*mi2*mj4*(mF2 - 2*mi2 + mj2 - 3*mV2)*ScalarC0(mi2,mj2,mV,mV,mF) + (mF4*(mi - mj)*(mi + mj) + mj2*(mj - mV)*(mj + mV)*mV2 + mF2*(-mj4 + 2*mi2*(mj - mV)*(mj + mV) + 2*mj2*mV2) + mi2*(-mj4 - 4*mj2*mV2 + mV4))*std::log(r)))*VFin.right()*VFout.right())/(mi3*mj3*Power2(mi - mj)*Power2(mi + mj));
      }
    }
  }
}


std::complex<double> FFV_FFV_A1L(double mi, double mj, double mF, double mV, auto VFin, auto VFout)
{
  const double mi2=Power2(mi);
  const double mi3=Power3(mi);
  const double mi4=Power4(mi);
  const double mi6=Power6(mi);
  const double mj2=Power2(mj);
  const double mj3=Power3(mj);
  const double mj4=Power4(mj);
  const double mj6=Power6(mj);
  const double mF2=Power2(mF);
  const double mF4=Power4(mF);
  const double mF6=Power6(mF);
  const double mV2=Power2(mV);
  const double mV4=Power4(mV);
  const double mV6=Power6(mV);
  const double pi2=Power2(M_PI);
  if (is_zero(mV)) {
    if (is_zero(mi-mj)) {
      if (is_zero(mi-mF)) {
        return 1./0.;//((7 + 6/Eps + 6*std::log(Power2(Mu)/mi2))*VFin.left()*VFout.left())/(3.*mi) - ((7 + 6/Eps + 6*std::log(Power2(Mu)/mi2))*VFin.right()*VFout.right())/(3.*mi);
      } else {
        return ((-2*mF2*mi2 + 9*mi4 + 2*(mF4 - 5*mF2*mi2 - \
2*mi4)*std::log(mF2/(mF2 - \
mi2)))*VFin.left()*VFout.left())/(3.*Power5(mi)) + ((2*mF2*mi2 - 9*mi4 \
- 2*(mF4 - 5*mF2*mi2 - 2*mi4)*std::log(mF2/(mF2 - \
mi2)))*VFin.right()*VFout.right())/(3.*Power5(mi));
      }
    } else {
      if (is_zero(mi-mF)) {
        return (-2*(-3*mi6*mj2 + mi2*mj6*(39 + 5*pi2) + mi4*mj4*(-51 \
+ 7*pi2) + 6*(7*mi4*mj4 + 5*mi2*mj6)*dilog(mj2/(-mi2 + mj2)) + \
15*Power8(mj) + 3*std::log(mi2/(mi2 - mj2))*(-9*mi6*mj2 - 5*mi4*mj4 + \
9*mi2*mj6 + Power8(mi) + 4*Power8(mj) + (7*mi4*mj4 + \
5*mi2*mj6)*std::log(mi2/(mi2 - \
mj2))))*VFin.left()*VFout.left())/(3.*Power3(-(mi2*mj) + mj3)) + \
(4*mi*(3*mi2*mj2*(-8 + pi2) + mj4*(24 + pi2) + 6*(3*mi2*mj2 + \
mj4)*dilog(mj2/(-mi2 + mj2)) + 3*mj2*(3*mi2 + \
mj2)*Power2(std::log(mi2/(mi2 - mj2))) + 6*(-mi + mj)*(mi + mj)*(mi2 + \
3*mj2)*std::log(mi2/(mi2 - \
mj2)))*VFin.left()*VFout.right())/(3.*Power2(-(mi2*mj) + mj3)) + \
(2*mi*(24*mj6 + mi4*mj2*(-48 + 5*pi2) + mi2*mj4*(24 + 7*pi2) + \
6*(5*mi4*mj2 + 7*mi2*mj4)*dilog(mj2/(-mi2 + mj2)) + 3*mi2*mj2*(5*mi2 \
+ 7*mj2)*Power2(std::log(mi2/(mi2 - mj2))) + 3*(-mi + mj)*(mi + \
mj)*(3*mi2 + mj2)*(mi2 + 5*mj2)*std::log(mi2/(mi2 - \
mj2)))*VFin.right()*VFout.right())/(3.*mj2*Power3(-mi2 + mj2));
      } else if (is_zero(mj-mF)) {
        return (-2*mj*(24*mi6 + mi2*mj4*(-48 + 5*pi2) + mi4*mj2*(24 + \
7*pi2) + 6*(7*mi4*mj2 + 5*mi2*mj4)*dilog(mi2/(mi2 - mj2)) + \
3*std::log(mj2/(-mi2 + mj2))*((mi - mj)*(mi + mj)*(5*mi2 + mj2)*(mi2 + \
3*mj2) + (7*mi4*mj2 + 5*mi2*mj4)*std::log(mj2/(-mi2 + \
mj2))))*VFin.left()*VFout.left())/(3.*mi2*Power3(mi2 - mj2)) - \
(4*mj*(3*mi2*mj2*(-8 + pi2) + mi4*(24 + pi2) + 6*(mi4 + \
3*mi2*mj2)*dilog(mi2/(mi2 - mj2)) + 3*(mi4 + \
3*mi2*mj2)*Power2(std::log(mj2/(-mi2 + mj2))) + 6*(3*mi4 - 2*mi2*mj2 - \
mj4)*std::log(mj2/(-mi2 + \
mj2)))*VFin.left()*VFout.right())/(3.*Power2(mi3 - mi*mj2)) + \
(2*(-3*mi2*mj6 + mi6*mj2*(39 + 5*pi2) + mi4*mj4*(-51 + 7*pi2) + \
6*(5*mi6*mj2 + 7*mi4*mj4)*dilog(mi2/(mi2 - mj2)) + 15*Power8(mi) + \
3*std::log(mj2/(-mi2 + mj2))*(9*mi6*mj2 - 5*mi4*mj4 - 9*mi2*mj6 + \
4*Power8(mi) + Power8(mj) + (5*mi6*mj2 + 7*mi4*mj4)*std::log(mj2/(-mi2 \
+ mj2))))*VFin.right()*VFout.right())/(3.*Power3(mi3 - mi*mj2));
      } else {
        return (2*(-2*mi2*(mi - mj)*(mi + mj)*(2*mF4 + 2*mi2*mj2 + \
mF2*(5*mi2 + 3*mj2))*mj4*ScalarC0(mi2,mj2,mF,mF,mV2) + (mF - mi)*(mF \
+ mi)*mj4*(5*mi4 + 5*mi2*mj2 + mF2*(11*mi2 + mj2) + \
2*mj4)*std::log(mF2/(mF2 - mi2)) + mi2*(mj2*(-mi2 + mj2)*(7*mi2*mj2 + \
mF2*(mi2 + 11*mj2) + 5*mj4) + (-mF + mj)*(mF + mj)*(3*mi4*mj2 + \
5*mi2*mj4 + mF2*(-mi4 + 5*mi2*mj2 + 8*mj4) + 4*mj6)*std::log(mF2/(mF2 - \
mj2))))*VFin.left()*VFout.left())/(mi2*mj3*Power3(mi - mj)*Power3(mi + \
mj)) - (8*mF*(mi2*(mi - mj)*(mi + mj)*mj2*(2*mF2 + mi2 + \
mj2)*ScalarC0(mi2,mj2,mF,mF,mV2) + mj2*(4*mi2*(mi - mj)*(mi + mj) + \
(-mF + mi)*(mF + mi)*(3*mi2 + mj2)*std::log(mF2/(mF2 - mi2))) + mi2*(mF \
- mj)*(mF + mj)*(mi2 + 3*mj2)*std::log(mF2/(mF2 - \
mj2)))*VFin.left()*VFout.right())/(mi2*mj2*Power2(mi - mj)*Power2(mi + \
mj)) + (2*(-2*mi4*(mi - mj)*(mi + mj)*mj2*(2*mF4 + 2*mi2*mj2 + \
mF2*(3*mi2 + 5*mj2))*ScalarC0(mi2,mj2,mF,mF,mV2) + mj2*(mi2*(-mi + \
mj)*(mi + mj)*(5*mi4 + 7*mi2*mj2 + mF2*(11*mi2 + mj2)) + (mF - \
mi)*(mF + mi)*(4*mi6 + 5*mi4*mj2 + mF2*(8*mi4 + 5*mi2*mj2 - mj4) + \
3*mi2*mj4)*std::log(mF2/(mF2 - mi2))) + mi4*(-mF + mj)*(mF + mj)*(2*mi4 \
+ 5*mi2*mj2 + mF2*(mi2 + 11*mj2) + 5*mj4)*std::log(mF2/(mF2 - \
mj2)))*VFin.right()*VFout.right())/(mj2*Power3(-mi3 + mi*mj2));
      }
    }
  } else {
    const auto r = Power2(mF/mV);
    if (std::max(mF,mV) > approx_limit * std::max(mi,mj)) {
      return   VFin.left() * VFout.left() * OneLoopFunctionL(r) / 9. / mV2
             - mi/mj * VFin.right() * VFout.right() * OneLoopFunctionL(r) / 9. / mV2;   
    } else {
      if (is_zero(mi-mj)) {
        return ((mi2*(-2*mF2 + 9*mi2 + 2*mV2) - (2*mi2*(mF6 + 2*mi6 + \
6*mi4*mV2 - 3*mF4*(2*mi2 + mV2) - 3*mi2*mV4 + 3*mF2*(mi4 + 3*mi2*mV2 \
+ mV4) - mV6)*DiscontinuityB(mi2,mF,mV))/KallenLambda(mF2,mi2,mV2) + \
(mF4 - 5*mF2*mi2 - 2*mi4 - 2*(mF2 - 2*mi2)*mV2 + \
mV4)*std::log(r))*VFin.left()*VFout.left())/(3.*Power5(mi)) - \
((mi2*(-2*mF2 + 9*mi2 + 2*mV2) - (2*mi2*(mF6 + 2*mi6 + 6*mi4*mV2 - \
3*mF4*(2*mi2 + mV2) - 3*mi2*mV4 + 3*mF2*(mi4 + 3*mi2*mV2 + mV4) - \
mV6)*DiscontinuityB(mi2,mF,mV))/KallenLambda(mF2,mi2,mV2) + (mF4 - \
5*mF2*mi2 - 2*mi4 - 2*(mF2 - 2*mi2)*mV2 + \
mV4)*std::log(r))*VFin.right()*VFout.right())/(3.*Power5(mi));
      } else {
        return ((-2*mi2*mj4*(5*mi4 + 5*mi2*mj2 + mF2*(11*mi2 + mj2) + \
2*mj4 - (11*mi2 + mj2)*mV2)*DiscontinuityB(mi2,mF,mV) + \
2*mi2*mj2*(3*mi4*mj2 + 5*mi2*mj4 + mF2*(-mi4 + 5*mi2*mj2 + 8*mj4) + \
4*mj6 + (mi4 - 5*mi2*mj2 - 8*mj4)*mV2)*DiscontinuityB(mj2,mF,mV) - \
(mi - mj)*(mi + mj)*(2*mi2*mj2*(7*mi2*mj2 + mF2*(mi2 + 11*mj2) + \
5*mj4 - (mi2 + 11*mj2)*mV2) + 4*mi2*mj4*(2*mF4 + 2*(mi - mV)*(mj - \
mV)*(mi + mV)*(mj + mV) + mF2*(5*mi2 + 3*mj2 - \
4*mV2))*ScalarC0(mi2,mj2,mF,mF,mV) + (2*mi2*(mi2 + mj2)*mj4 + \
mF4*(-mi4 + 4*mi2*mj2 + mj4) + 2*mF2*(2*mi4*mj2 + 5*mi2*mj4 + mj6 + \
(mi4 - 4*mi2*mj2 - mj4)*mV2) + (-mi4 + 4*mi2*mj2 + mj4)*mV4 - \
2*mj2*mV2*Power2(mi2 + \
mj2))*std::log(r)))*VFin.left()*VFout.left())/(mi2*mj3*Power3(mi - \
mj)*Power3(mi + mj)) + (4*mF*(-2*mi2*mj2*(3*mi2 + \
mj2)*DiscontinuityB(mi2,mF,mV) + 2*mi2*mj2*(mi2 + \
3*mj2)*DiscontinuityB(mj2,mF,mV) + (mi - mj)*(mi + mj)*(-8*mi2*mj2 - \
2*mi2*mj2*(2*mF2 + mi2 + mj2 - 2*mV2)*ScalarC0(mi2,mj2,mF,mF,mV) + \
(-2*mi2*mj2 - mF2*(mi2 + mj2) + (mi2 + \
mj2)*mV2)*std::log(r)))*VFin.left()*VFout.right())/(mi2*mj2*Power2(mi2 - \
mj2)) + ((2*mi2*mj2*(4*mi6 + mF2*(8*mi4 + 5*mi2*mj2 - mj4) + \
mi4*(5*mj2 - 8*mV2) + mj4*mV2 + mi2*(3*mj4 - \
5*mj2*mV2))*DiscontinuityB(mi2,mF,mV) - 2*mi4*mj2*(2*mi4 + 5*mi2*mj2 \
+ mF2*(mi2 + 11*mj2) + 5*mj4 - (mi2 + \
11*mj2)*mV2)*DiscontinuityB(mj2,mF,mV) + (mi - mj)*(mi + \
mj)*(2*mi2*mj2*(5*mi4 + 7*mi2*mj2 + mF2*(11*mi2 + mj2) - (11*mi2 + \
mj2)*mV2) + 4*mi4*mj2*(2*mF4 + 2*(mi - mV)*(mj - mV)*(mi + mV)*(mj + \
mV) + mF2*(3*mi2 + 5*mj2 - 4*mV2))*ScalarC0(mi2,mj2,mF,mF,mV) + \
(2*mi4*mj2*(mi2 + mj2) + mF4*(mi4 + 4*mi2*mj2 - mj4) + 2*mF2*(mi6 + \
5*mi4*mj2 + 2*mi2*mj4 + (-mi4 - 4*mi2*mj2 + mj4)*mV2) + (mi4 + \
4*mi2*mj2 - mj4)*mV4 - 2*mi2*mV2*Power2(mi2 + \
mj2))*std::log(r)))*VFin.right()*VFout.right())/(mi3*mj2*Power3(mi - \
mj)*Power3(mi + mj));
      }
    }
  }
}

std::complex<double> FFV_FFV_A1R(double mi, double mj, double mF, double mV, auto VFin, auto VFout)
{
  const double mi2=Power2(mi);
  const double mi3=Power3(mi);
  const double mi4=Power4(mi);
  const double mi6=Power6(mi);
  const double mj2=Power2(mj);
  const double mj3=Power3(mj);
  const double mj4=Power4(mj);
  const double mj6=Power6(mj);
  const double mF2=Power2(mF);
  const double mF4=Power4(mF);
  const double mF6=Power6(mF);
  const double mV2=Power2(mV);
  const double mV4=Power4(mV);
  const double mV6=Power6(mV);
  const double pi2=Power2(M_PI);
  if (is_zero(mV)) {
    if (is_zero(mi-mj)) {
      if (is_zero(mi-mF)) {
        return 1./0.;//-((7 + 6/Eps + 6*std::log(Power2(Mu)/mi2))*VFin.left()*VFout.left())/(3.*mi) + ((7 + 6/Eps + 6*std::log(Power2(Mu)/mi2))*VFin.right()*VFout.right())/(3.*mi);
      } else {
        return ((2*mF2*mi2 - 9*mi4 - 2*(mF4 - 5*mF2*mi2 - \
2*mi4)*std::log(mF2/(mF2 - \
mi2)))*VFin.left()*VFout.left())/(3.*Power5(mi)) + ((-2*mF2*mi2 + 9*mi4 \
+ 2*(mF4 - 5*mF2*mi2 - 2*mi4)*std::log(mF2/(mF2 - \
mi2)))*VFin.right()*VFout.right())/(3.*Power5(mi));
      }
    } else {
      if (is_zero(mi-mF)) {
        return (2*mi*(24*mj6 + mi4*mj2*(-48 + 5*pi2) + mi2*mj4*(24 + \
7*pi2) + 6*(5*mi4*mj2 + 7*mi2*mj4)*dilog(mj2/(-mi2 + mj2)) + \
3*mi2*mj2*(5*mi2 + 7*mj2)*Power2(std::log(mi2/(mi2 - mj2))) + 3*(-mi + \
mj)*(mi + mj)*(3*mi2 + mj2)*(mi2 + 5*mj2)*std::log(mi2/(mi2 - \
mj2)))*VFin.left()*VFout.left())/(3.*mj2*Power3(-mi2 + mj2)) + \
(4*mi*(3*mi2*mj2*(-8 + pi2) + mj4*(24 + pi2) + 6*(3*mi2*mj2 + \
mj4)*dilog(mj2/(-mi2 + mj2)) + 3*mj2*(3*mi2 + \
mj2)*Power2(std::log(mi2/(mi2 - mj2))) + 6*(-mi + mj)*(mi + mj)*(mi2 + \
3*mj2)*std::log(mi2/(mi2 - \
mj2)))*VFin.right()*VFout.left())/(3.*Power2(-(mi2*mj) + mj3)) + \
(2*(-3*mi6*mj2 + mi2*mj6*(39 + 5*pi2) + mi4*mj4*(-51 + 7*pi2) + \
6*(7*mi4*mj4 + 5*mi2*mj6)*dilog(mj2/(-mi2 + mj2)) + 15*Power8(mj) + \
3*std::log(mi2/(mi2 - mj2))*(-9*mi6*mj2 - 5*mi4*mj4 + 9*mi2*mj6 + \
Power8(mi) + 4*Power8(mj) + (7*mi4*mj4 + 5*mi2*mj6)*std::log(mi2/(mi2 - \
mj2))))*VFin.right()*VFout.right())/(3.*mj3*Power3(mi2 - mj2));
      } else if (is_zero(mj-mF)) {
        return (2*(-3*mi2*mj6 + mi6*mj2*(39 + 5*pi2) + mi4*mj4*(-51 + \
7*pi2) + 6*(5*mi6*mj2 + 7*mi4*mj4)*dilog(mi2/(mi2 - mj2)) + \
15*Power8(mi) + 3*std::log(mj2/(-mi2 + mj2))*(9*mi6*mj2 - 5*mi4*mj4 - \
9*mi2*mj6 + 4*Power8(mi) + Power8(mj) + (5*mi6*mj2 + \
7*mi4*mj4)*std::log(mj2/(-mi2 + \
mj2))))*VFin.left()*VFout.left())/(3.*Power3(mi3 - mi*mj2)) - \
(4*mj*(3*mi2*mj2*(-8 + pi2) + mi4*(24 + pi2) + 6*(mi4 + \
3*mi2*mj2)*dilog(mi2/(mi2 - mj2)) + 3*(mi4 + \
3*mi2*mj2)*Power2(std::log(mj2/(-mi2 + mj2))) + 6*(3*mi4 - 2*mi2*mj2 - \
mj4)*std::log(mj2/(-mi2 + \
mj2)))*VFin.right()*VFout.left())/(3.*Power2(mi3 - mi*mj2)) - \
(2*mj*(24*mi6 + mi2*mj4*(-48 + 5*pi2) + mi4*mj2*(24 + 7*pi2) + \
6*(7*mi4*mj2 + 5*mi2*mj4)*dilog(mi2/(mi2 - mj2)) + 3*std::log(mj2/(-mi2 \
+ mj2))*((mi - mj)*(mi + mj)*(5*mi2 + mj2)*(mi2 + 3*mj2) + (7*mi4*mj2 \
+ 5*mi2*mj4)*std::log(mj2/(-mi2 + \
mj2))))*VFin.right()*VFout.right())/(3.*mi2*Power3(mi - mj)*Power3(mi + \
mj));
      } else {
        return (-2*(2*mi4*(mi - mj)*(mi + mj)*mj2*(2*mF4 + 2*mi2*mj2 \
+ mF2*(3*mi2 + 5*mj2))*ScalarC0(mi2,mj2,mF,mF,mV2) + mj2*(mi2*(mi - \
mj)*(mi + mj)*(5*mi4 + 7*mi2*mj2 + mF2*(11*mi2 + mj2)) + (-mF + \
mi)*(mF + mi)*(4*mi6 + 5*mi4*mj2 + mF2*(8*mi4 + 5*mi2*mj2 - mj4) + \
3*mi2*mj4)*std::log(mF2/(mF2 - mi2))) + mi4*(mF - mj)*(mF + mj)*(2*mi4 \
+ 5*mi2*mj2 + mF2*(mi2 + 11*mj2) + 5*mj4)*std::log(mF2/(mF2 - \
mj2)))*VFin.left()*VFout.left())/(mj2*Power3(-mi3 + mi*mj2)) - \
(8*mF*(mi2*(mi - mj)*(mi + mj)*mj2*(2*mF2 + mi2 + \
mj2)*ScalarC0(mi2,mj2,mF,mF,mV2) + mj2*(4*mi2*(mi - mj)*(mi + mj) + \
(-mF + mi)*(mF + mi)*(3*mi2 + mj2)*std::log(mF2/(mF2 - mi2))) + mi2*(mF \
- mj)*(mF + mj)*(mi2 + 3*mj2)*std::log(mF2/(mF2 - \
mj2)))*VFin.right()*VFout.left())/(mi2*mj2*Power2(mi - mj)*Power2(mi + \
mj)) + (2*(-2*mi2*(mi - mj)*(mi + mj)*(2*mF4 + 2*mi2*mj2 + mF2*(5*mi2 \
+ 3*mj2))*mj4*ScalarC0(mi2,mj2,mF,mF,mV2) + (mF - mi)*(mF + \
mi)*mj4*(5*mi4 + 5*mi2*mj2 + mF2*(11*mi2 + mj2) + \
2*mj4)*std::log(mF2/(mF2 - mi2)) + mi2*(mj2*(-mi2 + mj2)*(7*mi2*mj2 + \
mF2*(mi2 + 11*mj2) + 5*mj4) + (-mF + mj)*(mF + mj)*(3*mi4*mj2 + \
5*mi2*mj4 + mF2*(-mi4 + 5*mi2*mj2 + 8*mj4) + 4*mj6)*std::log(mF2/(mF2 - \
mj2))))*VFin.right()*VFout.right())/(mi2*mj3*Power3(mi - mj)*Power3(mi \
+ mj));
      }
    }
  } else {
    const auto r = Power2(mF/mV);
    if (std::max(mF,mV) > approx_limit * std::max(mi,mj)) {
      return   VFin.right() * VFout.right() * OneLoopFunctionL(r) / 9. / mV2
             - mi/mj * VFin.left() * VFout.left() * OneLoopFunctionL(r) / 9. / mV2;  
    } else {
      if (is_zero(mi-mj)) {
        return ((mi2*(2*mF2 - 9*mi2 - 2*mV2) + (2*mi2*(mF6 + 2*mi6 + \
6*mi4*mV2 - 3*mF4*(2*mi2 + mV2) - 3*mi2*mV4 + 3*mF2*(mi4 + 3*mi2*mV2 \
+ mV4) - mV6)*DiscontinuityB(mi2,mF,mV))/KallenLambda(mF2,mi2,mV2) - \
(mF4 - 5*mF2*mi2 - 2*mi4 - 2*(mF2 - 2*mi2)*mV2 + \
mV4)*std::log(r))*VFin.left()*VFout.left())/(3.*Power5(mi)) + \
((mi2*(-2*mF2 + 9*mi2 + 2*mV2) - (2*mi2*(mF6 + 2*mi6 + 6*mi4*mV2 - \
3*mF4*(2*mi2 + mV2) - 3*mi2*mV4 + 3*mF2*(mi4 + 3*mi2*mV2 + mV4) - \
mV6)*DiscontinuityB(mi2,mF,mV))/KallenLambda(mF2,mi2,mV2) + (mF4 - \
5*mF2*mi2 - 2*mi4 - 2*(mF2 - 2*mi2)*mV2 + \
mV4)*std::log(r))*VFin.right()*VFout.right())/(3.*Power5(mi));
      } else {
        return ((2*mi2*mj2*(4*mi6 + mF2*(8*mi4 + 5*mi2*mj2 - mj4) + \
mi4*(5*mj2 - 8*mV2) + mj4*mV2 + mi2*(3*mj4 - \
5*mj2*mV2))*DiscontinuityB(mi2,mF,mV) - 2*mi4*mj2*(2*mi4 + 5*mi2*mj2 \
+ mF2*(mi2 + 11*mj2) + 5*mj4 - (mi2 + \
11*mj2)*mV2)*DiscontinuityB(mj2,mF,mV) + (mi - mj)*(mi + \
mj)*(2*mi2*mj2*(5*mi4 + 7*mi2*mj2 + mF2*(11*mi2 + mj2) - (11*mi2 + \
mj2)*mV2) + 4*mi4*mj2*(2*mF4 + 2*(mi - mV)*(mj - mV)*(mi + mV)*(mj + \
mV) + mF2*(3*mi2 + 5*mj2 - 4*mV2))*ScalarC0(mi2,mj2,mF,mF,mV) + \
(2*mi4*mj2*(mi2 + mj2) + mF4*(mi4 + 4*mi2*mj2 - mj4) + 2*mF2*(mi6 + \
5*mi4*mj2 + 2*mi2*mj4 + (-mi4 - 4*mi2*mj2 + mj4)*mV2) + (mi4 + \
4*mi2*mj2 - mj4)*mV4 - 2*mi2*mV2*Power2(mi2 + \
mj2))*std::log(r)))*VFin.left()*VFout.left())/(mi3*mj2*Power3(mi - \
mj)*Power3(mi + mj)) + (4*mF*(-2*mi2*mj2*(3*mi2 + \
mj2)*DiscontinuityB(mi2,mF,mV) + 2*mi2*mj2*(mi2 + \
3*mj2)*DiscontinuityB(mj2,mF,mV) + (mi - mj)*(mi + mj)*(-8*mi2*mj2 - \
2*mi2*mj2*(2*mF2 + mi2 + mj2 - 2*mV2)*ScalarC0(mi2,mj2,mF,mF,mV) + \
(-2*mi2*mj2 - mF2*(mi2 + mj2) + (mi2 + \
mj2)*mV2)*std::log(r)))*VFin.right()*VFout.left())/(mi2*mj2*Power2(mi2 - \
mj2)) + ((-2*mi2*mj4*(5*mi4 + 5*mi2*mj2 + mF2*(11*mi2 + mj2) + 2*mj4 \
- (11*mi2 + mj2)*mV2)*DiscontinuityB(mi2,mF,mV) + \
2*mi2*mj2*(3*mi4*mj2 + 5*mi2*mj4 + mF2*(-mi4 + 5*mi2*mj2 + 8*mj4) + \
4*mj6 + (mi4 - 5*mi2*mj2 - 8*mj4)*mV2)*DiscontinuityB(mj2,mF,mV) - \
(mi - mj)*(mi + mj)*(2*mi2*mj2*(7*mi2*mj2 + mF2*(mi2 + 11*mj2) + \
5*mj4 - (mi2 + 11*mj2)*mV2) + 4*mi2*mj4*(2*mF4 + 2*(mi - mV)*(mj - \
mV)*(mi + mV)*(mj + mV) + mF2*(5*mi2 + 3*mj2 - \
4*mV2))*ScalarC0(mi2,mj2,mF,mF,mV) + (2*mi2*(mi2 + mj2)*mj4 + \
mF4*(-mi4 + 4*mi2*mj2 + mj4) + 2*mF2*(2*mi4*mj2 + 5*mi2*mj4 + mj6 + \
(mi4 - 4*mi2*mj2 - mj4)*mV2) + (-mi4 + 4*mi2*mj2 + mj4)*mV4 - \
2*mj2*mV2*Power2(mi2 + \
mj2))*std::log(r)))*VFin.right()*VFout.right())/(mi2*mj3*Power3(mi - \
mj)*Power3(mi + mj));
      }
    }
  }
}

std::complex<double> FFV_FFV_A2L(double mi, double mj, double mF, double mV, auto VFin, auto VFout)
{
  const double mi2=Power2(mi);
  const double mi3=Power3(mi);
  const double mi4=Power4(mi);
  const double mi6=Power6(mi);
  const double mj2=Power2(mj);
  const double mj3=Power3(mj);
  const double mj4=Power4(mj);
  const double mj6=Power6(mj);
  const double mF2=Power2(mF);
  const double mF4=Power4(mF);
  const double mF6=Power6(mF);
  const double mV2=Power2(mV);
  const double mV4=Power4(mV);
  const double mV6=Power6(mV);
  const double pi2=Power2(M_PI);
  if (is_zero(mV)) {
    if (is_zero(mi-mj)) {
      if (is_zero(mi-mF)) {
        return 1./0.;//-(((5 + 2/Eps + 2*std::log(Power2(Mu)/mi2))*VFin.left()*VFout.left())/mi2) + (4*(2 + 1/Eps + std::log(Power2(Mu)/mi2))*VFin.left()*VFout.right())/mi2 - ((5 + 2/Eps + 2*std::log(Power2(Mu)/mi2))*VFin.right()*VFout.right())/mi2;
      } else {
        return ((-2*mF2*mi2 - 3*mi4 + 2*mF2*(mF2 + \
mi2)*std::log(mF2/(mF2 - mi2)))*VFin.left()*VFout.left())/mi6 + \
(8*mF*(mi2 - mF2*std::log(mF2/(mF2 - \
mi2)))*VFin.left()*VFout.right())/Power5(mi) + ((-2*mF2*mi2 - 3*mi4 + \
2*mF2*(mF2 + mi2)*std::log(mF2/(mF2 - \
mi2)))*VFin.right()*VFout.right())/mi6;
      }
    } else {
      if (is_zero(mi-mF)) {
        return (2*(-3*mi4*mj2 + 3*mj6 + mi2*mj4*pi2 + \
6*mi2*mj4*dilog(mj2/(-mi2 + mj2)) + 3*std::log(mi2/(mi2 - mj2))*(mi6 - \
2*mi4*mj2 - mi2*mj4 + 2*mj6 + mi2*mj4*std::log(mi2/(mi2 - \
mj2))))*VFin.left()*VFout.left())/(3.*mi*mj3*Power2(mi2 - mj2)) - \
(8*std::log(mi2/(mi2 - mj2))*VFin.left()*VFout.right())/mj2 - (2*(6*mj4 + \
mi2*mj2*(-6 + pi2) + 6*mi2*mj2*dilog(mj2/(-mi2 + mj2)) + \
3*std::log(mi2/(mi2 - mj2))*(-3*mi4 + 4*mi2*mj2 - mj4 + \
mi2*mj2*std::log(mi2/(mi2 - \
mj2))))*VFin.right()*VFout.right())/(3.*Power2(-(mi2*mj) + mj3));
      } else if (is_zero(mj-mF)) {
        return (-2*mj*(6*mi4 + mi2*mj2*(-6 + pi2) + \
6*mi2*mj2*dilog(mi2/(mi2 - mj2)) + 3*std::log(mj2/(-mi2 + mj2))*(-mi4 + \
4*mi2*mj2 - 3*mj4 + mi2*mj2*std::log(mj2/(-mi2 + \
mj2))))*VFin.left()*VFout.left())/(3.*mi3*Power2(mi2 - mj2)) - \
(8*mj*std::log(mj2/(-mi2 + mj2))*VFin.left()*VFout.right())/mi3 + \
(2*(3*mi6 - 3*mi2*mj4 + mi4*mj2*pi2 + 6*mi4*mj2*dilog(mi2/(mi2 - \
mj2)) + 3*std::log(mj2/(-mi2 + mj2))*(2*mi6 - mi4*mj2 - 2*mi2*mj4 + mj6 \
+ mi4*mj2*std::log(mj2/(-mi2 + \
mj2))))*VFin.right()*VFout.right())/(3.*mi4*Power2(mi2 - mj2));
      } else {
        return (2*(2*mF2*mi2*(-mi2 + \
mj2)*mj4*ScalarC0(mi2,mj2,mF,mF,mV2) + (mF - mi)*(mF + mi)*(mF2 - mi2 \
+ 2*mj2)*mj4*std::log(mF2/(mF2 - mi2)) + mi2*(mF2 + mj2)*(-(mi2*mj2) + \
mj4 + (mF - mj)*(mF + mj)*(mi2 - 2*mj2)*std::log(mF2/(mF2 - \
mj2))))*VFin.left()*VFout.left())/(mi3*mj3*Power2(mi - mj)*Power2(mi + \
mj)) + (8*mF*((mF2 - mi2)*mj2*std::log(mF2/(mF2 - mi2)) + mi2*(-mF2 + \
mj2)*std::log(mF2/(mF2 - mj2)))*VFin.left()*VFout.right())/(mi3*(mi2 - \
mj2)*mj2) + (2*(2*mF2*mi4*(mi - mj)*(mi + \
mj)*mj2*ScalarC0(mi2,mj2,mF,mF,mV2) + mj2*(mi2*(mF2 + mi2)*(mi - \
mj)*(mi + mj) - (mF4 - mi4)*(2*mi2 - mj2)*std::log(mF2/(mF2 - mi2))) + \
mi4*(mF - mj)*(mF + mj)*(mF2 + 2*mi2 - mj2)*std::log(mF2/(mF2 - \
mj2)))*VFin.right()*VFout.right())/(mi4*mj2*Power2(mi2 - mj2));
      }
    }
  } else {
    const auto r = Power2(mF/mV);
    if (std::max(mF,mV) > approx_limit * std::max(mi,mj)) {
      return - 4. * mF/mj * VFin.left() * VFout.right() * OneLoopFunctionC(r) / 3. / mV2
             + mi/mj * VFin.left() * VFout.left() * OneLoopFunctionM(r) / 3. / mV2
             + VFin.right() * VFout.right() * OneLoopFunctionM(r) / 3. / mV2; 
    } else {
      if (is_zero(mi-mj)) {
        return ((mi2*(-2*mF2 - 3*mi2 + 2*mV2) + (2*mi2*(mF2 + mi2 - \
mV2)*(-mF4 + mF2*mi2 + 2*(mF2 + mi2)*mV2 - \
mV4)*DiscontinuityB(mi2,mF,mV))/KallenLambda(mF2,mi2,mV2) + (mF2*(mF2 \
+ mi2) - 2*(mF2 + mi2)*mV2 + \
mV4)*std::log(r))*VFin.left()*VFout.left())/mi6 + (4*mF*(2*mi2 + \
(2*mi2*(mF4 - mi2*mV2 - mF2*(mi2 + 2*mV2) + \
mV4)*DiscontinuityB(mi2,mF,mV))/KallenLambda(mF2,mi2,mV2) + (-mF2 + \
mV2)*std::log(r))*VFin.left()*VFout.right())/Power5(mi) + ((mi2*(-2*mF2 - \
3*mi2 + 2*mV2) + (2*mi2*(mF2 + mi2 - mV2)*(-mF4 + mF2*mi2 + 2*(mF2 + \
mi2)*mV2 - mV4)*DiscontinuityB(mi2,mF,mV))/KallenLambda(mF2,mi2,mV2) \
+ (mF2*(mF2 + mi2) - 2*(mF2 + mi2)*mV2 + \
mV4)*std::log(r))*VFin.right()*VFout.right())/mi6;
      } else {
        return ((2*mi2*mj4*(-mF2 + mi2 - 2*mj2 + \
mV2)*DiscontinuityB(mi2,mF,mV) - 2*mi2*(mi2 - 2*mj2)*mj2*(mF2 + mj2 - \
mV2)*DiscontinuityB(mj2,mF,mV) - (mi - mj)*(mi + mj)*(2*mi2*mj2*(mF2 \
+ mj2 - mV2) + 4*mF2*mi2*mj4*ScalarC0(mi2,mj2,mF,mF,mV) + (mF4*(-mi2 \
+ mj2) + 2*mF2*mj4 + 2*(mi - mj)*(mi + mj)*(mF2 + mj2)*mV2 + (-mi2 + \
mj2)*mV4)*std::log(r)))*VFin.left()*VFout.left())/(mi3*mj3*Power2(mi - \
mj)*Power2(mi + mj)) + ((8*mF*(-DiscontinuityB(mi2,mF,mV) + \
DiscontinuityB(mj2,mF,mV)))/(mi3 - mi*mj2) - (4*mF*(mF - mV)*(mF + \
mV)*std::log(r))/(mi3*mj2))*VFin.left()*VFout.right() + ((2*mi2*(2*mi2 - \
mj2)*mj2*(mF2 + mi2 - mV2)*DiscontinuityB(mi2,mF,mV) + \
2*mi4*mj2*(-mF2 - 2*mi2 + mj2 + mV2)*DiscontinuityB(mj2,mF,mV) + (mi \
- mj)*(mi + mj)*(2*mi2*mj2*(mF2 + mi2 - mV2) + \
4*mF2*mi4*mj2*ScalarC0(mi2,mj2,mF,mF,mV) + (2*mF2*mi4 + mF4*(mi - \
mj)*(mi + mj) - 2*(mF2 + mi2)*(mi - mj)*(mi + mj)*mV2 + (mi - mj)*(mi \
+ mj)*mV4)*std::log(r)))*VFin.right()*VFout.right())/(mi4*mj2*Power2(mi - \
mj)*Power2(mi + mj));
      }
    }
  }  
}

std::complex<double> FFV_FFV_A2R(double mi, double mj, double mF, double mV, auto VFin, auto VFout)
{
  const double mi2=Power2(mi);
  const double mi3=Power3(mi);
  const double mi4=Power4(mi);
  const double mi6=Power6(mi);
  const double mj2=Power2(mj);
  const double mj3=Power3(mj);
  const double mj4=Power4(mj);
  const double mj6=Power6(mj);
  const double mF2=Power2(mF);
  const double mF4=Power4(mF);
  const double mF6=Power6(mF);
  const double mV2=Power2(mV);
  const double mV4=Power4(mV);
  const double mV6=Power6(mV);
  const double pi2=Power2(M_PI);
  if (is_zero(mV)) {
    if (is_zero(mi-mj)) {
      if (is_zero(mi-mF)) {
        return 1./0.;//-(((5 + 2/Eps + 2*std::log(Power2(Mu)/mi2))*VFin.left()*VFout.left())/mi2) + (4*(2 + 1/Eps + std::log(Power2(Mu)/mi2))*VFin.right()*VFout.left())/mi2 - ((5 + 2/Eps + 2*std::log(Power2(Mu)/mi2))*VFin.right()*VFout.right())/mi2;
      } else {
        return ((-2*mF2*mi2 - 3*mi4 + 2*mF2*(mF2 + \
mi2)*std::log(mF2/(mF2 - mi2)))*VFin.left()*VFout.left())/mi6 + \
(8*mF*(mi2 - mF2*std::log(mF2/(mF2 - \
mi2)))*VFin.right()*VFout.left())/Power5(mi) + ((-2*mF2*mi2 - 3*mi4 + \
2*mF2*(mF2 + mi2)*std::log(mF2/(mF2 - \
mi2)))*VFin.right()*VFout.right())/mi6;
      }
    } else {
      if (is_zero(mi-mF)) {
        return (-2*(6*mj4 + mi2*mj2*(-6 + pi2) + \
6*mi2*mj2*dilog(mj2/(-mi2 + mj2)) + 3*std::log(mi2/(mi2 - mj2))*(-3*mi4 \
+ 4*mi2*mj2 - mj4 + mi2*mj2*std::log(mi2/(mi2 - \
mj2))))*VFin.left()*VFout.left())/(3.*Power2(-(mi2*mj) + mj3)) - \
(8*std::log(mi2/(mi2 - mj2))*VFin.right()*VFout.left())/mj2 + \
(2*(-3*mi4*mj2 + 3*mj6 + mi2*mj4*pi2 + 6*mi2*mj4*dilog(mj2/(-mi2 + \
mj2)) + 3*std::log(mi2/(mi2 - mj2))*(mi6 - 2*mi4*mj2 - mi2*mj4 + 2*mj6 \
+ mi2*mj4*std::log(mi2/(mi2 - \
mj2))))*VFin.right()*VFout.right())/(3.*mi*mj3*Power2(mi2 - mj2));
      } else if (is_zero(mj-mF)) {
        return (2*(3*mi6 - 3*mi2*mj4 + mi4*mj2*pi2 + \
6*mi4*mj2*dilog(mi2/(mi2 - mj2)) + 3*std::log(mj2/(-mi2 + mj2))*(2*mi6 \
- mi4*mj2 - 2*mi2*mj4 + mj6 + mi4*mj2*std::log(mj2/(-mi2 + \
mj2))))*VFin.left()*VFout.left())/(3.*mi4*Power2(mi2 - mj2)) - \
(8*mj*std::log(mj2/(-mi2 + mj2))*VFin.right()*VFout.left())/mi3 - \
(2*(6*mi4*mj + mi2*mj3*(-6 + pi2) + 6*mi2*mj3*dilog(mi2/(mi2 - mj2)) \
- 3*mj*std::log(mj2/(-mi2 + mj2))*(mi4 - 4*mi2*mj2 + 3*mj4 - \
mi2*mj2*std::log(mj2/(-mi2 + \
mj2))))*VFin.right()*VFout.right())/(3.*mi3*Power2(mi2 - mj2));
      } else {
        return (2*(2*mF2*mi4*(mi - mj)*(mi + \
mj)*mj2*ScalarC0(mi2,mj2,mF,mF,mV2) + mj2*(mi2*(mF2 + mi2)*(mi - \
mj)*(mi + mj) - (mF4 - mi4)*(2*mi2 - mj2)*std::log(mF2/(mF2 - mi2))) + \
mi4*(mF - mj)*(mF + mj)*(mF2 + 2*mi2 - mj2)*std::log(mF2/(mF2 - \
mj2)))*VFin.left()*VFout.left())/(mi4*mj2*Power2(mi2 - mj2)) + \
(8*mF*((mF2 - mi2)*mj2*std::log(mF2/(mF2 - mi2)) + mi2*(-mF2 + \
mj2)*std::log(mF2/(mF2 - mj2)))*VFin.right()*VFout.left())/(mi3*(mi2 - \
mj2)*mj2) + (2*(2*mF2*mi2*(-mi2 + \
mj2)*mj4*ScalarC0(mi2,mj2,mF,mF,mV2) + (mF - mi)*(mF + mi)*(mF2 - mi2 \
+ 2*mj2)*mj4*std::log(mF2/(mF2 - mi2)) + mi2*(mF2 + mj2)*(-(mi2*mj2) + \
mj4 + (mF - mj)*(mF + mj)*(mi2 - 2*mj2)*std::log(mF2/(mF2 - \
mj2))))*VFin.right()*VFout.right())/(mi3*mj3*Power2(mi - mj)*Power2(mi \
+ mj));
      }
    }
  } else {
    const auto r = Power2(mF/mV);
    if (std::max(mF,mV) > approx_limit * std::max(mi,mj)) {
      return - 4. * mF/mj * VFin.right() * VFout.left() * OneLoopFunctionC(r) / 3. / mV2
              + mi/mj * VFin.right() * VFout.right() * OneLoopFunctionM(r) / 3. / mV2
              + VFin.left() * VFout.left() * OneLoopFunctionM(r) / 3. / mV2;
    } else {
      if (is_zero(mi-mj)) {
        return ((mi2*(-2*mF2 - 3*mi2 + 2*mV2) + (2*mi2*(mF2 + mi2 - \
mV2)*(-mF4 + mF2*mi2 + 2*(mF2 + mi2)*mV2 - \
mV4)*DiscontinuityB(mi2,mF,mV))/KallenLambda(mF2,mi2,mV2) + (mF2*(mF2 \
+ mi2) - 2*(mF2 + mi2)*mV2 + \
mV4)*std::log(r))*VFin.left()*VFout.left())/mi6 + (4*mF*(2*mi2 + \
(2*mi2*(mF4 - mi2*mV2 - mF2*(mi2 + 2*mV2) + \
mV4)*DiscontinuityB(mi2,mF,mV))/KallenLambda(mF2,mi2,mV2) + (-mF2 + \
mV2)*std::log(r))*VFin.right()*VFout.left())/Power5(mi) + ((mi2*(-2*mF2 - \
3*mi2 + 2*mV2) + (2*mi2*(mF2 + mi2 - mV2)*(-mF4 + mF2*mi2 + 2*(mF2 + \
mi2)*mV2 - mV4)*DiscontinuityB(mi2,mF,mV))/KallenLambda(mF2,mi2,mV2) \
+ (mF2*(mF2 + mi2) - 2*(mF2 + mi2)*mV2 + \
mV4)*std::log(r))*VFin.right()*VFout.right())/mi6;
      } else {
        return ((2*mi2*(2*mi2 - mj2)*mj2*(mF2 + mi2 - \
mV2)*DiscontinuityB(mi2,mF,mV) + 2*mi4*mj2*(-mF2 - 2*mi2 + mj2 + \
mV2)*DiscontinuityB(mj2,mF,mV) + (mi - mj)*(mi + mj)*(2*mi2*mj2*(mF2 \
+ mi2 - mV2) + 4*mF2*mi4*mj2*ScalarC0(mi2,mj2,mF,mF,mV) + (2*mF2*mi4 \
+ mF4*(mi - mj)*(mi + mj) - 2*(mF2 + mi2)*(mi - mj)*(mi + mj)*mV2 + \
(mi - mj)*(mi + \
mj)*mV4)*std::log(r)))*VFin.left()*VFout.left())/(mi4*mj2*Power2(mi - \
mj)*Power2(mi + mj)) + ((8*mF*(-DiscontinuityB(mi2,mF,mV) + \
DiscontinuityB(mj2,mF,mV)))/(mi3 - mi*mj2) - (4*mF*(mF - mV)*(mF + \
mV)*std::log(r))/(mi3*mj2))*VFin.right()*VFout.left() + ((2*mi2*mj4*(-mF2 \
+ mi2 - 2*mj2 + mV2)*DiscontinuityB(mi2,mF,mV) - 2*mi2*(mi2 - \
2*mj2)*mj2*(mF2 + mj2 - mV2)*DiscontinuityB(mj2,mF,mV) - (mi - \
mj)*(mi + mj)*(2*mi2*mj2*(mF2 + mj2 - mV2) + \
4*mF2*mi2*mj4*ScalarC0(mi2,mj2,mF,mF,mV) + (mF4*(-mi2 + mj2) + \
2*mF2*mj4 + 2*(mi - mj)*(mi + mj)*(mF2 + mj2)*mV2 + (-mi2 + \
mj2)*mV4)*std::log(r)))*VFin.right()*VFout.right())/(mi3*mj3*Power2(mi - \
mj)*Power2(mi + mj));
      }
    }
  }
}


std::complex<double> FFV_VSF_A1L(double mi, double mj, double mF, double mV, double mG, auto VFin, auto SFout)
{
  const double mi2=Power2(mi);
  const double mi3=Power3(mi);
  const double mi4=Power4(mi);
  const double mi6=Power6(mi);
  const double mj2=Power2(mj);
  const double mj3=Power3(mj);
  const double mj4=Power4(mj);
  const double mj6=Power6(mj);
  const double mF2=Power2(mF);
  const double mF4=Power4(mF);
  const double mF6=Power6(mF);
  const double mV2=Power2(mV);
  const double mV4=Power4(mV);
  const double mV6=Power6(mV);
  const double mG2=Power2(mG);
  const double mG4=Power4(mG);
  const double mG6=Power6(mG);
  const double pi2=Power2(M_PI);
  if (is_zero(-mG + mV)) {
    if (is_zero(mF)) {
      if (is_zero(mi-mj)) {
        if (is_zero(mi-mV)) {
          return (SFout.left()*VFin.left())/mi2;
        } else {
          return (mV*SFout.left()*(mi2 + (mi - mV)*(mi + \
mV)*std::log(mV2/(-mi2 + mV2)))*VFin.left())/Power5(mi);
        }
      } else {
        if (is_zero(mi-mV)) {
          return -(SFout.left()*(mi2*(-12 + pi2) + mj2*(12 + pi2) + \
6*(mi2 + mj2)*dilog(mj2/(-mi2 + mj2)) + 3*std::log(mi2/(mi2 - \
mj2))*(-4*(mi - mj)*(mi + mj) + (mi2 + mj2)*std::log(mi2/(mi2 - \
mj2))))*VFin.left())/(3.*Power2(mi2 - mj2));
        } else if (is_zero(mj-mV)) {
          return (2*mj*SFout.left()*(6*mi4 + mi2*mj2*(-6 + pi2) + \
6*mi2*mj2*dilog(mi2/(mi2 - mj2)) + 3*std::log(mj2/(-mi2 + mj2))*(mi4 - \
mj4 + mi2*mj2*std::log(mj2/(-mi2 + \
mj2))))*VFin.left())/(3.*mi3*Power2(mi2 - mj2));
        } else {
          return (2*mV*SFout.left()*(mi2*(mi - mj)*(mi + mj)*(mj2 + \
mV2)*ScalarC0(mi2,mj2,mV,mV,mF2) + (mi2 + mj2)*(mi - mV)*(mi + \
mV)*std::log(mV2/(-mi2 + mV2)) + 2*mi2*(mi2 - mj2 + (-mj2 + \
mV2)*std::log(mV2/(-mj2 + mV2))))*VFin.left())/(mi3*Power2(mi2 - mj2));
        }
      }
    } else {
    const auto r = Power2(mF/mV);
      if (std::max(mV,mF) > approx_limit * std::max(mi,mj)) {
        return -1./mj * VFin.right() * SFout.right() * OneLoopFunctionN(r,r) / mV;// / 2.;
      } else {
        if (is_zero(mi-mj)) {
          return (mV*SFout.left()*(2*mi2 + (2*mi2*(mF4 + mi4 - 2*(mF2 \
+ mi2)*mV2 + \
mV4)*DiscontinuityB(mi2,mF,mV))/KallenLambda(mF2,mi2,mV2) - (mF2 + \
mi2 - mV2)*std::log(r))*VFin.left())/(2.*Power5(mi));
        } else {
          return (mV*SFout.left()*(2*mi2*(mi2 + \
mj2)*DiscontinuityB(mi2,mF,mV) - 4*mi2*mj2*DiscontinuityB(mj2,mF,mV) \
+ (mi - mj)*(mi + mj)*(4*mi2 + 2*mi2*(-mF2 + mj2 + \
mV2)*ScalarC0(mi2,mj2,mV,mV,mF) - (-mF2 + mi2 + \
mV2)*std::log(r)))*VFin.left())/(mi3*Power2(mi - mj)*Power2(mi + mj));
        }
      }
    }
  } else {
    if (is_zero(mF)) {
      if (is_zero(mi-mj)) {
        if (is_zero(mi-mV)) {
          return (SFout.left()*(mG4*mi2 - 4*mG2*mi4 + 3*mi6 + \
Power3(-mG + mi)*Power3(mG + mi)*std::log(mG2/(mG2 - mi2)) - (-3*mG2 + \
mi2)*mi4*std::log(mG2/mi2))*VFin.left())/(3.*mi4*Power2(mG2 - mi2));
        } else if (is_zero(mG)){
          return (2*mV*SFout.left()*(-(mi4*mV2) + mi2*mV4 + \
mi6*std::log(mi2/mV2) + Power3(mi2 - mV2)*std::log(mV2/(-mi2 + \
mV2)))*VFin.left())/(3.*Power2(mi2 - mV2)*Power5(mi));
        } else {
          return (mV*SFout.left()*(mi2*(mG - mV)*(mG + mV)*(mG2 - mi2 \
- 2*mV2) - Power3(mG2 - mi2)*std::log(mG2/(mG2 - mi2)) + (3*mG2*mi4 - \
mi6)*std::log(mG2/mV2) + (3*mG2 - mi2 - 2*mV2)*Power2(mi2 - \
mV2)*std::log(mV2/(-mi2 + mV2)))*VFin.left())/(3.*Power2(mG2 - \
mV2)*Power5(mi));
        }
      } else {
        if (is_zero(mi-mV)) {
          if (is_zero(mj-mG)) {
            return (2*SFout.left()*(mi2 - mj2 - \
mj2*std::log(mi2/mj2))*VFin.left())/Power2(mi2 - mj2);
          } else {
            return (2*SFout.left()*((mG - mi)*(mG + mi)*(mG - mj)*(mG \
+ mj)*(mi2 + mj2)*ScalarC0(mi2,mj2,mG,mi,mF2) + (-2*mi2*mj2 + \
mG2*(mi2 + mj2))*std::log(mG2/mi2) + (mG - mi)*(mG + mi)*(mi2 - mj2 + \
2*(mG - mj)*(mG + mj)*std::log(mG2/(mG2 - mj2))))*VFin.left())/((mG - \
mi)*(mG + mi)*Power2(mi - mj)*Power2(mi + mj));
          }
        } else {
          if (is_zero(mj-mG)) {
            return (2*mV*SFout.left()*(2*mi2*mj2*(mi - mV)*(mj - \
mV)*(mi + mV)*(mj + mV)*ScalarC0(mi2,mj2,mj,mV,mF2) + mi2*mj2*(mi2 + \
mj2 - 2*mV2)*std::log(mj2/mV2) + (mj - mV)*(mj + mV)*(mi4 - mi2*mj2 + \
(mi2 + mj2)*(mi - mV)*(mi + mV)*std::log(mV2/(-mi2 + \
mV2))))*VFin.left())/(mi3*(mj - mV)*(mj + mV)*Power2(mi - \
mj)*Power2(mi + mj));
          } else {
            return (2*mV*SFout.left()*(mi2*(mG - mV)*(mG + \
mV)*(mG2*(mi2 + mj2) + mj2*(mi2 - mj2 - \
2*mV2))*ScalarC0(mi2,mj2,mG,mV,mF2) + mi2*((mG - mV)*(mG + mV)*(mi2 - \
mj2 + 2*(mG - mj)*(mG + mj)*std::log(mG2/(mG2 - mj2))) + (mG2*(mi2 + \
mj2) - 2*mj2*mV2)*std::log(mG2/mV2)) + (mi2 + mj2)*(mG - mV)*(mi - \
mV)*(mG + mV)*(mi + mV)*std::log(mV2/(-mi2 + \
mV2)))*VFin.left())/(mi3*(mG - mV)*(mG + mV)*Power2(mi - mj)*Power2(mi \
+ mj));
          }
        }
      }
    } else {
    const auto r = Power2(mF/mV);
    const auto s = Power2(mF/mG);
      if (std::max(std::max(mV,mG),mF) > approx_limit * ) {
        return -1./mj * VFin.right() * SFout.right() * OneLoopFunctionN(r,s) / mV;// / 2.;
      } else {
        if (is_zero(mi-mj)) {
          return (mV*SFout.left()*(2*(-mF - mG + mi)*(mF - mG + \
mi)*(-mF + mG + mi)*(mF + mG + mi)*mi2*DiscontinuityB(mi2,mF,mG) - \
2*mi2*(mF4 + mF2*(-3*mG2 - 2*mi2 + mV2) + (mi - mV)*(mi + mV)*(-3*mG2 \
+ mi2 + 2*mV2))*DiscontinuityB(mi2,mF,mV) - (-mF2 + mG2 + \
mi2)*(-2*(mF2 + 2*mG2)*mi2 + mi4 + Power2(mF2 - mG2))*std::log(mG2/mV2) \
+ (mG - mV)*(mG + mV)*(2*mi2*(mF2 + mG2 - mi2 - 2*mV2) + (mG - \
mV)*(mG + mV)*(-3*mF2 + mG2 - 3*mi2 + \
2*mV2)*std::log(r)))*VFin.left())/(6.*Power2(mG2 - mV2)*Power5(mi));
        } else {
          return (mV*SFout.left()*(-2*mi2*(mi2 + mj2)*(mG - mV)*(mG + \
mV)*DiscontinuityB(mi2,mF,mV) + 4*mi2*mj2*(mG - mV)*(mG + \
mV)*DiscontinuityB(mj2,mF,mG) - 2*mi2*(mG - mV)*(mG + mV)*(mF2*(-mi2 \
+ mj2) + mG2*(mi2 + mj2) + mj2*(mi2 - mj2 - \
2*mV2))*ScalarC0(mi2,mj2,mG,mV,mF) - 2*mi2*(mG2*(-mF2 + mG2 + mi2) - \
(-mF2 + mG2 + mj2)*mV2)*std::log(mG2/mV2) + (mG - mV)*(mG + \
mV)*(-2*mi2*(mi - mj)*(mi + mj) - (mF2*(mi - mj)*(mi + mj) + \
mi2*(-2*mG2 - mi2 + mj2) + (mi2 + \
mj2)*mV2)*std::log(r)))*VFin.left())/(mi3*(-mG2 + mV2)*Power2(mi2 - mj2));
        }
      }
    }
  }
}

std::complex<double> FFV_VSF_A1R(double mi, double mj, double mF, double mV, double mG, auto VFin, auto SFout)
{
  const double mi2=Power2(mi);
  const double mi3=Power3(mi);
  const double mi4=Power4(mi);
  const double mi6=Power6(mi);
  const double mj2=Power2(mj);
  const double mj3=Power3(mj);
  const double mj4=Power4(mj);
  const double mj6=Power6(mj);
  const double mF2=Power2(mF);
  const double mF4=Power4(mF);
  const double mF6=Power6(mF);
  const double mV2=Power2(mV);
  const double mV4=Power4(mV);
  const double mV6=Power6(mV);
  const double mG2=Power2(mG);
  const double mG4=Power4(mG);
  const double mG6=Power6(mG);
  const double pi2=Power2(M_PI);
  if (is_zero(-mG + mV)) {
    if (is_zero(mF)) {
      if (is_zero(mi-mj)) {
        if (is_zero(mi-mV)) {
          return (SFout.left()*VFin.left())/mi2;
        } else {
          return (mV*SFout.left()*(mi2 + (mi - mV)*(mi + \
mV)*std::log(mV2/(-mi2 + mV2)))*VFin.left())/Power5(mi);
        }
      } else {
        if (is_zero(mi-mV)) {
          return -(SFout.left()*(mi2*(-12 + pi2) + mj2*(12 + pi2) + \
6*(mi2 + mj2)*dilog(mj2/(-mi2 + mj2)) + 3*std::log(mi2/(mi2 - \
mj2))*(-4*(mi - mj)*(mi + mj) + (mi2 + mj2)*std::log(mi2/(mi2 - \
mj2))))*VFin.left())/(3.*Power2(mi2 - mj2));
        } else if (is_zero(mj-mV)) {
          return (2*mj*SFout.left()*(6*mi4 + mi2*mj2*(-6 + pi2) + \
6*mi2*mj2*dilog(mi2/(mi2 - mj2)) + 3*std::log(mj2/(-mi2 + mj2))*(mi4 - \
mj4 + mi2*mj2*std::log(mj2/(-mi2 + \
mj2))))*VFin.left())/(3.*mi3*Power2(mi2 - mj2));
        } else {
          return (2*mV*SFout.left()*(mi2*(mi - mj)*(mi + mj)*(mj2 + \
mV2)*ScalarC0(mi2,mj2,mV,mV,mF2) + (mi2 + mj2)*(mi - mV)*(mi + \
mV)*std::log(mV2/(-mi2 + mV2)) + 2*mi2*(mi2 - mj2 + (-mj2 + \
mV2)*std::log(mV2/(-mj2 + mV2))))*VFin.left())/(mi3*Power2(mi2 - mj2));
        }
      }
    } else {
    const auto r = Power2(mF/mV);
      if (std::max(mV,mF) > approx_limit * std::max(mi,mj)) {
        return -1./mj * VFin.left() * SFout.left() * OneLoopFunctionN(r,r) / mV;// / 2.;
      } else {
        if (is_zero(mi-mj)) {
          return (mV*SFout.left()*(2*mi2 + (2*mi2*(mF4 + mi4 - 2*(mF2 \
+ mi2)*mV2 + \
mV4)*DiscontinuityB(mi2,mF,mV))/KallenLambda(mF2,mi2,mV2) - (mF2 + \
mi2 - mV2)*std::log(r))*VFin.left())/(2.*Power5(mi));
        } else {
          return (mV*SFout.left()*(2*mi2*(mi2 + \
mj2)*DiscontinuityB(mi2,mF,mV) - 4*mi2*mj2*DiscontinuityB(mj2,mF,mV) \
+ (mi - mj)*(mi + mj)*(4*mi2 + 2*mi2*(-mF2 + mj2 + \
mV2)*ScalarC0(mi2,mj2,mV,mV,mF) - (-mF2 + mi2 + \
mV2)*std::log(r)))*VFin.left())/(mi3*Power2(mi - mj)*Power2(mi + mj));
        }
      }
    }
  } else {
    if (is_zero(mF)) {
      if (is_zero(mi-mj)) {
        if (is_zero(mi-mV)) {
          return (SFout.left()*(mG4*mi2 - 4*mG2*mi4 + 3*mi6 + \
Power3(-mG + mi)*Power3(mG + mi)*std::log(mG2/(mG2 - mi2)) - (-3*mG2 + \
mi2)*mi4*std::log(mG2/mi2))*VFin.left())/(3.*mi4*Power2(mG2 - mi2));
        } else if (is_zero(mG)){
          return (2*mV*SFout.left()*(-(mi4*mV2) + mi2*mV4 + \
mi6*std::log(mi2/mV2) + Power3(mi2 - mV2)*std::log(mV2/(-mi2 + \
mV2)))*VFin.left())/(3.*Power2(mi2 - mV2)*Power5(mi));
        } else {
          return (mV*SFout.left()*(mi2*(mG - mV)*(mG + mV)*(mG2 - mi2 \
- 2*mV2) - Power3(mG2 - mi2)*std::log(mG2/(mG2 - mi2)) + (3*mG2*mi4 - \
mi6)*std::log(mG2/mV2) + (3*mG2 - mi2 - 2*mV2)*Power2(mi2 - \
mV2)*std::log(mV2/(-mi2 + mV2)))*VFin.left())/(3.*Power2(mG2 - \
mV2)*Power5(mi));
        }
      } else {
        if (is_zero(mi-mV)) {
          if (is_zero(mj-mG)) {
            return (2*SFout.left()*(mi2 - mj2 - \
mj2*std::log(mi2/mj2))*VFin.left())/Power2(mi2 - mj2);
          } else {
            return (2*SFout.left()*((mG - mi)*(mG + mi)*(mG - mj)*(mG \
+ mj)*(mi2 + mj2)*ScalarC0(mi2,mj2,mG,mi,mF2) + (-2*mi2*mj2 + \
mG2*(mi2 + mj2))*std::log(mG2/mi2) + (mG - mi)*(mG + mi)*(mi2 - mj2 + \
2*(mG - mj)*(mG + mj)*std::log(mG2/(mG2 - mj2))))*VFin.left())/((mG - \
mi)*(mG + mi)*Power2(mi - mj)*Power2(mi + mj));
          }
        } else {
          if (is_zero(mj-mG)) {
            return (2*mV*SFout.left()*(2*mi2*mj2*(mi - mV)*(mj - \
mV)*(mi + mV)*(mj + mV)*ScalarC0(mi2,mj2,mj,mV,mF2) + mi2*mj2*(mi2 + \
mj2 - 2*mV2)*std::log(mj2/mV2) + (mj - mV)*(mj + mV)*(mi4 - mi2*mj2 + \
(mi2 + mj2)*(mi - mV)*(mi + mV)*std::log(mV2/(-mi2 + \
mV2))))*VFin.left())/(mi3*(mj - mV)*(mj + mV)*Power2(mi - \
mj)*Power2(mi + mj));
          } else {
            return (2*mV*SFout.left()*(mi2*(mG - mV)*(mG + \
mV)*(mG2*(mi2 + mj2) + mj2*(mi2 - mj2 - \
2*mV2))*ScalarC0(mi2,mj2,mG,mV,mF2) + mi2*((mG - mV)*(mG + mV)*(mi2 - \
mj2 + 2*(mG - mj)*(mG + mj)*std::log(mG2/(mG2 - mj2))) + (mG2*(mi2 + \
mj2) - 2*mj2*mV2)*std::log(mG2/mV2)) + (mi2 + mj2)*(mG - mV)*(mi - \
mV)*(mG + mV)*(mi + mV)*std::log(mV2/(-mi2 + \
mV2)))*VFin.left())/(mi3*(mG - mV)*(mG + mV)*Power2(mi - mj)*Power2(mi \
+ mj));
          }
        }
      }
    } else {
    const auto r = Power2(mF/mV);
    const auto s = Power2(mF/mG);
      if (std::max(std::max(mV,mG),mF) > approx_limit * std::max(mi,mj)) {
        return -1./mj * VFin.left() * SFout.left() * OneLoopFunctionN(r,s) / mV;// / 2.;
      } else {
        if (is_zero(mi-mj)) {
          return (mV*SFout.left()*(2*(-mF - mG + mi)*(mF - mG + \
mi)*(-mF + mG + mi)*(mF + mG + mi)*mi2*DiscontinuityB(mi2,mF,mG) - \
2*mi2*(mF4 + mF2*(-3*mG2 - 2*mi2 + mV2) + (mi - mV)*(mi + mV)*(-3*mG2 \
+ mi2 + 2*mV2))*DiscontinuityB(mi2,mF,mV) - (-mF2 + mG2 + \
mi2)*(-2*(mF2 + 2*mG2)*mi2 + mi4 + Power2(mF2 - mG2))*std::log(mG2/mV2) \
+ (mG - mV)*(mG + mV)*(2*mi2*(mF2 + mG2 - mi2 - 2*mV2) + (mG - \
mV)*(mG + mV)*(-3*mF2 + mG2 - 3*mi2 + \
2*mV2)*std::log(r)))*VFin.left())/(6.*Power2(mG2 - mV2)*Power5(mi));
        } else {
          return (mV*SFout.left()*(-2*mi2*(mi2 + mj2)*(mG - mV)*(mG + \
mV)*DiscontinuityB(mi2,mF,mV) + 4*mi2*mj2*(mG - mV)*(mG + \
mV)*DiscontinuityB(mj2,mF,mG) - 2*mi2*(mG - mV)*(mG + mV)*(mF2*(-mi2 \
+ mj2) + mG2*(mi2 + mj2) + mj2*(mi2 - mj2 - \
2*mV2))*ScalarC0(mi2,mj2,mG,mV,mF) - 2*mi2*(mG2*(-mF2 + mG2 + mi2) - \
(-mF2 + mG2 + mj2)*mV2)*std::log(mG2/mV2) + (mG - mV)*(mG + \
mV)*(-2*mi2*(mi - mj)*(mi + mj) - (mF2*(mi - mj)*(mi + mj) + \
mi2*(-2*mG2 - mi2 + mj2) + (mi2 + \
mj2)*mV2)*std::log(r)))*VFin.left())/(mi3*(-mG2 + mV2)*Power2(mi2 - mj2));
        }
      }
    }
  }        
} 

std::complex<double> FFV_VSF_A2L(double mi, double mj, double mF, double mV, double mG, auto VFin, auto SFout)
{
  const double mi2=Power2(mi);
  const double mi3=Power3(mi);
  const double mi4=Power4(mi);
  const double mi6=Power6(mi);
  const double mj2=Power2(mj);
  const double mj3=Power3(mj);
  const double mj4=Power4(mj);
  const double mj6=Power6(mj);
  const double mF2=Power2(mF);
  const double mF4=Power4(mF);
  const double mF6=Power6(mF);
  const double mV2=Power2(mV);
  const double mV4=Power4(mV);
  const double mV6=Power6(mV);
  const double mG2=Power2(mG);
  const double mG4=Power4(mG);
  const double mG6=Power6(mG);
  const double pi2=Power2(M_PI);
  if (is_zero(-mG + mV)) {
    if (is_zero(mF)) {
      if (is_zero(mi-mj)) {
        if (is_zero(mi-mV)) {
          return (SFout.left()*VFin.left())/mi2;
        } else {
          return (mV*SFout.left()*(mi2 + (mi - mV)*(mi + \
mV)*std::log(mV2/(-mi2 + mV2)))*VFin.left())/Power5(mi);
        }
      } else {
        if (is_zero(mi-mV)) {
          return -(SFout.left()*(mi2*(-12 + pi2) + mj2*(12 + pi2) + \
6*(mi2 + mj2)*dilog(mj2/(-mi2 + mj2)) + 3*std::log(mi2/(mi2 - \
mj2))*(-4*(mi - mj)*(mi + mj) + (mi2 + mj2)*std::log(mi2/(mi2 - \
mj2))))*VFin.left())/(3.*Power2(mi2 - mj2));
        } else if (is_zero(mj-mV)) {
          return (2*mj*SFout.left()*(6*mi4 + mi2*mj2*(-6 + pi2) + \
6*mi2*mj2*dilog(mi2/(mi2 - mj2)) + 3*std::log(mj2/(-mi2 + mj2))*(mi4 - \
mj4 + mi2*mj2*std::log(mj2/(-mi2 + \
mj2))))*VFin.left())/(3.*mi3*Power2(mi2 - mj2));
        } else {
          return (2*mV*SFout.left()*(mi2*(mi - mj)*(mi + mj)*(mj2 + \
mV2)*ScalarC0(mi2,mj2,mV,mV,mF2) + (mi2 + mj2)*(mi - mV)*(mi + \
mV)*std::log(mV2/(-mi2 + mV2)) + 2*mi2*(mi2 - mj2 + (-mj2 + \
mV2)*std::log(mV2/(-mj2 + mV2))))*VFin.left())/(mi3*Power2(mi2 - mj2));
        }
      }
    } else {
    const auto r = Power2(mF/mV);
      if (std::max(mV,mF) > approx_limit * std::max(mi,mj)) {
        return  1./mj * VFin.left() * SFout.left() * OneLoopFunctionN(r,r) / mV;// / 2.;
      } else {
        if (is_zero(mi-mj)) {
          return (mV*SFout.left()*(2*mi2 + (2*mi2*(mF4 + mi4 - 2*(mF2 \
+ mi2)*mV2 + \
mV4)*DiscontinuityB(mi2,mF,mV))/KallenLambda(mF2,mi2,mV2) - (mF2 + \
mi2 - mV2)*std::log(r))*VFin.left())/(2.*Power5(mi));
        } else {
          return (mV*SFout.left()*(2*mi2*(mi2 + \
mj2)*DiscontinuityB(mi2,mF,mV) - 4*mi2*mj2*DiscontinuityB(mj2,mF,mV) \
+ (mi - mj)*(mi + mj)*(4*mi2 + 2*mi2*(-mF2 + mj2 + \
mV2)*ScalarC0(mi2,mj2,mV,mV,mF) - (-mF2 + mi2 + \
mV2)*std::log(r)))*VFin.left())/(mi3*Power2(mi - mj)*Power2(mi + mj));
        }
      }
    }
  } else {
    if (is_zero(mF)) {
      if (is_zero(mi-mj)) {
        if (is_zero(mi-mV)) {
          return (SFout.left()*(mG4*mi2 - 4*mG2*mi4 + 3*mi6 + \
Power3(-mG + mi)*Power3(mG + mi)*std::log(mG2/(mG2 - mi2)) - (-3*mG2 + \
mi2)*mi4*std::log(mG2/mi2))*VFin.left())/(3.*mi4*Power2(mG2 - mi2));
        } else if (is_zero(mG)){
          return (2*mV*SFout.left()*(-(mi4*mV2) + mi2*mV4 + \
mi6*std::log(mi2/mV2) + Power3(mi2 - mV2)*std::log(mV2/(-mi2 + \
mV2)))*VFin.left())/(3.*Power2(mi2 - mV2)*Power5(mi));
        } else {
          return (mV*SFout.left()*(mi2*(mG - mV)*(mG + mV)*(mG2 - mi2 \
- 2*mV2) - Power3(mG2 - mi2)*std::log(mG2/(mG2 - mi2)) + (3*mG2*mi4 - \
mi6)*std::log(mG2/mV2) + (3*mG2 - mi2 - 2*mV2)*Power2(mi2 - \
mV2)*std::log(mV2/(-mi2 + mV2)))*VFin.left())/(3.*Power2(mG2 - \
mV2)*Power5(mi));
        }
      } else {
        if (is_zero(mi-mV)) {
          if (is_zero(mj-mG)) {
            return (2*SFout.left()*(mi2 - mj2 - \
mj2*std::log(mi2/mj2))*VFin.left())/Power2(mi2 - mj2);
          } else {
            return (2*SFout.left()*((mG - mi)*(mG + mi)*(mG - mj)*(mG \
+ mj)*(mi2 + mj2)*ScalarC0(mi2,mj2,mG,mi,mF2) + (-2*mi2*mj2 + \
mG2*(mi2 + mj2))*std::log(mG2/mi2) + (mG - mi)*(mG + mi)*(mi2 - mj2 + \
2*(mG - mj)*(mG + mj)*std::log(mG2/(mG2 - mj2))))*VFin.left())/((mG - \
mi)*(mG + mi)*Power2(mi - mj)*Power2(mi + mj));
          }
        } else {
          if (is_zero(mj-mG)) {
            return (2*mV*SFout.left()*(2*mi2*mj2*(mi - mV)*(mj - \
mV)*(mi + mV)*(mj + mV)*ScalarC0(mi2,mj2,mj,mV,mF2) + mi2*mj2*(mi2 + \
mj2 - 2*mV2)*std::log(mj2/mV2) + (mj - mV)*(mj + mV)*(mi4 - mi2*mj2 + \
(mi2 + mj2)*(mi - mV)*(mi + mV)*std::log(mV2/(-mi2 + \
mV2))))*VFin.left())/(mi3*(mj - mV)*(mj + mV)*Power2(mi - \
mj)*Power2(mi + mj));
          } else {
            return (2*mV*SFout.left()*(mi2*(mG - mV)*(mG + \
mV)*(mG2*(mi2 + mj2) + mj2*(mi2 - mj2 - \
2*mV2))*ScalarC0(mi2,mj2,mG,mV,mF2) + mi2*((mG - mV)*(mG + mV)*(mi2 - \
mj2 + 2*(mG - mj)*(mG + mj)*std::log(mG2/(mG2 - mj2))) + (mG2*(mi2 + \
mj2) - 2*mj2*mV2)*std::log(mG2/mV2)) + (mi2 + mj2)*(mG - mV)*(mi - \
mV)*(mG + mV)*(mi + mV)*std::log(mV2/(-mi2 + \
mV2)))*VFin.left())/(mi3*(mG - mV)*(mG + mV)*Power2(mi - mj)*Power2(mi \
+ mj));
          }
        }
      }
    } else {
    const auto r = Power2(mF/mV);
    const auto s = Power2(mF/mG);
      if (std::max(std::max(mV,mG),mF) > approx_limit * std::max(mi,mj)) {
        return  1./mj * VFin.left() * SFout.left() * OneLoopFunctionN(r,s) / mV;// / 2.;
      } else {
        if (is_zero(mi-mj)) {
          return (mV*SFout.left()*(2*(-mF - mG + mi)*(mF - mG + \
mi)*(-mF + mG + mi)*(mF + mG + mi)*mi2*DiscontinuityB(mi2,mF,mG) - \
2*mi2*(mF4 + mF2*(-3*mG2 - 2*mi2 + mV2) + (mi - mV)*(mi + mV)*(-3*mG2 \
+ mi2 + 2*mV2))*DiscontinuityB(mi2,mF,mV) - (-mF2 + mG2 + \
mi2)*(-2*(mF2 + 2*mG2)*mi2 + mi4 + Power2(mF2 - mG2))*std::log(mG2/mV2) \
+ (mG - mV)*(mG + mV)*(2*mi2*(mF2 + mG2 - mi2 - 2*mV2) + (mG - \
mV)*(mG + mV)*(-3*mF2 + mG2 - 3*mi2 + \
2*mV2)*std::log(r)))*VFin.left())/(6.*Power2(mG2 - mV2)*Power5(mi));
        } else {
          return (mV*SFout.left()*(-2*mi2*(mi2 + mj2)*(mG - mV)*(mG + \
mV)*DiscontinuityB(mi2,mF,mV) + 4*mi2*mj2*(mG - mV)*(mG + \
mV)*DiscontinuityB(mj2,mF,mG) - 2*mi2*(mG - mV)*(mG + mV)*(mF2*(-mi2 \
+ mj2) + mG2*(mi2 + mj2) + mj2*(mi2 - mj2 - \
2*mV2))*ScalarC0(mi2,mj2,mG,mV,mF) - 2*mi2*(mG2*(-mF2 + mG2 + mi2) - \
(-mF2 + mG2 + mj2)*mV2)*std::log(mG2/mV2) + (mG - mV)*(mG + \
mV)*(-2*mi2*(mi - mj)*(mi + mj) - (mF2*(mi - mj)*(mi + mj) + \
mi2*(-2*mG2 - mi2 + mj2) + (mi2 + \
mj2)*mV2)*std::log(r)))*VFin.left())/(mi3*(-mG2 + mV2)*Power2(mi2 - mj2));
        }
      }
    }
  }        
}

std::complex<double> FFV_VSF_A2R(double mi, double mj, double mF, double mV, double mG, auto VFin, auto SFout)
{
  const double mi2=Power2(mi);
  const double mi3=Power3(mi);
  const double mi4=Power4(mi);
  const double mi6=Power6(mi);
  const double mj2=Power2(mj);
  const double mj3=Power3(mj);
  const double mj4=Power4(mj);
  const double mj6=Power6(mj);
  const double mF2=Power2(mF);
  const double mF4=Power4(mF);
  const double mF6=Power6(mF);
  const double mV2=Power2(mV);
  const double mV4=Power4(mV);
  const double mV6=Power6(mV);
  const double mG2=Power2(mG);
  const double mG4=Power4(mG);
  const double mG6=Power6(mG);
  const double pi2=Power2(M_PI);
  if (is_zero(-mG + mV)) {
    if (is_zero(mF)) {
      if (is_zero(mi-mj)) {
        if (is_zero(mi-mV)) {
          return (SFout.left()*VFin.left())/mi2;
        } else {
          return (mV*SFout.left()*(mi2 + (mi - mV)*(mi + \
mV)*std::log(mV2/(-mi2 + mV2)))*VFin.left())/Power5(mi);
        }
      } else {
        if (is_zero(mi-mV)) {
          return -(SFout.left()*(mi2*(-12 + pi2) + mj2*(12 + pi2) + \
6*(mi2 + mj2)*dilog(mj2/(-mi2 + mj2)) + 3*std::log(mi2/(mi2 - \
mj2))*(-4*(mi - mj)*(mi + mj) + (mi2 + mj2)*std::log(mi2/(mi2 - \
mj2))))*VFin.left())/(3.*Power2(mi2 - mj2));
        } else if (is_zero(mj-mV)) {
          return (2*mj*SFout.left()*(6*mi4 + mi2*mj2*(-6 + pi2) + \
6*mi2*mj2*dilog(mi2/(mi2 - mj2)) + 3*std::log(mj2/(-mi2 + mj2))*(mi4 - \
mj4 + mi2*mj2*std::log(mj2/(-mi2 + \
mj2))))*VFin.left())/(3.*mi3*Power2(mi2 - mj2));
        } else {
          return (2*mV*SFout.left()*(mi2*(mi - mj)*(mi + mj)*(mj2 + \
mV2)*ScalarC0(mi2,mj2,mV,mV,mF2) + (mi2 + mj2)*(mi - mV)*(mi + \
mV)*std::log(mV2/(-mi2 + mV2)) + 2*mi2*(mi2 - mj2 + (-mj2 + \
mV2)*std::log(mV2/(-mj2 + mV2))))*VFin.left())/(mi3*Power2(mi2 - mj2));
        }
      }
    } else {
    const auto r = Power2(mF/mV);
      if (std::max(mV,mF) > approx_limit * std::max(mi,mj)) {
        return 1./mj * VFin.right() * SFout.right() * OneLoopFunctionN(r,r) / mV;// / 2.;
      } else {
        if (is_zero(mi-mj)) {
          return (mV*SFout.left()*(2*mi2 + (2*mi2*(mF4 + mi4 - 2*(mF2 \
+ mi2)*mV2 + \
mV4)*DiscontinuityB(mi2,mF,mV))/KallenLambda(mF2,mi2,mV2) - (mF2 + \
mi2 - mV2)*std::log(r))*VFin.left())/(2.*Power5(mi));
        } else {
          return (mV*SFout.left()*(2*mi2*(mi2 + \
mj2)*DiscontinuityB(mi2,mF,mV) - 4*mi2*mj2*DiscontinuityB(mj2,mF,mV) \
+ (mi - mj)*(mi + mj)*(4*mi2 + 2*mi2*(-mF2 + mj2 + \
mV2)*ScalarC0(mi2,mj2,mV,mV,mF) - (-mF2 + mi2 + \
mV2)*std::log(r)))*VFin.left())/(mi3*Power2(mi - mj)*Power2(mi + mj));
        }
      }
    }
  } else {
    if (is_zero(mF)) {
      if (is_zero(mi-mj)) {
        if (is_zero(mi-mV)) {
          return (SFout.left()*(mG4*mi2 - 4*mG2*mi4 + 3*mi6 + \
Power3(-mG + mi)*Power3(mG + mi)*std::log(mG2/(mG2 - mi2)) - (-3*mG2 + \
mi2)*mi4*std::log(mG2/mi2))*VFin.left())/(3.*mi4*Power2(mG2 - mi2));
        } else if (is_zero(mG)){
          return (2*mV*SFout.left()*(-(mi4*mV2) + mi2*mV4 + \
mi6*std::log(mi2/mV2) + Power3(mi2 - mV2)*std::log(mV2/(-mi2 + \
mV2)))*VFin.left())/(3.*Power2(mi2 - mV2)*Power5(mi));
        } else {
          return (mV*SFout.left()*(mi2*(mG - mV)*(mG + mV)*(mG2 - mi2 \
- 2*mV2) - Power3(mG2 - mi2)*std::log(mG2/(mG2 - mi2)) + (3*mG2*mi4 - \
mi6)*std::log(mG2/mV2) + (3*mG2 - mi2 - 2*mV2)*Power2(mi2 - \
mV2)*std::log(mV2/(-mi2 + mV2)))*VFin.left())/(3.*Power2(mG2 - \
mV2)*Power5(mi));
        }
      } else {
        if (is_zero(mi-mV)) {
          if (is_zero(mj-mG)) {
            return (2*SFout.left()*(mi2 - mj2 - \
mj2*std::log(mi2/mj2))*VFin.left())/Power2(mi2 - mj2);
          } else {
            return (2*SFout.left()*((mG - mi)*(mG + mi)*(mG - mj)*(mG \
+ mj)*(mi2 + mj2)*ScalarC0(mi2,mj2,mG,mi,mF2) + (-2*mi2*mj2 + \
mG2*(mi2 + mj2))*std::log(mG2/mi2) + (mG - mi)*(mG + mi)*(mi2 - mj2 + \
2*(mG - mj)*(mG + mj)*std::log(mG2/(mG2 - mj2))))*VFin.left())/((mG - \
mi)*(mG + mi)*Power2(mi - mj)*Power2(mi + mj));
          }
        } else {
          if (is_zero(mj-mG)) {
            return (2*mV*SFout.left()*(2*mi2*mj2*(mi - mV)*(mj - \
mV)*(mi + mV)*(mj + mV)*ScalarC0(mi2,mj2,mj,mV,mF2) + mi2*mj2*(mi2 + \
mj2 - 2*mV2)*std::log(mj2/mV2) + (mj - mV)*(mj + mV)*(mi4 - mi2*mj2 + \
(mi2 + mj2)*(mi - mV)*(mi + mV)*std::log(mV2/(-mi2 + \
mV2))))*VFin.left())/(mi3*(mj - mV)*(mj + mV)*Power2(mi - \
mj)*Power2(mi + mj));
          } else {
            return (2*mV*SFout.left()*(mi2*(mG - mV)*(mG + \
mV)*(mG2*(mi2 + mj2) + mj2*(mi2 - mj2 - \
2*mV2))*ScalarC0(mi2,mj2,mG,mV,mF2) + mi2*((mG - mV)*(mG + mV)*(mi2 - \
mj2 + 2*(mG - mj)*(mG + mj)*std::log(mG2/(mG2 - mj2))) + (mG2*(mi2 + \
mj2) - 2*mj2*mV2)*std::log(mG2/mV2)) + (mi2 + mj2)*(mG - mV)*(mi - \
mV)*(mG + mV)*(mi + mV)*std::log(mV2/(-mi2 + \
mV2)))*VFin.left())/(mi3*(mG - mV)*(mG + mV)*Power2(mi - mj)*Power2(mi \
+ mj));
          }
        }
      }
    } else {
    const auto r = Power2(mF/mV);
    const auto s = Power2(mF/mG);
      if (std::max(std::max(mV,mG),mF) > approx_limit * std::max(mi,mj)) {
        return 1./mj * VFin.right() * SFout.right() * OneLoopFunctionN(r,s) / mV;// / 2.;
      } else {
        if (is_zero(mi-mj)) {
          return (mV*SFout.left()*(2*(-mF - mG + mi)*(mF - mG + \
mi)*(-mF + mG + mi)*(mF + mG + mi)*mi2*DiscontinuityB(mi2,mF,mG) - \
2*mi2*(mF4 + mF2*(-3*mG2 - 2*mi2 + mV2) + (mi - mV)*(mi + mV)*(-3*mG2 \
+ mi2 + 2*mV2))*DiscontinuityB(mi2,mF,mV) - (-mF2 + mG2 + \
mi2)*(-2*(mF2 + 2*mG2)*mi2 + mi4 + Power2(mF2 - mG2))*std::log(mG2/mV2) \
+ (mG - mV)*(mG + mV)*(2*mi2*(mF2 + mG2 - mi2 - 2*mV2) + (mG - \
mV)*(mG + mV)*(-3*mF2 + mG2 - 3*mi2 + \
2*mV2)*std::log(r)))*VFin.left())/(6.*Power2(mG2 - mV2)*Power5(mi));
        } else {
          return (mV*SFout.left()*(-2*mi2*(mi2 + mj2)*(mG - mV)*(mG + \
mV)*DiscontinuityB(mi2,mF,mV) + 4*mi2*mj2*(mG - mV)*(mG + \
mV)*DiscontinuityB(mj2,mF,mG) - 2*mi2*(mG - mV)*(mG + mV)*(mF2*(-mi2 \
+ mj2) + mG2*(mi2 + mj2) + mj2*(mi2 - mj2 - \
2*mV2))*ScalarC0(mi2,mj2,mG,mV,mF) - 2*mi2*(mG2*(-mF2 + mG2 + mi2) - \
(-mF2 + mG2 + mj2)*mV2)*std::log(mG2/mV2) + (mG - mV)*(mG + \
mV)*(-2*mi2*(mi - mj)*(mi + mj) - (mF2*(mi - mj)*(mi + mj) + \
mi2*(-2*mG2 - mi2 + mj2) + (mi2 + \
mj2)*mV2)*std::log(r)))*VFin.left())/(mi3*(-mG2 + mV2)*Power2(mi2 - mj2));
        }
      }
    }
  }
}


std::complex<double> FFV_SVF_A1L(double mi, double mj, double mF, double mV, double mG, auto SFin, auto VFout)
{
  const double mi2=Power2(mi);
  const double mi3=Power3(mi);
  const double mi4=Power4(mi);
  const double mi6=Power6(mi);
  const double mj2=Power2(mj);
  const double mj3=Power3(mj);
  const double mj4=Power4(mj);
  const double mj6=Power6(mj);
  const double mF2=Power2(mF);
  const double mF4=Power4(mF);
  const double mF6=Power6(mF);
  const double mV2=Power2(mV);
  const double mV4=Power4(mV);
  const double mV6=Power6(mV);
  const double mG2=Power2(mG);
  const double mG4=Power4(mG);
  const double mG6=Power6(mG);
  const double pi2=Power2(M_PI);
  if (is_zero(-mG + mV)) {
    if (is_zero(mF)) {
      if (is_zero(mi-mj)) {
        if (is_zero(mi-mV)) {
          return (SFin.left()*VFout.right())/mi2;
        } else {
          return (mV*SFin.left()*(mi2 + (mi - mV)*(mi + \
mV)*std::log(mV2/(-mi2 + mV2)))*VFout.right())/Power5(mi);
        }
      } else {
        if (is_zero(mi-mV)) {
          return (2*SFin.left()*(6*mj4 + mi2*mj2*(-6 + pi2) + \
6*mi2*mj2*dilog(mj2/(-mi2 + mj2)) + 3*std::log(mi2/(mi2 - mj2))*(-mi4 + \
mj4 + mi2*mj2*std::log(mi2/(mi2 - \
mj2))))*VFout.right())/(3.*Power2(-(mi2*mj) + mj3));
        } else if (is_zero(mj-mV)) {
          return (mj*SFin.left()*(-(mj2*(-12 + pi2)) - mi2*(12 + pi2) \
- 6*(mi2 + mj2)*dilog(mi2/(mi2 - mj2)) + 3*std::log(mj2/(-mi2 + \
mj2))*(-4*(mi - mj)*(mi + mj) - (mi2 + mj2)*std::log(mj2/(-mi2 + \
mj2))))*VFout.right())/(3.*mi*Power2(mi2 - mj2));
        } else {
          return (2*mV*SFin.left()*((-mi + mj)*(mi + mj)*mj2*(mi2 + \
mV2)*ScalarC0(mi2,mj2,mV,mV,mF2) + 2*mj2*(-mi2 + mj2 + (-mi2 + \
mV2)*std::log(mV2/(-mi2 + mV2))) + (mi2 + mj2)*(mj - mV)*(mj + \
mV)*std::log(mV2/(-mj2 + mV2)))*VFout.right())/(mi*mj2*Power2(mi2 - mj2));
        }
      }
    } else {
    const auto r = Power2(mF/mV);
      if (std::max(mV,mF) > approx_limit * std::max(mi,mj)) {
        return 1./mj * SFin.right() * VFout.left() * OneLoopFunctionN(r,r) / mV;// / 2.;
      } else {
        if (is_zero(mi-mj)) {
          return (mV*SFin.left()*(2*mi2 + (2*mi2*(mF4 + mi4 - 2*(mF2 + \
mi2)*mV2 + mV4)*DiscontinuityB(mi2,mF,mV))/KallenLambda(mF2,mi2,mV2) \
- (mF2 + mi2 - mV2)*std::log(r))*VFout.right())/(2.*Power5(mi));
        } else {
          return (mV*SFin.left()*(-4*mi2*mj2*DiscontinuityB(mi2,mF,mV) \
+ 2*mj2*(mi2 + mj2)*DiscontinuityB(mj2,mF,mV) + (mi - mj)*(mi + \
mj)*(-4*mj2 + 2*mj2*(mF2 - mi2 - mV2)*ScalarC0(mi2,mj2,mV,mV,mF) + \
(-mF2 + mj2 + mV2)*std::log(r)))*VFout.right())/(mi*mj2*Power2(mi - \
mj)*Power2(mi + mj));
        }
      }
    }
  } else {
    if (is_zero(mF)) {
      if (is_zero(mi-mj)) {
        if (is_zero(mi-mV)) {
          return (SFin.left()*(mG4*mi2 - 4*mG2*mi4 + 3*mi6 + \
Power3(-mG + mi)*Power3(mG + mi)*std::log(mG2/(mG2 - mi2)) - (-3*mG2 + \
mi2)*mi4*std::log(mG2/mi2))*VFout.right())/(3.*mi4*Power2(mG2 - mi2));
        } else if (is_zero(mG)){
          return (2*mV*SFin.left()*(-(mi4*mV2) + mi2*mV4 + \
mi6*std::log(mi2/mV2) + Power3(mi2 - mV2)*std::log(mV2/(-mi2 + \
mV2)))*VFout.right())/(3.*Power2(mi2 - mV2)*Power5(mi));
        } else {
          return (mV*SFin.left()*(mi2*(mG - mV)*(mG + mV)*(mG2 - mi2 - \
2*mV2) - Power3(mG2 - mi2)*std::log(mG2/(mG2 - mi2)) + (3*mG2*mi4 - \
mi6)*std::log(mG2/mV2) + (3*mG2 - mi2 - 2*mV2)*Power2(mi2 - \
mV2)*std::log(mV2/(-mi2 + mV2)))*VFout.right())/(3.*Power2(mG2 - \
mV2)*Power5(mi));
        }
      } else {
        if (is_zero(mi-mG)) {
          if (is_zero(mj-mV)) {
            return (2*mj*SFin.left()*(-mi2 + mj2 + \
mi2*std::log(mi2/mj2))*VFout.right())/(mi*Power2(mi2 - mj2));
          } else {
            return (2*mV*SFin.left()*(-mi2 + mj2 + 2*mi2*(mj - mV)*(mj \
+ mV)*ScalarC0(mi2,mj2,mV,mi,mF2) + (mi2*(mi2 + mj2 - \
2*mV2)*std::log(mi2/mV2))/(mi2 - mV2) + ((mi2 + mj2)*(mj - mV)*(mj + \
mV)*std::log(mV2/(-mj2 + mV2)))/mj2)*VFout.right())/(mi*Power2(mi - \
mj)*Power2(mi + mj));
          }
        } else {
          if (is_zero(mj-mV)) {
            return (2*mj*SFin.left()*(-((mG - mi)*(mG + mi)*(mG - \
mj)*(mG + mj)*(mi2 + mj2)*ScalarC0(mi2,mj2,mj,mG,mF2)) + (mG - \
mj)*(mG + mj)*((mi - mj)*(mi + mj) + 2*(-mG + mi)*(mG + \
mi)*std::log(mG2/(mG2 - mi2))) - (-2*mi2*mj2 + mG2*(mi2 + \
mj2))*std::log(mG2/mj2))*VFout.right())/(mi*(-mG2 + mj2)*Power2(mi2 - \
mj2));
          } else {
            return (2*mV*SFin.left()*(mj2*(mG - mV)*(mG + \
mV)*(mG2*(mi2 + mj2) + mi2*(-mi2 + mj2 - \
2*mV2))*ScalarC0(mi2,mj2,mV,mG,mF2) + mj2*((mG - mV)*(mG + mV)*(-mi2 \
+ mj2 + 2*(mG - mi)*(mG + mi)*std::log(mG2/(mG2 - mi2))) + (mG2*(mi2 + \
mj2) - 2*mi2*mV2)*std::log(mG2/mV2)) + (mi2 + mj2)*(mG - mV)*(mj - \
mV)*(mG + mV)*(mj + mV)*std::log(mV2/(-mj2 + \
mV2)))*VFout.right())/(mi*mj2*(mG - mV)*(mG + mV)*Power2(mi - \
mj)*Power2(mi + mj));
          }
        }
      }
    } else {
    const auto r = Power2(mF/mV);
    const auto s = Power2(mF/mG);
      if (std::max(std::max(mV,mG),mF) > approx_limit * std::max(mi,mj)) {
        return 1./mj * SFin.right() * VFout.left() * OneLoopFunctionN(r,s) / mV;// / 2.;
      } else {
        if (is_zero(mi-mj)) {
          return (mV*SFin.left()*(2*(-mF - mG + mi)*(mF - mG + \
mi)*(-mF + mG + mi)*(mF + mG + mi)*mi2*DiscontinuityB(mi2,mF,mG) - \
2*mi2*(mF4 + mF2*(-3*mG2 - 2*mi2 + mV2) + (mi - mV)*(mi + mV)*(-3*mG2 \
+ mi2 + 2*mV2))*DiscontinuityB(mi2,mF,mV) - (-mF2 + mG2 + \
mi2)*(-2*(mF2 + 2*mG2)*mi2 + mi4 + Power2(mF2 - mG2))*std::log(mG2/mV2) \
+ (mG - mV)*(mG + mV)*(2*mi2*(mF2 + mG2 - mi2 - 2*mV2) + (mG - \
mV)*(mG + mV)*(-3*mF2 + mG2 - 3*mi2 + \
2*mV2)*std::log(r)))*VFout.right())/(6.*Power2(mG2 - mV2)*Power5(mi));
        } else {
          return (mV*SFin.left()*(2*(mi - mj)*(mi + mj)*mj2*(mG - \
mV)*(mG + mV) + 4*mi2*mj2*(mG - mV)*(mG + \
mV)*DiscontinuityB(mi2,mF,mG) - 2*mj2*(mi2 + mj2)*(mG - mV)*(mG + \
mV)*DiscontinuityB(mj2,mF,mV) - 2*mj2*(mG - mV)*(mG + mV)*(mF2*(mi - \
mj)*(mi + mj) + mG2*(mi2 + mj2) + mi2*(-mi2 + mj2 - \
2*mV2))*ScalarC0(mi2,mj2,mV,mG,mF) + 2*(mi - mj)*(mi + \
mj)*mj2*mV2*std::log(mG2/mV2) + mF2*mG2*mi2*std::log(r) + \
mF2*mG2*mj2*std::log(r) - mG2*mi2*mj2*std::log(r) - mG2*mj4*std::log(r) - \
mF2*mi2*mV2*std::log(r) - mG2*mi2*mV2*std::log(r) - mF2*mj2*mV2*std::log(r) \
- mG2*mj2*mV2*std::log(r) + mi2*mj2*mV2*std::log(r) + mj4*mV2*std::log(r) + \
mi2*mV4*std::log(r) + mj2*mV4*std::log(r) - 2*mF2*mG2*mj2*std::log(s) + \
2*mG4*mj2*std::log(s) + 2*mG2*mj4*std::log(s) + 2*mF2*mj2*mV2*std::log(s) - \
2*mG2*mj2*mV2*std::log(s) - \
2*mj4*mV2*std::log(s))*VFout.right())/(mi*mj2*(-mG2 + mV2)*Power2(mi2 - \
mj2));
        }
      }
    }
  }
} 

std::complex<double> FFV_SVF_A1R(double mi, double mj, double mF, double mV, double mG, auto SFin, auto VFout)
{
  const double mi2=Power2(mi);
  const double mi3=Power3(mi);
  const double mi4=Power4(mi);
  const double mi6=Power6(mi);
  const double mj2=Power2(mj);
  const double mj3=Power3(mj);
  const double mj4=Power4(mj);
  const double mj6=Power6(mj);
  const double mF2=Power2(mF);
  const double mF4=Power4(mF);
  const double mF6=Power6(mF);
  const double mV2=Power2(mV);
  const double mV4=Power4(mV);
  const double mV6=Power6(mV);
  const double mG2=Power2(mG);
  const double mG4=Power4(mG);
  const double mG6=Power6(mG);
  const double pi2=Power2(M_PI);
  if (is_zero(-mG + mV)) {
    if (is_zero(mF)) {
      if (is_zero(mi-mj)) {
        if (is_zero(mi-mV)) {
          return (SFin.left()*VFout.right())/mi2;
        } else {
          return (mV*SFin.left()*(mi2 + (mi - mV)*(mi + \
mV)*std::log(mV2/(-mi2 + mV2)))*VFout.right())/Power5(mi);
        }
      } else {
        if (is_zero(mi-mV)) {
          return (2*SFin.left()*(6*mj4 + mi2*mj2*(-6 + pi2) + \
6*mi2*mj2*dilog(mj2/(-mi2 + mj2)) + 3*std::log(mi2/(mi2 - mj2))*(-mi4 + \
mj4 + mi2*mj2*std::log(mi2/(mi2 - \
mj2))))*VFout.right())/(3.*Power2(-(mi2*mj) + mj3));
        } else if (is_zero(mj-mV)) {
          return (mj*SFin.left()*(-(mj2*(-12 + pi2)) - mi2*(12 + pi2) \
- 6*(mi2 + mj2)*dilog(mi2/(mi2 - mj2)) + 3*std::log(mj2/(-mi2 + \
mj2))*(-4*(mi - mj)*(mi + mj) - (mi2 + mj2)*std::log(mj2/(-mi2 + \
mj2))))*VFout.right())/(3.*mi*Power2(mi2 - mj2));
        } else {
          return (2*mV*SFin.left()*((-mi + mj)*(mi + mj)*mj2*(mi2 + \
mV2)*ScalarC0(mi2,mj2,mV,mV,mF2) + 2*mj2*(-mi2 + mj2 + (-mi2 + \
mV2)*std::log(mV2/(-mi2 + mV2))) + (mi2 + mj2)*(mj - mV)*(mj + \
mV)*std::log(mV2/(-mj2 + mV2)))*VFout.right())/(mi*mj2*Power2(mi2 - mj2));
        }
      }
    } else {
    const auto r = Power2(mF/mV);
      if (std::max(mV,mF) > approx_limit * std::max(mi,mj)) {
        return 1./mj * SFin.left() * VFout.right() * OneLoopFunctionN(r,r) / mV;// / 2.;
      } else {
        if (is_zero(mi-mj)) {
          return (mV*SFin.left()*(2*mi2 + (2*mi2*(mF4 + mi4 - 2*(mF2 + \
mi2)*mV2 + mV4)*DiscontinuityB(mi2,mF,mV))/KallenLambda(mF2,mi2,mV2) \
- (mF2 + mi2 - mV2)*std::log(r))*VFout.right())/(2.*Power5(mi));
        } else {
          return (mV*SFin.left()*(-4*mi2*mj2*DiscontinuityB(mi2,mF,mV) \
+ 2*mj2*(mi2 + mj2)*DiscontinuityB(mj2,mF,mV) + (mi - mj)*(mi + \
mj)*(-4*mj2 + 2*mj2*(mF2 - mi2 - mV2)*ScalarC0(mi2,mj2,mV,mV,mF) + \
(-mF2 + mj2 + mV2)*std::log(r)))*VFout.right())/(mi*mj2*Power2(mi - \
mj)*Power2(mi + mj));
        }
      }
    }
  } else {
    if (is_zero(mF)) {
      if (is_zero(mi-mj)) {
        if (is_zero(mi-mV)) {
          return (SFin.left()*(mG4*mi2 - 4*mG2*mi4 + 3*mi6 + \
Power3(-mG + mi)*Power3(mG + mi)*std::log(mG2/(mG2 - mi2)) - (-3*mG2 + \
mi2)*mi4*std::log(mG2/mi2))*VFout.right())/(3.*mi4*Power2(mG2 - mi2));
        } else if (is_zero(mG)){
          return (2*mV*SFin.left()*(-(mi4*mV2) + mi2*mV4 + \
mi6*std::log(mi2/mV2) + Power3(mi2 - mV2)*std::log(mV2/(-mi2 + \
mV2)))*VFout.right())/(3.*Power2(mi2 - mV2)*Power5(mi));
        } else {
          return (mV*SFin.left()*(mi2*(mG - mV)*(mG + mV)*(mG2 - mi2 - \
2*mV2) - Power3(mG2 - mi2)*std::log(mG2/(mG2 - mi2)) + (3*mG2*mi4 - \
mi6)*std::log(mG2/mV2) + (3*mG2 - mi2 - 2*mV2)*Power2(mi2 - \
mV2)*std::log(mV2/(-mi2 + mV2)))*VFout.right())/(3.*Power2(mG2 - \
mV2)*Power5(mi));
        }
      } else {
        if (is_zero(mi-mG)) {
          if (is_zero(mj-mV)) {
            return (2*mj*SFin.left()*(-mi2 + mj2 + \
mi2*std::log(mi2/mj2))*VFout.right())/(mi*Power2(mi2 - mj2));
          } else {
            return (2*mV*SFin.left()*(-mi2 + mj2 + 2*mi2*(mj - mV)*(mj \
+ mV)*ScalarC0(mi2,mj2,mV,mi,mF2) + (mi2*(mi2 + mj2 - \
2*mV2)*std::log(mi2/mV2))/(mi2 - mV2) + ((mi2 + mj2)*(mj - mV)*(mj + \
mV)*std::log(mV2/(-mj2 + mV2)))/mj2)*VFout.right())/(mi*Power2(mi - \
mj)*Power2(mi + mj));
          }
        } else {
          if (is_zero(mj-mV)) {
            return (2*mj*SFin.left()*(-((mG - mi)*(mG + mi)*(mG - \
mj)*(mG + mj)*(mi2 + mj2)*ScalarC0(mi2,mj2,mj,mG,mF2)) + (mG - \
mj)*(mG + mj)*((mi - mj)*(mi + mj) + 2*(-mG + mi)*(mG + \
mi)*std::log(mG2/(mG2 - mi2))) - (-2*mi2*mj2 + mG2*(mi2 + \
mj2))*std::log(mG2/mj2))*VFout.right())/(mi*(-mG2 + mj2)*Power2(mi2 - \
mj2));
          } else {
            return (2*mV*SFin.left()*(mj2*(mG - mV)*(mG + \
mV)*(mG2*(mi2 + mj2) + mi2*(-mi2 + mj2 - \
2*mV2))*ScalarC0(mi2,mj2,mV,mG,mF2) + mj2*((mG - mV)*(mG + mV)*(-mi2 \
+ mj2 + 2*(mG - mi)*(mG + mi)*std::log(mG2/(mG2 - mi2))) + (mG2*(mi2 + \
mj2) - 2*mi2*mV2)*std::log(mG2/mV2)) + (mi2 + mj2)*(mG - mV)*(mj - \
mV)*(mG + mV)*(mj + mV)*std::log(mV2/(-mj2 + \
mV2)))*VFout.right())/(mi*mj2*(mG - mV)*(mG + mV)*Power2(mi - \
mj)*Power2(mi + mj));
          }
        }
      }
    } else {
    const auto r = Power2(mF/mV);
    const auto s = Power2(mF/mG);
      if (std::max(std::max(mV,mG),mF) > approx_limit * std::max(mi,mj)) {
        return 1./mj * SFin.left() * VFout.right() * OneLoopFunctionN(r,s) / mV;// / 2.;
      } else {
        if (is_zero(mi-mj)) {
          return (mV*SFin.left()*(2*(-mF - mG + mi)*(mF - mG + \
mi)*(-mF + mG + mi)*(mF + mG + mi)*mi2*DiscontinuityB(mi2,mF,mG) - \
2*mi2*(mF4 + mF2*(-3*mG2 - 2*mi2 + mV2) + (mi - mV)*(mi + mV)*(-3*mG2 \
+ mi2 + 2*mV2))*DiscontinuityB(mi2,mF,mV) - (-mF2 + mG2 + \
mi2)*(-2*(mF2 + 2*mG2)*mi2 + mi4 + Power2(mF2 - mG2))*std::log(mG2/mV2) \
+ (mG - mV)*(mG + mV)*(2*mi2*(mF2 + mG2 - mi2 - 2*mV2) + (mG - \
mV)*(mG + mV)*(-3*mF2 + mG2 - 3*mi2 + \
2*mV2)*std::log(r)))*VFout.right())/(6.*Power2(mG2 - mV2)*Power5(mi));
        } else {
          return (mV*SFin.left()*(2*(mi - mj)*(mi + mj)*mj2*(mG - \
mV)*(mG + mV) + 4*mi2*mj2*(mG - mV)*(mG + \
mV)*DiscontinuityB(mi2,mF,mG) - 2*mj2*(mi2 + mj2)*(mG - mV)*(mG + \
mV)*DiscontinuityB(mj2,mF,mV) - 2*mj2*(mG - mV)*(mG + mV)*(mF2*(mi - \
mj)*(mi + mj) + mG2*(mi2 + mj2) + mi2*(-mi2 + mj2 - \
2*mV2))*ScalarC0(mi2,mj2,mV,mG,mF) + 2*(mi - mj)*(mi + \
mj)*mj2*mV2*std::log(mG2/mV2) + mF2*mG2*mi2*std::log(r) + \
mF2*mG2*mj2*std::log(r) - mG2*mi2*mj2*std::log(r) - mG2*mj4*std::log(r) - \
mF2*mi2*mV2*std::log(r) - mG2*mi2*mV2*std::log(r) - mF2*mj2*mV2*std::log(r) \
- mG2*mj2*mV2*std::log(r) + mi2*mj2*mV2*std::log(r) + mj4*mV2*std::log(r) + \
mi2*mV4*std::log(r) + mj2*mV4*std::log(r) - 2*mF2*mG2*mj2*std::log(s) + \
2*mG4*mj2*std::log(s) + 2*mG2*mj4*std::log(s) + 2*mF2*mj2*mV2*std::log(s) - \
2*mG2*mj2*mV2*std::log(s) - \
2*mj4*mV2*std::log(s))*VFout.right())/(mi*mj2*(-mG2 + mV2)*Power2(mi2 - \
mj2));
        }
      }
    }
  }        
} 

std::complex<double> FFV_SVF_A2L(double mi, double mj, double mF, double mV, double mG, auto SFin, auto VFout)
{
  const double mi2=Power2(mi);
  const double mi3=Power3(mi);
  const double mi4=Power4(mi);
  const double mi6=Power6(mi);
  const double mj2=Power2(mj);
  const double mj3=Power3(mj);
  const double mj4=Power4(mj);
  const double mj6=Power6(mj);
  const double mF2=Power2(mF);
  const double mF4=Power4(mF);
  const double mF6=Power6(mF);
  const double mV2=Power2(mV);
  const double mV4=Power4(mV);
  const double mV6=Power6(mV);
  const double mG2=Power2(mG);
  const double mG4=Power4(mG);
  const double mG6=Power6(mG);
  const double pi2=Power2(M_PI);
  if (is_zero(-mG + mV)) {
    if (is_zero(mF)) {
      if (is_zero(mi-mj)) {
        if (is_zero(mi-mV)) {
          return (SFin.left()*VFout.right())/mi2;
        } else {
          return (mV*SFin.left()*(mi2 + (mi - mV)*(mi + \
mV)*std::log(mV2/(-mi2 + mV2)))*VFout.right())/Power5(mi);
        }
      } else {
        if (is_zero(mi-mV)) {
          return (2*SFin.left()*(6*mj4 + mi2*mj2*(-6 + pi2) + \
6*mi2*mj2*dilog(mj2/(-mi2 + mj2)) + 3*std::log(mi2/(mi2 - mj2))*(-mi4 + \
mj4 + mi2*mj2*std::log(mi2/(mi2 - \
mj2))))*VFout.right())/(3.*Power2(-(mi2*mj) + mj3));
        } else if (is_zero(mj-mV)) {
          return (mj*SFin.left()*(-(mj2*(-12 + pi2)) - mi2*(12 + pi2) \
- 6*(mi2 + mj2)*dilog(mi2/(mi2 - mj2)) + 3*std::log(mj2/(-mi2 + \
mj2))*(-4*(mi - mj)*(mi + mj) - (mi2 + mj2)*std::log(mj2/(-mi2 + \
mj2))))*VFout.right())/(3.*mi*Power2(mi2 - mj2));
        } else {
          return (2*mV*SFin.left()*((-mi + mj)*(mi + mj)*mj2*(mi2 + \
mV2)*ScalarC0(mi2,mj2,mV,mV,mF2) + 2*mj2*(-mi2 + mj2 + (-mi2 + \
mV2)*std::log(mV2/(-mi2 + mV2))) + (mi2 + mj2)*(mj - mV)*(mj + \
mV)*std::log(mV2/(-mj2 + mV2)))*VFout.right())/(mi*mj2*Power2(mi2 - mj2));
        }
      }
    } else {
    const auto r = Power2(mF/mV);
      if (std::max(mV,mF) > approx_limit * std::max(mi,mj)) {
        return 1./mj * SFin.left() * VFout.right() * OneLoopFunctionN(r,r) / mV;// / 2.;
      } else {
        if (is_zero(mi-mj)) {
          return (mV*SFin.left()*(2*mi2 + (2*mi2*(mF4 + mi4 - 2*(mF2 + \
mi2)*mV2 + mV4)*DiscontinuityB(mi2,mF,mV))/KallenLambda(mF2,mi2,mV2) \
- (mF2 + mi2 - mV2)*std::log(r))*VFout.right())/(2.*Power5(mi));
        } else {
          return (mV*SFin.left()*(-4*mi2*mj2*DiscontinuityB(mi2,mF,mV) \
+ 2*mj2*(mi2 + mj2)*DiscontinuityB(mj2,mF,mV) + (mi - mj)*(mi + \
mj)*(-4*mj2 + 2*mj2*(mF2 - mi2 - mV2)*ScalarC0(mi2,mj2,mV,mV,mF) + \
(-mF2 + mj2 + mV2)*std::log(r)))*VFout.right())/(mi*mj2*Power2(mi - \
mj)*Power2(mi + mj));
        }
      }
    }
  } else {
    if (is_zero(mF)) {
      if (is_zero(mi-mj)) {
        if (is_zero(mi-mV)) {
          return (SFin.left()*(mG4*mi2 - 4*mG2*mi4 + 3*mi6 + \
Power3(-mG + mi)*Power3(mG + mi)*std::log(mG2/(mG2 - mi2)) - (-3*mG2 + \
mi2)*mi4*std::log(mG2/mi2))*VFout.right())/(3.*mi4*Power2(mG2 - mi2));
        } else if (is_zero(mG)){
          return (2*mV*SFin.left()*(-(mi4*mV2) + mi2*mV4 + \
mi6*std::log(mi2/mV2) + Power3(mi2 - mV2)*std::log(mV2/(-mi2 + \
mV2)))*VFout.right())/(3.*Power2(mi2 - mV2)*Power5(mi));
        } else {
          return (mV*SFin.left()*(mi2*(mG - mV)*(mG + mV)*(mG2 - mi2 - \
2*mV2) - Power3(mG2 - mi2)*std::log(mG2/(mG2 - mi2)) + (3*mG2*mi4 - \
mi6)*std::log(mG2/mV2) + (3*mG2 - mi2 - 2*mV2)*Power2(mi2 - \
mV2)*std::log(mV2/(-mi2 + mV2)))*VFout.right())/(3.*Power2(mG2 - \
mV2)*Power5(mi));
        }
      } else {
        if (is_zero(mi-mG)) {
          if (is_zero(mj-mV)) {
            return (2*mj*SFin.left()*(-mi2 + mj2 + \
mi2*std::log(mi2/mj2))*VFout.right())/(mi*Power2(mi2 - mj2));
          } else {
            return (2*mV*SFin.left()*(-mi2 + mj2 + 2*mi2*(mj - mV)*(mj \
+ mV)*ScalarC0(mi2,mj2,mV,mi,mF2) + (mi2*(mi2 + mj2 - \
2*mV2)*std::log(mi2/mV2))/(mi2 - mV2) + ((mi2 + mj2)*(mj - mV)*(mj + \
mV)*std::log(mV2/(-mj2 + mV2)))/mj2)*VFout.right())/(mi*Power2(mi - \
mj)*Power2(mi + mj));
          }
        } else {
          if (is_zero(mj-mV)) {
            return (2*mj*SFin.left()*(-((mG - mi)*(mG + mi)*(mG - \
mj)*(mG + mj)*(mi2 + mj2)*ScalarC0(mi2,mj2,mj,mG,mF2)) + (mG - \
mj)*(mG + mj)*((mi - mj)*(mi + mj) + 2*(-mG + mi)*(mG + \
mi)*std::log(mG2/(mG2 - mi2))) - (-2*mi2*mj2 + mG2*(mi2 + \
mj2))*std::log(mG2/mj2))*VFout.right())/(mi*(-mG2 + mj2)*Power2(mi2 - \
mj2));
          } else {
            return (2*mV*SFin.left()*(mj2*(mG - mV)*(mG + \
mV)*(mG2*(mi2 + mj2) + mi2*(-mi2 + mj2 - \
2*mV2))*ScalarC0(mi2,mj2,mV,mG,mF2) + mj2*((mG - mV)*(mG + mV)*(-mi2 \
+ mj2 + 2*(mG - mi)*(mG + mi)*std::log(mG2/(mG2 - mi2))) + (mG2*(mi2 + \
mj2) - 2*mi2*mV2)*std::log(mG2/mV2)) + (mi2 + mj2)*(mG - mV)*(mj - \
mV)*(mG + mV)*(mj + mV)*std::log(mV2/(-mj2 + \
mV2)))*VFout.right())/(mi*mj2*(mG - mV)*(mG + mV)*Power2(mi - \
mj)*Power2(mi + mj));
          }
        }
      }
    } else {
    const auto r = Power2(mF/mV);
    const auto s = Power2(mF/mG);
      if (std::max(std::max(mV,mG),mF) > approx_limit * std::max(mi,mj)) {
        return 1./mj * SFin.left() * VFout.right() * OneLoopFunctionN(r,s) / mV;// / 2.;
      } else {
        if (is_zero(mi-mj)) {
          return (mV*SFin.left()*(2*(-mF - mG + mi)*(mF - mG + \
mi)*(-mF + mG + mi)*(mF + mG + mi)*mi2*DiscontinuityB(mi2,mF,mG) - \
2*mi2*(mF4 + mF2*(-3*mG2 - 2*mi2 + mV2) + (mi - mV)*(mi + mV)*(-3*mG2 \
+ mi2 + 2*mV2))*DiscontinuityB(mi2,mF,mV) - (-mF2 + mG2 + \
mi2)*(-2*(mF2 + 2*mG2)*mi2 + mi4 + Power2(mF2 - mG2))*std::log(mG2/mV2) \
+ (mG - mV)*(mG + mV)*(2*mi2*(mF2 + mG2 - mi2 - 2*mV2) + (mG - \
mV)*(mG + mV)*(-3*mF2 + mG2 - 3*mi2 + \
2*mV2)*std::log(r)))*VFout.right())/(6.*Power2(mG2 - mV2)*Power5(mi));
        } else {
          return (mV*SFin.left()*(2*(mi - mj)*(mi + mj)*mj2*(mG - \
mV)*(mG + mV) + 4*mi2*mj2*(mG - mV)*(mG + \
mV)*DiscontinuityB(mi2,mF,mG) - 2*mj2*(mi2 + mj2)*(mG - mV)*(mG + \
mV)*DiscontinuityB(mj2,mF,mV) - 2*mj2*(mG - mV)*(mG + mV)*(mF2*(mi - \
mj)*(mi + mj) + mG2*(mi2 + mj2) + mi2*(-mi2 + mj2 - \
2*mV2))*ScalarC0(mi2,mj2,mV,mG,mF) + 2*(mi - mj)*(mi + \
mj)*mj2*mV2*std::log(mG2/mV2) + mF2*mG2*mi2*std::log(r) + \
mF2*mG2*mj2*std::log(r) - mG2*mi2*mj2*std::log(r) - mG2*mj4*std::log(r) - \
mF2*mi2*mV2*std::log(r) - mG2*mi2*mV2*std::log(r) - mF2*mj2*mV2*std::log(r) \
- mG2*mj2*mV2*std::log(r) + mi2*mj2*mV2*std::log(r) + mj4*mV2*std::log(r) + \
mi2*mV4*std::log(r) + mj2*mV4*std::log(r) - 2*mF2*mG2*mj2*std::log(s) + \
2*mG4*mj2*std::log(s) + 2*mG2*mj4*std::log(s) + 2*mF2*mj2*mV2*std::log(s) - \
2*mG2*mj2*mV2*std::log(s) - \
2*mj4*mV2*std::log(s))*VFout.right())/(mi*mj2*(-mG2 + mV2)*Power2(mi2 - \
mj2));
        }
      }
    }
  }
} 

std::complex<double> FFV_SVF_A2R(double mi, double mj, double mF, double mV, double mG, auto SFin, auto VFout)
{
  const double mi2=Power2(mi);
  const double mi3=Power3(mi);
  const double mi4=Power4(mi);
  const double mi6=Power6(mi);
  const double mj2=Power2(mj);
  const double mj3=Power3(mj);
  const double mj4=Power4(mj);
  const double mj6=Power6(mj);
  const double mF2=Power2(mF);
  const double mF4=Power4(mF);
  const double mF6=Power6(mF);
  const double mV2=Power2(mV);
  const double mV4=Power4(mV);
  const double mV6=Power6(mV);
  const double mG2=Power2(mG);
  const double mG4=Power4(mG);
  const double mG6=Power6(mG);
  const double pi2=Power2(M_PI);
  if (is_zero(-mG + mV)) {
    if (is_zero(mF)) {
      if (is_zero(mi-mj)) {
        if (is_zero(mi-mV)) {
          return (SFin.left()*VFout.right())/mi2;
        } else {
          return (mV*SFin.left()*(mi2 + (mi - mV)*(mi + \
mV)*std::log(mV2/(-mi2 + mV2)))*VFout.right())/Power5(mi);
        }
      } else {
        if (is_zero(mi-mV)) {
          return (2*SFin.left()*(6*mj4 + mi2*mj2*(-6 + pi2) + \
6*mi2*mj2*dilog(mj2/(-mi2 + mj2)) + 3*std::log(mi2/(mi2 - mj2))*(-mi4 + \
mj4 + mi2*mj2*std::log(mi2/(mi2 - \
mj2))))*VFout.right())/(3.*Power2(-(mi2*mj) + mj3));
        } else if (is_zero(mj-mV)) {
          return (mj*SFin.left()*(-(mj2*(-12 + pi2)) - mi2*(12 + pi2) \
- 6*(mi2 + mj2)*dilog(mi2/(mi2 - mj2)) + 3*std::log(mj2/(-mi2 + \
mj2))*(-4*(mi - mj)*(mi + mj) - (mi2 + mj2)*std::log(mj2/(-mi2 + \
mj2))))*VFout.right())/(3.*mi*Power2(mi2 - mj2));
        } else {
          return (2*mV*SFin.left()*((-mi + mj)*(mi + mj)*mj2*(mi2 + \
mV2)*ScalarC0(mi2,mj2,mV,mV,mF2) + 2*mj2*(-mi2 + mj2 + (-mi2 + \
mV2)*std::log(mV2/(-mi2 + mV2))) + (mi2 + mj2)*(mj - mV)*(mj + \
mV)*std::log(mV2/(-mj2 + mV2)))*VFout.right())/(mi*mj2*Power2(mi2 - mj2));
        }
      }
    } else {
    const auto r = Power2(mF/mV);
      if (std::max(mV,mF) > approx_limit * std::max(mi,mj)) {
        return 1./mj * SFin.right() * VFout.left() * OneLoopFunctionN(r,r) / mV;// / 2.;
      } else {
        if (is_zero(mi-mj)) {
          return (mV*SFin.left()*(2*mi2 + (2*mi2*(mF4 + mi4 - 2*(mF2 + \
mi2)*mV2 + mV4)*DiscontinuityB(mi2,mF,mV))/KallenLambda(mF2,mi2,mV2) \
- (mF2 + mi2 - mV2)*std::log(r))*VFout.right())/(2.*Power5(mi));
        } else {
          return (mV*SFin.left()*(-4*mi2*mj2*DiscontinuityB(mi2,mF,mV) \
+ 2*mj2*(mi2 + mj2)*DiscontinuityB(mj2,mF,mV) + (mi - mj)*(mi + \
mj)*(-4*mj2 + 2*mj2*(mF2 - mi2 - mV2)*ScalarC0(mi2,mj2,mV,mV,mF) + \
(-mF2 + mj2 + mV2)*std::log(r)))*VFout.right())/(mi*mj2*Power2(mi - \
mj)*Power2(mi + mj));
        }
      }
    }
  } else {
    if (is_zero(mF)) {
      if (is_zero(mi-mj)) {
        if (is_zero(mi-mV)) {
          return (SFin.left()*(mG4*mi2 - 4*mG2*mi4 + 3*mi6 + \
Power3(-mG + mi)*Power3(mG + mi)*std::log(mG2/(mG2 - mi2)) - (-3*mG2 + \
mi2)*mi4*std::log(mG2/mi2))*VFout.right())/(3.*mi4*Power2(mG2 - mi2));
        } else if (is_zero(mG)){
          return (2*mV*SFin.left()*(-(mi4*mV2) + mi2*mV4 + \
mi6*std::log(mi2/mV2) + Power3(mi2 - mV2)*std::log(mV2/(-mi2 + \
mV2)))*VFout.right())/(3.*Power2(mi2 - mV2)*Power5(mi));
        } else {
          return (mV*SFin.left()*(mi2*(mG - mV)*(mG + mV)*(mG2 - mi2 - \
2*mV2) - Power3(mG2 - mi2)*std::log(mG2/(mG2 - mi2)) + (3*mG2*mi4 - \
mi6)*std::log(mG2/mV2) + (3*mG2 - mi2 - 2*mV2)*Power2(mi2 - \
mV2)*std::log(mV2/(-mi2 + mV2)))*VFout.right())/(3.*Power2(mG2 - \
mV2)*Power5(mi));
        }
      } else {
        if (is_zero(mi-mG)) {
          if (is_zero(mj-mV)) {
            return (2*mj*SFin.left()*(-mi2 + mj2 + \
mi2*std::log(mi2/mj2))*VFout.right())/(mi*Power2(mi2 - mj2));
          } else {
            return (2*mV*SFin.left()*(-mi2 + mj2 + 2*mi2*(mj - mV)*(mj \
+ mV)*ScalarC0(mi2,mj2,mV,mi,mF2) + (mi2*(mi2 + mj2 - \
2*mV2)*std::log(mi2/mV2))/(mi2 - mV2) + ((mi2 + mj2)*(mj - mV)*(mj + \
mV)*std::log(mV2/(-mj2 + mV2)))/mj2)*VFout.right())/(mi*Power2(mi - \
mj)*Power2(mi + mj));
          }
        } else {
          if (is_zero(mj-mV)) {
            return (2*mj*SFin.left()*(-((mG - mi)*(mG + mi)*(mG - \
mj)*(mG + mj)*(mi2 + mj2)*ScalarC0(mi2,mj2,mj,mG,mF2)) + (mG - \
mj)*(mG + mj)*((mi - mj)*(mi + mj) + 2*(-mG + mi)*(mG + \
mi)*std::log(mG2/(mG2 - mi2))) - (-2*mi2*mj2 + mG2*(mi2 + \
mj2))*std::log(mG2/mj2))*VFout.right())/(mi*(-mG2 + mj2)*Power2(mi2 - \
mj2));
          } else {
            return (2*mV*SFin.left()*(mj2*(mG - mV)*(mG + \
mV)*(mG2*(mi2 + mj2) + mi2*(-mi2 + mj2 - \
2*mV2))*ScalarC0(mi2,mj2,mV,mG,mF2) + mj2*((mG - mV)*(mG + mV)*(-mi2 \
+ mj2 + 2*(mG - mi)*(mG + mi)*std::log(mG2/(mG2 - mi2))) + (mG2*(mi2 + \
mj2) - 2*mi2*mV2)*std::log(mG2/mV2)) + (mi2 + mj2)*(mG - mV)*(mj - \
mV)*(mG + mV)*(mj + mV)*std::log(mV2/(-mj2 + \
mV2)))*VFout.right())/(mi*mj2*(mG - mV)*(mG + mV)*Power2(mi - \
mj)*Power2(mi + mj));
          }
        }
      }
    } else {
    const auto r = Power2(mF/mV);
    const auto s = Power2(mF/mG);
      if (std::max(std::max(mV,mG),mF) > approx_limit * std::max(mi,mj)) {
        return 1./mj * SFin.right() * VFout.left() * OneLoopFunctionN(r,s) / mV;// / 2.;
      } else {
        if (is_zero(mi-mj)) {
          return (mV*SFin.left()*(2*(-mF - mG + mi)*(mF - mG + \
mi)*(-mF + mG + mi)*(mF + mG + mi)*mi2*DiscontinuityB(mi2,mF,mG) - \
2*mi2*(mF4 + mF2*(-3*mG2 - 2*mi2 + mV2) + (mi - mV)*(mi + mV)*(-3*mG2 \
+ mi2 + 2*mV2))*DiscontinuityB(mi2,mF,mV) - (-mF2 + mG2 + \
mi2)*(-2*(mF2 + 2*mG2)*mi2 + mi4 + Power2(mF2 - mG2))*std::log(mG2/mV2) \
+ (mG - mV)*(mG + mV)*(2*mi2*(mF2 + mG2 - mi2 - 2*mV2) + (mG - \
mV)*(mG + mV)*(-3*mF2 + mG2 - 3*mi2 + \
2*mV2)*std::log(r)))*VFout.right())/(6.*Power2(mG2 - mV2)*Power5(mi));
        } else {
          return (mV*SFin.left()*(2*(mi - mj)*(mi + mj)*mj2*(mG - \
mV)*(mG + mV) + 4*mi2*mj2*(mG - mV)*(mG + \
mV)*DiscontinuityB(mi2,mF,mG) - 2*mj2*(mi2 + mj2)*(mG - mV)*(mG + \
mV)*DiscontinuityB(mj2,mF,mV) - 2*mj2*(mG - mV)*(mG + mV)*(mF2*(mi - \
mj)*(mi + mj) + mG2*(mi2 + mj2) + mi2*(-mi2 + mj2 - \
2*mV2))*ScalarC0(mi2,mj2,mV,mG,mF) + 2*(mi - mj)*(mi + \
mj)*mj2*mV2*std::log(mG2/mV2) + mF2*mG2*mi2*std::log(r) + \
mF2*mG2*mj2*std::log(r) - mG2*mi2*mj2*std::log(r) - mG2*mj4*std::log(r) - \
mF2*mi2*mV2*std::log(r) - mG2*mi2*mV2*std::log(r) - mF2*mj2*mV2*std::log(r) \
- mG2*mj2*mV2*std::log(r) + mi2*mj2*mV2*std::log(r) + mj4*mV2*std::log(r) + \
mi2*mV4*std::log(r) + mj2*mV4*std::log(r) - 2*mF2*mG2*mj2*std::log(s) + \
2*mG4*mj2*std::log(s) + 2*mG2*mj4*std::log(s) + 2*mF2*mj2*mV2*std::log(s) - \
2*mG2*mj2*mV2*std::log(s) - \
2*mj4*mV2*std::log(s))*VFout.right())/(mi*mj2*(-mG2 + mV2)*Power2(mi2 - \
mj2));
        }
      }
    }
  }
} 


/**
* @defgroup FFVContributions FFV diagram massless photon contributions
* @brief Contributions to the processes Fe_I -> Fe_J gamma at the one-loop level.
*
* Diagram contributions are of the form:
* \Gamma^\mu = gamma^\mu F1 + I sigma^\mu\nu (p-pp)_\nu / (2*mj) F2
*                A1L gamma^\mu P_L + A1R gamma^\mu P_R 
*              + A2L I sigma^\mu\nu (p-pp)_\nu / (2*mj) P_L
*              + A2R I sigma^\mu\nu (p-pp)_\nu / (2*mj) P_R 
*/


// emit massless vector boson from the internal scalar line
template <class Fj, class Fi, class V, class SA, class SB, class F>
std::valarray<std::complex<double>> FFV_SSF<Fj, Fi, V, SA, SB, F>::value(
   const typename field_indices<Fj>::type& indices_in,
   const typename field_indices<Fi>::type& indices_out,
   context_base const& context,
   bool discard_SM_contributions)
{

   static_assert(
      std::is_same<SA, SB>::type::value,
      "Internal scalars in the FFV_SSF instantiation must be of the same type."
   );

   using VertexFBarFjSBar = Vertex<typename F::lorentz_conjugate, typename SA::lorentz_conjugate, Fj>;
   using VertexFiBarFS    = Vertex<typename Fi::lorentz_conjugate, SB, F>;
   using VertexSBarSVBar  = Vertex<typename SB::lorentz_conjugate, SA, typename V::lorentz_conjugate>;

   // masses of external fermions
   const auto mj = context.mass<Fj>(indices_in);
   const auto mi = context.mass<Fi>(indices_out);

   // loop over all possible particle generations attached to both vertices
   std::valarray<std::complex<double>> res {0.0, 0.0, 0.0, 0.0};
   for (const auto& indexIn: index_range<VertexFBarFjSBar>()) {
      for (const auto& indexOut: index_range<VertexFiBarFS>()) {

         // cycle if generations of external fermions  are different then requested   
         const auto jFieldIndices = VertexFBarFjSBar::template indices_of_field<2>(indexIn);
         const auto iFieldIndices = VertexFiBarFS::template indices_of_field<0>(indexOut);
         if (jFieldIndices != indices_in || iFieldIndices != indices_out)
            continue;

         // match indices of the fermion in the loop
         const auto fermionFieldIndicesIn = VertexFBarFjSBar::template indices_of_field<0>(indexIn);
         const auto fermionFieldIndicesOut = VertexFiBarFS::template indices_of_field<2>(indexOut);
         if (fermionFieldIndicesIn != fermionFieldIndicesOut)
            continue;

         // match indices of the scalar in the loop
         const auto scalarFieldIndicesIn = VertexFBarFjSBar::template indices_of_field<1>(indexIn);
         const auto scalarIndicesOut = VertexFiBarFS::template indices_of_field<1>(indexOut);
         if (scalarFieldIndicesIn != scalarIndicesOut) 
            continue;

         if (discard_SM_contributions) {
            if (isSMField<SA>(scalarFieldIndicesIn) && isSMField<F>(fermionFieldIndicesIn)) {
               continue;
            }
         }

         const auto vertexIn = VertexFBarFjSBar::evaluate(indexIn, context);
         const auto vertexOut = VertexFiBarFS::evaluate(indexOut, context);

         const auto indexEmit = concatenate(scalarFieldIndicesIn, scalarFieldIndicesIn);
         const auto vertexEmit = VertexSBarSVBar::evaluate(indexEmit, context);

         const auto mS = context.mass<SA>(scalarFieldIndicesIn);
         const auto mF = context.mass<F>(fermionFieldIndicesIn);

         // TODO: check the sign convention of this coupling
         std::complex<double> vector_boson_coupling {-vertexEmit.value(1,0)};

         const std::complex<double> A1L = FFV_SSF_A1L(mi, mj, mF, mS, vertexIn, vertexOut);
         const std::complex<double> A2L = FFV_SSF_A2L(mi, mj, mF, mS, vertexIn, vertexOut);

         const std::complex<double> A1R = FFV_SSF_A1R(mi, mj, mF, mS, vertexIn, vertexOut);
         const std::complex<double> A2R = FFV_SSF_A2R(mi, mj, mF, mS, vertexIn, vertexOut);

         const std::complex<double> massFactor = 1.0;//Power2(1.0/mS);

         res += oneOver32PiSqr * vector_boson_coupling * massFactor
            * std::valarray<std::complex<double>> {A1L, A1R, A2L, A2R};
      }
   }

   return res;
}

// emit massless vector boson from the internal fermion line
template <class Fj, class Fi, class V, class FA, class FB, class S>
std::valarray<std::complex<double>> FFV_FFS<Fj, Fi, V, FA, FB, S>::value(
   const typename field_indices<Fj>::type& indices_in,
   const typename field_indices<Fi>::type& indices_out,
   context_base const& context,
   bool discard_SM_contributions)
{

   static_assert(
      std::is_same<FA, FB>::type::value, 
      "Internal fermions in the FFV_FFS instantiation must be of the same type."
   );

   using VertexFBarFjSBar = Vertex<typename S::lorentz_conjugate, typename FA::lorentz_conjugate, Fj>;
   using VertexFiBarFS    = Vertex<typename Fi::lorentz_conjugate, FB, S>;
   using VertexFBarFVBar  = Vertex<typename FB::lorentz_conjugate, FA, typename V::lorentz_conjugate>;
   
   // masses of external fermions
   const auto mj = context.mass<Fj>(indices_in);
   const auto mi = context.mass<Fi>(indices_out);

   // loop over all possible particle generations attached to both vertices
   std::valarray<std::complex<double>> res {0.0, 0.0, 0.0, 0.0};
   for (const auto& indexIn: index_range<VertexFBarFjSBar>()) {
      for (const auto& indexOut: index_range<VertexFiBarFS>()) {

         // cycle if generations of external fermions are different then requested   
         const auto jFieldIndices = VertexFBarFjSBar::template indices_of_field<2>(indexIn);
         const auto iFieldIndices = VertexFiBarFS::template indices_of_field<0>(indexOut);
         if (jFieldIndices != indices_in || iFieldIndices != indices_out)
            continue;

         const auto fermionFieldIndicesIn = VertexFBarFjSBar::template indices_of_field<1>(indexIn);
         const auto fermionFieldIndicesOut = VertexFiBarFS::template indices_of_field<1>(indexOut);
         if (fermionFieldIndicesIn != fermionFieldIndicesOut )
            continue;

         const auto scalarFieldIndicesIn = VertexFBarFjSBar::template indices_of_field<0>(indexIn);
         const auto scalarIndicesOut = VertexFiBarFS::template indices_of_field<2>(indexOut);
         if (scalarFieldIndicesIn != scalarIndicesOut) 
            continue;

         if (discard_SM_contributions) {
            if (isSMField<S>(scalarFieldIndicesIn) && isSMField<FA>(fermionFieldIndicesIn)) {
               continue;
            }
         }

         const auto vertexIn = VertexFBarFjSBar::evaluate(indexIn, context);
         const auto vertexOut = VertexFiBarFS::evaluate(indexOut, context);
         
         const auto indexEmit = concatenate(fermionFieldIndicesIn, fermionFieldIndicesIn);
         const auto vertexEmit = VertexFBarFVBar::evaluate(indexEmit, context);

         const auto mF = context.mass<FA>(fermionFieldIndicesIn);
         const auto mS = context.mass<S>(scalarFieldIndicesIn);

         std::complex<double> vector_boson_coupling {vertexEmit.left()};

         const std::complex<double> A1L = FFV_FFS_A1L(mi, mj, mF, mS, vertexIn, vertexOut);
         const std::complex<double> A2L = FFV_FFS_A2L(mi, mj, mF, mS, vertexIn, vertexOut);

         const std::complex<double> A1R = FFV_FFS_A1R(mi, mj, mF, mS, vertexIn, vertexOut);
         const std::complex<double> A2R = FFV_FFS_A2R(mi, mj, mF, mS, vertexIn, vertexOut);

         const std::complex<double> massFactor = 1.0;//Power2(1.0/mS);

         res += oneOver32PiSqr * vector_boson_coupling * massFactor
            * std::valarray<std::complex<double>> {A1L, A1R, A2L, A2R};
      }
   }

   return res;
}

// emit massless vector boson from the internal vector line in a fermion-vector loop
template <class Fj, class Fi, class P, class VA, class VB, class F>
std::valarray<std::complex<double>> FFV_VVF<Fj, Fi, P, VA, VB, F>::value(
   const typename field_indices<Fj>::type& indices_in,
   const typename field_indices<Fi>::type& indices_out,
   context_base const& context,
   bool discard_SM_contributions)
{

   static_assert(
       std::is_same<VA, VB>::type::value,
       "Internal vectors in the FFV_VVF instantiation must be of the same type."
   );

   // use P for external massless vector so as not to confuse with the internal vectors
   using VertexFBarFjVBar = Vertex<typename F::lorentz_conjugate, typename VA::lorentz_conjugate, Fj>;
   using VertexFiBarFV = Vertex<typename Fi::lorentz_conjugate, VB, F>;
   using VertexVBarVPBar = Vertex<typename VB::lorentz_conjugate, VA, typename P::lorentz_conjugate>;

   // masses of external fermions
   const auto mj = context.mass<Fj>(indices_in);
   const auto mi = context.mass<Fi>(indices_out);

   // loop over all possible particle generations attached to both vertices
   std::valarray<std::complex<double>> res {0.0, 0.0, 0.0, 0.0};
   for (const auto& indexIn: index_range<VertexFBarFjVBar>()) {
      for (const auto& indexOut: index_range<VertexFiBarFV>()) {
          
         // cycle if generations of external fermions are different then requested
         const auto jFieldIndices = VertexFBarFjVBar::template indices_of_field<2>(indexIn);
         const auto iFieldIndices = VertexFiBarFV::template indices_of_field<0>(indexOut);
         if (jFieldIndices != indices_in || iFieldIndices != indices_out)
            continue;
         
         // match indices of the fermion in the loop
         const auto fermionFieldIndicesIn = VertexFBarFjVBar::template indices_of_field<0>(indexIn);
         const auto fermionFieldIndicesOut = VertexFiBarFV::template indices_of_field<2>(indexOut);
         if (fermionFieldIndicesIn != fermionFieldIndicesOut)
            continue;

         // match indices of the vector in the loop
         const auto vectorFieldIndicesIn = VertexFBarFjVBar::template indices_of_field<1>(indexIn);
         const auto vectorFieldIndicesOut = VertexFiBarFV::template indices_of_field<1>(indexOut);
         if (vectorFieldIndicesIn != vectorFieldIndicesOut)
            continue;

         // ignore contribution if both vector and fermion are SM particles
         if (discard_SM_contributions) {
            if (isSMField<VA>(vectorFieldIndicesIn) && isSMField<F>(fermionFieldIndicesIn)) {
               continue;
            }
         }

         const auto vertexIn = VertexFBarFjVBar::evaluate(indexIn, context);
         const auto vertexOut = VertexFiBarFV::evaluate(indexOut, context);

         const auto indexEmit = concatenate(vectorFieldIndicesIn, vectorFieldIndicesIn);
         const auto vertexEmit = VertexVBarVPBar::evaluate(indexEmit, context);

         const auto mV = context.mass<VA>(vectorFieldIndicesIn);
         const auto mF = context.mass<F>(fermionFieldIndicesIn);

         // triple gauge boson vertex
         // need to check that the sign and function call are correct
         std::complex<double> vector_boson_coupling {-vertexEmit.value( TripleVectorVertex::even_permutation{} )};

         const std::complex<double> A1L = FFV_VVF_A1L(mi, mj, mF, mV, vertexIn, vertexOut);
	 const std::complex<double> A2L = FFV_VVF_A2L(mi, mj, mF, mV, vertexIn, vertexOut);
         
         const std::complex<double> A1R = FFV_VVF_A1R(mi, mj, mF, mV, vertexIn, vertexOut);
	 const std::complex<double> A2R = FFV_VVF_A2R(mi, mj, mF, mV, vertexIn, vertexOut);

         const std::complex<double> massFactor = 1.0;//Power2(1.0/mV);

         res += oneOver32PiSqr * vector_boson_coupling * massFactor * std::valarray<std::complex<double>> {A1L,A1R,A2L,A2R};
      }
   }

   return res;

}

// emit massless vector boson from the internal vector line in a fermion-vector loop
template <class Fj, class Fi, class P, class FA, class FB, class V>
std::valarray<std::complex<double>> FFV_FFV<Fj, Fi, P, FA, FB, V>::value(
   const typename field_indices<Fj>::type& indices_in,
   const typename field_indices<Fi>::type& indices_out,
   context_base const& context,
   bool discard_SM_contributions)
{

   static_assert(
      std::is_same<FA, FB>::type::value,
      "Internal fermions in the FFV_FFV instantiation must be of the same type."
   );

   // use P for external massless vector so as not to confuse with the internal vectors
   using VertexFBarFjVBar = Vertex<typename V::lorentz_conjugate, typename FA::lorentz_conjugate, Fj>;
   using VertexFiBarFV = Vertex<typename Fi::lorentz_conjugate, FB, V>;
   using VertexFBarFPBar = Vertex<typename FB::lorentz_conjugate, FA, typename P::lorentz_conjugate>;

   // masses of external fermions
   const auto mj = context.mass<Fj>(indices_in);
   const auto mi = context.mass<Fi>(indices_out);

   // loop over all possible particle generations attached to both vertices
   std::valarray<std::complex<double>> res {0.0, 0.0, 0.0, 0.0};
   for (const auto& indexIn: index_range<VertexFBarFjVBar>()) {
      for (const auto& indexOut: index_range<VertexFiBarFV>()) {
           
         // cycle if generations of external fermions are different then requested
         const auto jFieldIndices = VertexFBarFjVBar::template indices_of_field<2>(indexIn);
         const auto iFieldIndices = VertexFiBarFV::template indices_of_field<0>(indexOut);
         if (jFieldIndices != indices_in || iFieldIndices != indices_out)
            continue;

         // match indices of the fermion in the loop
         const auto fermionFieldIndicesIn = VertexFBarFjVBar::template indices_of_field<1>(indexIn);
         const auto fermionFieldIndicesOut = VertexFiBarFV::template indices_of_field<1>(indexOut);
         if (fermionFieldIndicesIn != fermionFieldIndicesOut)
            continue;

         // match indices of the vector in the loop
         const auto vectorFieldIndicesIn = VertexFBarFjVBar::template indices_of_field<0>(indexIn);
         const auto vectorFieldIndicesOut = VertexFiBarFV::template indices_of_field<2>(indexOut);
         if (vectorFieldIndicesIn != vectorFieldIndicesOut)
            continue;

         // ignore contribution if both vector and fermion are SM particles
         if (discard_SM_contributions) {
            if (isSMField<FA>(fermionFieldIndicesIn) && isSMField<V>(vectorFieldIndicesIn)) {
               continue;
            }
         }

         const auto vertexIn = VertexFBarFjVBar::evaluate(indexIn, context);
         const auto vertexOut = VertexFiBarFV::evaluate(indexOut, context);

         const auto indexEmit = concatenate(fermionFieldIndicesIn, fermionFieldIndicesIn);
         const auto vertexEmit = VertexFBarFPBar::evaluate(indexEmit, context);

         const auto mV = context.mass<V>(vectorFieldIndicesIn);
         const auto mF = context.mass<FA>(fermionFieldIndicesIn);

         std::complex<double> vector_boson_coupling {vertexEmit.left()};

         const std::complex<double> A1L = FFV_FFV_A1L(mi, mj, mF, mV, vertexIn, vertexOut);
         const std::complex<double> A2L = FFV_FFV_A2L(mi, mj, mF, mV, vertexIn, vertexOut);

         const std::complex<double> A1R = FFV_FFV_A1R(mi, mj, mF, mV, vertexIn, vertexOut);
         const std::complex<double> A2R = FFV_FFV_A2R(mi, mj, mF, mV, vertexIn, vertexOut);

         std::complex<double> massFactor = 1.0;
         //std::complex<double> massFactor = 0.0;
         //if (std::isinf(x)) {
         //   massFactor = Power2(1.0/mF);
         //} else {
         //   massFactor = Power2(1.0/mV);
         //}

         res += oneOver32PiSqr * vector_boson_coupling * massFactor * std::valarray<std::complex<double>> {A1L,A1R,A2L,A2R};
      }
   }

   return res;

}

// emit massless vector boson from the internal vector line in a fermion-vector loop
template <class Fj, class Fi, class P, class VA, class GB, class F>
std::valarray<std::complex<double>> FFV_VSF<Fj, Fi, P, VA, GB, F>::value(
   const typename field_indices<Fj>::type& indices_in,
   const typename field_indices<Fi>::type& indices_out,
   context_base const& context,
   bool discard_SM_contributions)
{

   // do not assert that VA and GB are the same
   // static_assert(
   //     std::is_same<VA, GB>::type::value,
   //     "Internal vectors in the FFV_VGF instantiation must be of the same type."
   // );

   // use P for external massless vector so as not to confuse with the internal vectors
   using VertexFBarFjVBar = Vertex<typename F::lorentz_conjugate, typename VA::lorentz_conjugate, Fj>;
   using VertexFiBarFG = Vertex<typename Fi::lorentz_conjugate, GB, F>;
   using VertexGBarVPBar = Vertex<typename GB::lorentz_conjugate, VA, typename P::lorentz_conjugate>;

   // masses of external fermions
   const auto mj = context.mass<Fj>(indices_in);
   const auto mi = context.mass<Fi>(indices_out);

   // loop over all possible particle generations attached to both vertices
   std::valarray<std::complex<double>> res {0.0, 0.0, 0.0, 0.0};
   for (const auto& indexIn: index_range<VertexFBarFjVBar>()) {
      for (const auto& indexOut: index_range<VertexFiBarFG>()) {
          
         // cycle if generations of external fermions are different then requested
         const auto jFieldIndices = VertexFBarFjVBar::template indices_of_field<2>(indexIn);
         const auto iFieldIndices = VertexFiBarFG::template indices_of_field<0>(indexOut);
         if (jFieldIndices != indices_in || iFieldIndices != indices_out)
            continue;
         
         // match indices of the fermion in the loop
         const auto fermionFieldIndicesIn = VertexFBarFjVBar::template indices_of_field<0>(indexIn);
         const auto fermionFieldIndicesOut = VertexFiBarFG::template indices_of_field<2>(indexOut);
         if (fermionFieldIndicesIn != fermionFieldIndicesOut)
            continue;

         // cannot match indices if scalar is not would-be-goldstone corresponding to vector
         const auto vectorFieldIndicesIn = VertexFBarFjVBar::template indices_of_field<1>(indexIn);
         const auto goldstoneFieldIndicesOut = VertexFiBarFG::template indices_of_field<1>(indexOut);
         // if (vectorFieldIndicesIn != goldstoneFieldIndicesOut)
         //   continue;

         // ignore contribution if both vector and fermion are SM particles
         if (discard_SM_contributions) {
            if (isSMField<VA>(vectorFieldIndicesIn) && isSMField<GB>(goldstoneFieldIndicesOut) && isSMField<F>(fermionFieldIndicesIn)) {
               continue;
            }
         }

         const auto vertexIn = VertexFBarFjVBar::evaluate(indexIn, context);
         const auto vertexOut = VertexFiBarFG::evaluate(indexOut, context);

         const auto indexEmit = concatenate(vectorFieldIndicesIn, goldstoneFieldIndicesOut);
         const auto vertexEmit = VertexGBarVPBar::evaluate(indexEmit, context);

         const auto mV = context.mass<VA>(vectorFieldIndicesIn);
         const auto mG = context.mass<GB>(goldstoneFieldIndicesOut);
         const auto mF = context.mass<F>(fermionFieldIndicesIn);

         // scalar-vector-vector vertex
         // check that definition and sign is correct
         std::complex<double> vector_boson_coupling {-vertexEmit.value()};

         const std::complex<double> A1L = FFV_VSF_A1L(mi, mj, mF, mV, mG, vertexIn, vertexOut);
         const std::complex<double> A2L = FFV_VSF_A2L(mi, mj, mF, mV, mG, vertexIn, vertexOut);
      
         const std::complex<double> A1R = FFV_VSF_A1R(mi, mj, mF, mV, mG, vertexIn, vertexOut);
         const std::complex<double> A2R = FFV_VSF_A2R(mi, mj, mF, mV, mG, vertexIn, vertexOut);

         const std::complex<double> massFactor = 1.0;//1.0/mV;//Power2(1.0/mV);
          
         res += oneOver32PiSqr * vector_boson_coupling * massFactor * std::valarray<std::complex<double>> {A1L,A1R,A2L,A2R};
      }
   }

   return res;

}

// emit massless vector boson from the internal vector line in a fermion-vector loop
template <class Fj, class Fi, class P, class GA, class VB, class F>
std::valarray<std::complex<double>> FFV_SVF<Fj, Fi, P, GA, VB, F>::value(
   const typename field_indices<Fj>::type& indices_in,
   const typename field_indices<Fi>::type& indices_out,
   context_base const& context,
   bool discard_SM_contributions)
{

   // do not assert that GA and VB are the same
   // static_assert(
   //     std::is_same<GA, VB>::type::value,
   //     "Internal vectors in the FFV_VGF instantiation must be of the same type."
   // );

   // use P for external massless vector so as not to confuse with the internal vectors
   using VertexFBarFjGBar = Vertex<typename F::lorentz_conjugate, typename GA::lorentz_conjugate, Fj>;
   using VertexFiBarFV = Vertex<typename Fi::lorentz_conjugate, VB, F>;
   using VertexVBarGPBar = Vertex<typename VB::lorentz_conjugate, GA, typename P::lorentz_conjugate>;

   // masses of external fermions
   const auto mj = context.mass<Fj>(indices_in);
   const auto mi = context.mass<Fi>(indices_out);

   // loop over all possible particle generations attached to both vertices
   std::valarray<std::complex<double>> res {0.0, 0.0, 0.0, 0.0};
   for (const auto& indexIn: index_range<VertexFBarFjGBar>()) {
      for (const auto& indexOut: index_range<VertexFiBarFV>()) {
          
         // cycle if generations of external fermions are different then requested
         const auto jFieldIndices = VertexFBarFjGBar::template indices_of_field<2>(indexIn);
         const auto iFieldIndices = VertexFiBarFV::template indices_of_field<0>(indexOut);
         if (jFieldIndices != indices_in || iFieldIndices != indices_out)
            continue;
         
         // match indices of the fermion in the loop
         const auto fermionFieldIndicesIn = VertexFBarFjGBar::template indices_of_field<0>(indexIn);
         const auto fermionFieldIndicesOut = VertexFiBarFV::template indices_of_field<2>(indexOut);
         if (fermionFieldIndicesIn != fermionFieldIndicesOut)
            continue;

         // cannot match indices if scalar is not would-be-goldstone corresponding to vector
         const auto goldstoneFieldIndicesIn = VertexFBarFjGBar::template indices_of_field<1>(indexIn);
         const auto vectorFieldIndicesOut = VertexFiBarFV::template indices_of_field<1>(indexOut);
         // if (goldstoneFieldIndicesIn != vectorFieldIndicesOut)
         //    continue;

         // ignore contribution if both vector and fermion are SM particles
         if (discard_SM_contributions) {
            if (isSMField<GA>(goldstoneFieldIndicesIn) && isSMField<VB>(vectorFieldIndicesOut) && isSMField<F>(fermionFieldIndicesIn)) {
               continue;
            }
         }
   
         const auto vertexIn = VertexFBarFjGBar::evaluate(indexIn, context);
         const auto vertexOut = VertexFiBarFV::evaluate(indexOut, context);

         const auto indexEmit = concatenate(goldstoneFieldIndicesIn, vectorFieldIndicesOut);
         const auto vertexEmit = VertexVBarGPBar::evaluate(indexEmit, context);
   
         const auto mV = context.mass<GA>(goldstoneFieldIndicesIn);
         const auto mG = context.mass<VB>(vectorFieldIndicesOut);
         const auto mF = context.mass<F>(fermionFieldIndicesIn);

         // scalar-vector-vector vertex
         // check that definition and sign is correct
         std::complex<double> vector_boson_coupling {-vertexEmit.value()};

         const std::complex<double> A1L = FFV_SVF_A1L(mi, mj, mF, mV, mG, vertexIn, vertexOut);
         const std::complex<double> A2L = FFV_SVF_A2L(mi, mj, mF, mV, mG, vertexIn, vertexOut);
      
         const std::complex<double> A1R = FFV_SVF_A1R(mi, mj, mF, mV, mG, vertexIn, vertexOut);
         const std::complex<double> A2R = FFV_SVF_A2R(mi, mj, mF, mV, mG, vertexIn, vertexOut);

         const std::complex<double> massFactor = 1.0;//1.0/mV;//Power2(1.0/mV);
          
         res += oneOver32PiSqr * vector_boson_coupling * massFactor * std::valarray<std::complex<double>> {A1L,A1R,A2L,A2R};
      }
   }

   return res;

}


} // anonymous namespace
