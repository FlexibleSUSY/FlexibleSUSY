// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

/**
 * @file @ModelName@_FFV_form_factors.cpp
 *
 * This file was generated with FlexibleSUSY @FlexibleSUSYVersion@ and SARAH @SARAHVersion@ .
 */

#include <complex>
#include <valarray>

#include "@ModelName@_mass_eigenstates.hpp"
#include "concatenate.hpp"
#include "cxx_qft/@ModelName@_qft.hpp"

// Allow use of general Passarino-Veltmann functions if FlexibleSUSY has been 
// configured with a loop library
#include "loop_libraries/loop_library.hpp"  

#include "dilog.hpp"
#include "wrappers.hpp"

using namespace flexiblesusy;
using namespace @ModelName@_cxx_diagrams;
using namespace @ModelName@_cxx_diagrams::fields;

namespace {

static constexpr double oneOver32PiSqr = 0.5*oneOver16PiSqr;

/**
 * @class FFV_SSF
 * @brief A template that calculate contributions to the FFV form
 *        factors of a given particles in a one loop diagram
 *        specified by a vector emitters and an exchange particle.
 * @tparam Args Specifies in order the field of which to
 *              calculate the electric dipole moment,
 *              the photon emitter and the exchange particle
 *              in a one-loop diagram where the photon emitter
 *              is a scalar and the exchange particle a fermion.
 *
 * This template evaluates the contribution to the electric
 * dipole moment of a one loop diagram with fields given by
 * \a Args.
 */
template <class Fj, class Fi, class V, class S1, class S2, class F>
struct FFV_SSF {
   static std::valarray<std::complex<double>>
   value(const typename field_indices<Fj>::type& indices_in,
         const typename field_indices<Fi>::type& indices_out,
         context_base const& context,
         bool discard_SM_contributions);
};

/**
* @class FFV_FFS
* @brief A template that calculate contributions to the FFV form
*        factors of a given particle in a one loop diagram
*        specified by a vector emitters and an exchange particle.
* @tparam Args Specifies in order the field of which to
*              calculate the electric dipole moment,
*              the photon emitter and the exchange particle
*              in a one-loop diagram where the photon emitter
*              is a fermion and the exchange particle a scalar.
*
* This template evaluates the contribution to the electric
* dipole moment of a one loop diagram with fields given by
* \a Args.
*/
template <class Fj, class Fi, class V, class F1, class F2, class S>
struct FFV_FFS {
   static std::valarray<std::complex<double>>
   value(const typename field_indices<Fj>::type& indices_in,
         const typename field_indices<Fi>::type& indices_out,
         context_base const& context,
         bool discard_SM_contributions);
};

/**
 * @class FFV_VVF
 * @brief A template that calculates contributions to the FFV form
 *          factors of a given particle in a one loop diagram
 *          specified by a vector emitter and an exchange particle.
 * @tparam Args Specifies in order the field of which to
 *              calculate the electric dipole moment, 
 *              the photon emitter and the exchange particle 
 *              in a one-loop diagram where the photon emitter 
 *              is a vector and the exchange particle a fermion.
 *
 * This template evaluates the contribution to the electric
 * dipole moment of a one loop diagram with fields given by
 * \a Args.
 */
template <class Fj, class Fi, class P, class V1, class V2, class F>
struct FFV_VVF {
    static std::valarray<std::complex<double>>
    value(const typename field_indices<Fj>::type& indices_in,
          const typename field_indices<Fi>::type& indices_out,
          context_base const& context,
          bool discard_SM_contributions);
};

/**
 * @class FFV_FFV
 * @brief A template that calculates contributions to the FFV form
 *        factors of a given particle in a one loop diagram
 *        specified by a vector emitter and an exchange particle.
 * @tparam Args Specifies in order the field of which to
 *              calculate the electric dipole moment,
 *              the photon emitter and the exchange particle
 *              in a one-loop diagram where the photon emitter
 *              is a fermion and the exchange particle a vector.
 *
 * This template evaluates the contribution to the electric
 * dipole moment of a one loop diagram with fields given by
 * \a Args.
 */
template <class Fj, class Fi, class P, class F1, class F2, class V>
struct FFV_FFV {
    static std::valarray<std::complex<double>>
    value(const typename field_indices<Fj>::type& indices_in,
          const typename field_indices<Fi>::type& indices_out,
          context_base const& context,
          bool discard_SM_contributions);
};

/**
 * @class FFV_VGF
 * @brief A template that calculates contributions to the FFV form
 *        factors of a given particle in a one loop diagram
 *        specified by a vector emitter and an exchange particle.
 * @tparam Args Specifies in order the field of which to
 *         calculate the electric dipole moment,
 *         the photon emitter and the exchange particle
 *         in a one-loop diagram where the photon is emitted
 *         from a vector-goldstone vertex and the exchange
 *         particle is a fermion.
 *
 * This template evaluates the contribution to the electric
 * dipole moment of a one loop diagram with fields given by
 * \a Args.
 */
template <class Fj, class Fi, class P, class V1, class G2, class F>
struct FFV_VSF {
    static std::valarray<std::complex<double>>
    value(const typename field_indices<Fj>::type& indices_in,
          const typename field_indices<Fi>::type& indices_out,
          context_base const& context,
          bool discard_SM_contributions);
};

/**
 * @class FFV_GVF
 * @brief A template that calculates contributions to the FFV form
 *        factors of a given particle in a one loop diagram
 *        specified by a vector emitter and an exchange particle.
 * @tparam Args Specifies in order the field of which to
 *              calculate the electric dipole moment,
 *              the photon emitter and the exchange particle
 *              in a one-loop diagram where the photon is emitted
 *              from a goldstone-vector vertex and the exchange
 *              particle is a fermion.
 *
 * This template evaluates the contribution to the electric
 * dipole moment of a one loop diagram with fields given by
 * \a Args.
 */
template <class Fj, class Fi, class P, class G1, class V2, class F>
struct FFV_SVF {
    static std::valarray<std::complex<double>>
    value(const typename field_indices<Fj>::type& indices_in,
          const typename field_indices<Fi>::type& indices_out,
          context_base const& context,
          bool discard_SM_contributions);
};

} // anonymous namespace

namespace flexiblesusy {
namespace @ModelName@_FFV_form_factors {
@FFVFormFactors_InterfaceDefinitions@
}
} // namespace flexiblesusy

namespace {
/**
* @defgroup LoopFunctions Loop functions
* @brief The loop functions necessary for the Fe_I -> Fe_J gamma one-loop calculations.
*
* These are OneLoopFunctionA(), OneLoopFunctionB()
* as specified in arXiv:0808.1819
*/

//  TODO:  Several fixes still needed, 1/r is not helpful when r is infinite, 
//  may need to just input mF and mS\mV and then calculate the ratios in-house.

// Cutoff for standard literature one loop functions.  
const double approx_limit = 100.;
// Cutoff for using simplified one loop functions.  
const double ratio_limit = 0.00001;

// function from eq. 15 of hep-ph/9510309
double OneLoopFunctionA(double r)
{
   if (is_zero(1.0 - r)) {
      return 1.5;
   } else if (is_zero(r)) {
      return 2.0;
   } else if (1./r < Power3(ratio_limit)) {
      // Loop function is about 10^-13, treat as reaching the 0 limit
      return 0.;
   } else if (1./r < ratio_limit) {
      // Expand about 0 to 1st order
      return (-11.-6.*std::log(1./r)) / r;
   } else {
      return (2.0 - 9.0 * r + 18.0 * r * r - 11.0 * r * r * r +
              6.0 * r * r * r * std::log(r)) /
             Power4(1.0 - r);
   }
}

// function from eq. 16 of hep-ph/9510309
double OneLoopFunctionB(double r)
{
   const double y = r - 1.0;
   if (is_zero(r)) {
      return 2.0;
   } else if (std::abs(y) < 0.23) {
      // error around x=1 is <= 10^-12 on an intel i7
      return (1.0000000000000000000 -
              0.4000000000000000000  * y +
              0.2000000000000000000  * y * y -
              0.11428571428571428571 * y * y * y +
              0.07142857142857142857 * y * y * y * y -
              0.04761904761904761905 * y * y * y * y * y +
              0.03333333333333333333 * y * y * y * y * y * y -
              0.02424242424242424242 * y * y * y * y * y * y * y +
              0.0181818181818181818  * y * y * y * y * y * y * y * y -
              0.01398601398601398601 * y * y * y * y * y * y * y * y * y +
              0.01098901098901098901 * y * y * y * y * y * y * y * y * y * y -
              0.0087912087912087912  * y * y * y * y * y * y * y * y * y * y * y +
              0.00714285714285714286 * y * y * y * y * y * y * y * y * y * y * y * y -
              0.0058823529411764706  * y * y * y * y * y * y * y * y * y * y * y * y * y +
              0.0049019607843137255  * y * y * y * y * y * y * y * y * y * y * y * y * y * y -
              0.0041279669762641899  * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y);
   } else if (1./r < ratio_limit) {
      // Expand about 0 to 1st order
      return 4. / r;
   } else {
      return 2. *
             (1.0 - 6.0 * r + 3.0 * r * r + 2.0 * r * r * r -
              6.0 * r * r * std::log(r)) /
             Power4(1.0 - r);
   }
}

// function from eq. 16 of hep-ph/9510309
double OneLoopFunctionC(double r)
{
   const double y = r - 1.0;
   if (is_zero(r)) {
      return 3.0;
   } else if (std::isinf(r)) {
      return 3.0;
   } else if (std::abs(y) < 0.185) {
      // error around x=1 is <= 10^-13 on an intel i7
      return (1.0000000000000000000 -
              0.50000000000000000000 * y +
              0.30000000000000000000 * y * y -
              0.2000000000000000000  * y * y * y +
              0.14285714285714285714 * y * y * y * y -
              0.10714285714285714286 * y * y * y * y * y +
              0.08333333333333333333 * y * y * y * y * y * y -
              0.06666666666666666667 * y * y * y * y * y * y * y +
              0.05454545454545454545 * y * y * y * y * y * y * y * y -
              0.0454545454545454545  * y * y * y * y * y * y * y * y * y +
              0.0384615384615384615  * y * y * y * y * y * y * y * y * y * y -
              0.03296703296703296703 * y * y * y * y * y * y * y * y * y * y * y +
              0.0285714285714285714  * y * y * y * y * y * y * y * y * y * y * y * y -
              0.02500000000000000000 * y * y * y * y * y * y * y * y * y * y * y * y * y +
              0.0220588235294117647  * y * y * y * y * y * y * y * y * y * y * y * y * y * y -
              0.0196078431372549020  * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y);
   } else if (1./r < ratio_limit) {
      // Expand about 0 to 1st order
      return 3. / r;
   } else {
      return 3. * (1.0 - r * r + 2.0 * r * std::log(r)) / Power3(1.0 - r);
   }
}

// function from eq. 17 of hep-ph/9510309
double OneLoopFunctionD(double r)
{
   if (std::isinf(r)) {
      return 0.0;
   } else if (is_zero(1.0 - r)) {
      return -4.5;
   } else if (1./r < ratio_limit) {
      // Expand about 0 to 1st order
      return -7. / r;
   } else {
      return (16.0 - 45.0 * r + 36.0 * r * r - 7.0 * r * r * r +
              6.0 * (2.0 - 3.0 * r) * std::log(r)) /
             Power4(1.0 - r);
   }
}

// function from eq. 18 of hep-ph/9510309
double OneLoopFunctionE(double r)
{
   const double y = r - 1.0;
   if (is_zero(r)) {
      return 12.0;
   } else if (std::abs(y) < 0.21) {
      // error around x=1 is <= 10^-12 on an intel i7
      return (1.0000000000000000000 -
              0.60000000000000000000  * y +
              0.40000000000000000000  * y * y -
              0.28571428571428571429  * y * y * y +
              0.21428571428571428571  * y * y * y * y -
              0.16666666666666666667  * y * y * y * y * y +
              0.13333333333333333333  * y * y * y * y * y * y -
              0.10909090909090909091  * y * y * y * y * y * y * y +
              0.090909090909090909091 * y * y * y * y * y * y * y * y -
              0.076923076923076923077 * y * y * y * y * y * y * y * y * y +
              0.065934065934065934066 * y * y * y * y * y * y * y * y * y * y -
              0.057142857142857142857 * y * y * y * y * y * y * y * y * y * y * y +
              0.050000000000000000000 * y * y * y * y * y * y * y * y * y * y * y * y -
              0.044117647058823529412 * y * y * y * y * y * y * y * y * y * y * y * y * y +
              0.039215686274509803922 * y * y * y * y * y * y * y * y * y * y * y * y * y * y -
              0.035087719298245614035 * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y);
   } else if (1./r < ratio_limit) {
      // Expand about 0 to 1st order
      return 2. / r;
   } else {
      return 2. *
             (2.0 + 3.0 * r - 6.0 * r * r + r * r * r + 6.0 * r * std::log(r)) /
             Power4(1.0 - r);
   }
}

// function from eq. 18 of hep-ph/9510309
double OneLoopFunctionF(double r)
{
   const double y = r - 1.0;
   if (std::abs(y) < 0.155) {
      // error around x=1 is <= 10^-13 on an intel i7
      return (1.0 -
              0.75 * y +
              0.6 * y * y -
              0.50000000000000000000 * y * y * y +
              0.4285714285714285714  * y * y * y * y -
              0.37500000000000000000 * y * y * y * y * y +
              0.33333333333333333333 * y * y * y * y * y * y -
              0.3000000000000000000  * y * y * y * y * y * y * y +
              0.2727272727272727273  * y * y * y * y * y * y * y * y -
              0.2500000000000000000  * y * y * y * y * y * y * y * y * y +
              0.23076923076923076923 * y * y * y * y * y * y * y * y * y * y -
              0.21428571428571428571 * y * y * y * y * y * y * y * y * y * y * y +
              0.2000000000000000000  * y * y * y * y * y * y * y * y * y * y * y * y -
              0.1875000000000000000  * y * y * y * y * y * y * y * y * y * y * y * y * y +
              0.1764705882352941176  * y * y * y * y * y * y * y * y * y * y * y * y * y * y -
              0.16666666666666666667 * y * y * y * y * y * y * y * y * y * y * y * y * y * y * y);
   } else if (1./r < ratio_limit) {
      // Expand about 0 to 1st order
      return 1.5 / r;
   } else {
      return 3. / 2. * (-3.0 + 4.0 * r - r * r - 2.0 * std::log(r)) /
             Power3(1.0 - r);
   }
}

//  One loop function for the form factor F1 which is the coefficient
//  of ubar(pp,mj) \gamma^\mu u(p,mi), for the FFV_VVF contribution.  
double OneLoopFunctionH(double r)
{
   if (is_zero(r)) {
      return 5.0;
   } else if (is_zero(1.0 - r)){
      return 0.0;
   } else if (1./r < Power3(ratio_limit)) {
      // Loop function is about 10^-13, treat as reaching the 0 limit
      return 0.;
   } else if (1./r < ratio_limit) {
      // Expand about 0 to 1st order
      return (-5.-6.*std::log(1./r)) / r;
   } else {
      return (41.0 - 207.0 * r + 279.0 * r * r - 113.0 * r * r * r + 6.0 * r * r * (-15.0 + 13.0 * r)
              * std::log(r)) / Power4(1.0 - r);
      //return (5.0 - 27.0 * r + 27.0 * r * r - 5.0 * r * r * r + 6.0 * (r - 3.0) * r * r * std::log(r)) /
      //        Power4(1.0 - r);
   }
}

//  One loop function for the form factor F1 which is the coefficient
//  of ubar(pp,mj) \gamma^\mu u(p,mi), for the FFV_VVF contribution.  
double OneLoopFunctionI(double r)
{
   if (is_zero(r)) {
      return 1.0;
   } else if (is_zero(1.0 - r)){
      return 0.5;
   } else if (1./r < Power3(ratio_limit)) {
      // Loop function is about 10^-13, treat as reaching the 0 limit
      return 0.;
   } else if (1./r < ratio_limit) {
      // Expand about 0 to 1st order
      return (-1.-1.*std::log(1./r)) / r;
   } else {
      return (1.0 - r + r * std::log(r)) / Power2(1.0 - r);
   }
}

// function from eq. 78 of hep-ph/2104.03691
double OneLoopFunctionJ(double r)
{
   if (is_zero(r)) {
      return 7.0;
   } else if (is_zero(1.0 - r)){
      return 5.0;
   } else if (1./r < Power3(ratio_limit)) {
      // Loop function is about 10^-13, treat as reaching the 0 limit
      return 0.;
   } else if (1./r < ratio_limit) {
      // Expand about 0 to 1st order
      return (-31.-18.*std::log(1./r)) / r;
   } else {
      return (7.0 - 33.0 * r + 57.0 * r * r - 31.0 * r * r * r + 6.0 * r * r * (3.0 * r - 1.0)
                   * std::log(r)) / Power4(1.0 - r);
   }
}

// function from eq. 79 of hep-ph/2104.03691
double OneLoopFunctionK(double r)
{
   if (is_zero(r)) {
      return 1.0;
   } else if (is_zero(1.0 - r)){
      return 2.0 / 3.0;
   } else if (1./r < Power3(ratio_limit)) {
      // Loop function is about 10^-13, treat as reaching the 0 limit
      return 0.;
   } else if (1./r < ratio_limit) {
      // Expand about 0 to 1st order
      return (-3.-2.*std::log(1./r)) / r;
   } else {   
      return (1.0 - 4.0 * r + 3.0 * r * r - 2 * r * r * std::log(r)) / Power3(1.0 - r);
   }
}

//  One loop function for the form factor F1 which is the coefficient
//  of ubar(pp,mj) \gamma^\mu u(p,mi), for the FFV_FFV contribution.  
double OneLoopFunctionL(double r)
{  
   if (is_zero(r)) {
      return -10.0;
   } else if (is_zero(1.0 - r)){
      return 10.5;
   } else if (1./r < ratio_limit) {
      // Expand about 0 to 1st order
      return 25. / r;
   } else {
      return (2.0 + 27.0 * r - 54.0 * r * r + 25.0 * r * r * r - 6.0 * (2.0 - 9.0 * r + 6.0 * r * r)
                 * std::log(r)) / Power4(1.0 - r);
   }
}

// function from eq. 80 of hep-ph/2104.03691
double OneLoopFunctionM(double r)
{
   if (is_zero(r)) {
      return 4.0;
   } else if (is_zero(1.0 - r)){
      return 1.5;
   } else if (1./r < ratio_limit) {
      // Expand about 0 to 1st order
      return 5. / r;
   } else {
      return (4.0 - 9.0 * r + 5.0 * r * r * r + 6.0 * (1.0 - 2.0 * r) * r * std::log(r)) / 
              Power4(1.0 - r);
   }
}

// function from eq. 81 of hep-ph/2104.03691
double OneLoopFunctionN(double r, double s)
{
   if (is_zero(r - s)) {
      if (is_zero(r)) {
         return 1.0 / 2.0;
      } else if (is_zero(1.0 - r)){
         return 1.0 / 3.0;
      } else {
         return (1.0 - 4.0 * r + 3 * r * r - 2 * r * r * std::log(r)) / 2.0 / Power3(1.0 - r);
      }
   } else if (1./s < ratio_limit) {
      // Expand s about 0 to 1st order
      return (1.0 - r * r / s + r * (1.0 / s - 1.0) + r * (1.0 / s + 1.0) * std::log(r)) / Power2(r - 1.0);
   } else {
      return s * (r * Power2(r - s) * std::log(r) + (r - 1.0) * ((r - s) * (s - 1.0) - (r - 1.0)
                              * std::log(r/s))) / Power2(1.0 - r) / Power2(r - s) / (s - 1.0);
   }
}


std::complex<double> FFV_SSF_A2L(double mi, double mj, double mF, double mS, auto SFin, auto SFout)
{
  // Massless emitter (in this case mS==0, mi==mj==mF) will fail
  // Massless mediator (in this case mF==0) case can be calculated
  if (mi==mj and mi==mS and mF==0) {
    return -0.5*Power2(mS)*(SFin.right()*SFout.left() + SFin.left()*SFout.right()) / Power2(mi);
  } else if (not(Loop_library::get_type() == Loop_library::Library::Softsusy)) {
    std::array<std::complex<double>, C_N> c{};
    Loop_library::get().C(c, Power2(mj), 0., Power2(mi), Power2(mF), Power2(mS), Power2(mS), Power2(mS));  
    return -2. * Power2(mS) / mj * (
           - mF*(c[looplibrary::c0] + c[looplibrary::c1] + c[looplibrary::c2])*SFin.left()*SFout.left() 
           + mj*(c[looplibrary::c1] + c[looplibrary::c11] + c[looplibrary::c12])*SFin.right()*SFout.left() 
           + mi*(c[looplibrary::c12] + c[looplibrary::c2] + c[looplibrary::c22])*SFin.left()*SFout.right());
  } else {
    const auto r = Power2(mF/mS);
    //if (std::max(mS,mF) > approx_limit * std::max(mi,mj)) {
      // eq. 16 of hep-ph/9510309 (possibly with different sign)
      return - SFout.left() * SFin.right() * OneLoopFunctionB(r)/12.
             - SFout.left() * SFin.left() * mF/mj * OneLoopFunctionC(r)/3.
             - mi/mj * SFout.right() * SFin.left() * OneLoopFunctionB(r)/12.; 
    //}
  }
}

  
std::complex<double> FFV_SSF_A2R(double mi, double mj, double mF, double mS, auto SFin, auto SFout)
{
  // Massless emitter (in this case mS==0, mi==mj==mF) will fail
  // Massless mediator (in this case mF==0) case can be calculated
  if (mi==mj and mi==mS and mF==0) {
    return -0.5*Power2(mS)*(SFin.right()*SFout.left() + SFin.left()*SFout.right()) / Power2(mi);
  } else if (not(Loop_library::get_type() == Loop_library::Library::Softsusy)) {
    std::array<std::complex<double>, C_N> c{};
    Loop_library::get().C(c, Power2(mj), 0., Power2(mi), Power2(mF), Power2(mS), Power2(mS), Power2(mS)); 
    return -2. * Power2(mS) / mj * (
             mi*(c[looplibrary::c12] + c[looplibrary::c2] + c[looplibrary::c22])*SFin.right()*SFout.left() 
           + mj*(c[looplibrary::c1] + c[looplibrary::c11] + c[looplibrary::c12])*SFin.left()*SFout.right() 
           - mF*(c[looplibrary::c0] + c[looplibrary::c1] + c[looplibrary::c2])*SFin.right()*SFout.right());
  } else {
    const auto r = Power2(mF/mS);
    //if (std::max(mS,mF) > approx_limit * std::max(mi,mj)) {
      // eq. 15 of hep-ph/9510309 after replacement L <-> R (possibly with different sign)
      return - SFout.right() * SFin.left() * OneLoopFunctionB(r)/12.
             - SFout.right() * SFin.right() * mF/mj * OneLoopFunctionC(r)/3.
             - mi/mj * SFout.left() * SFin.right() * OneLoopFunctionB(r)/12.; 
    //}
  }
}


std::complex<double> FFV_FFS_A2L(double mi, double mj, double mF, double mS, auto SFin, auto SFout)
{
  // Massless emitter (in this case mF==0) will fail
  // Massless mediator (in this case mS==0) case can be calculated
  if (mi==mj and mi==mF and mS==0) {
    return -0.5*Power2(mS)*(SFin.right()*SFout.left() + SFin.left()*(4.*SFout.left() + SFout.right())) / Power2(mi);
  } else if (not(Loop_library::get_type() == Loop_library::Library::Softsusy)) {
    std::array<std::complex<double>,C_N>c{};
    Loop_library::get().C(c,Power2(mj),0.,Power2(mi),Power2(mS),Power2(mF),Power2(mF),Power2(mF));
    return -2. * Power2(mS) / mj * (
             mF*(c[looplibrary::c1] + c[looplibrary::c2])*SFin.left()*SFout.left() 
           + mj*(c[looplibrary::c1] + c[looplibrary::c11] + c[looplibrary::c12])*SFin.right()*SFout.left() 
           + mi*(c[looplibrary::c12] + c[looplibrary::c2] + c[looplibrary::c22])*SFin.left()*SFout.right());
  } else {
    const auto r = Power2(mF/mS);
    //if (std::max(mF,mS) > approx_limit * std::max(mi,mj)) {
      // eq. 19 of hep-ph/9510309 (possibly with different sign)
      return - SFout.left() * SFin.right() * OneLoopFunctionE(r)/12.
             - SFout.left() * SFin.left() * mF/mj * OneLoopFunctionF(r) * 2./3.
             - mi/mj * SFout.right() * SFin.left() * OneLoopFunctionE(r)/12.; 
    //}
  }
}

std::complex<double> FFV_FFS_A2R(double mi, double mj, double mF, double mS, auto SFin, auto SFout)
{
  // Massless emitter (in this case mF==0) will fail
  // Massless mediator (in this case mS==0) case can be calculated
  if (mi==mj and mi==mS and mF==0) {
    return -0.5*Power2(mS)*(SFin.left()*SFout.right() + SFin.right()*(SFout.left() + 4.*SFout.right())) / Power2(mi);
  } else if (not(Loop_library::get_type() == Loop_library::Library::Softsusy)) {
    std::array<std::complex<double>,C_N>c{};
    Loop_library::get().C(c,Power2(mj),0.,Power2(mi),Power2(mS),Power2(mF),Power2(mF),Power2(mF));
    return -2. * Power2(mS) / mj * (
             mi*(c[looplibrary::c12] + c[looplibrary::c2] + c[looplibrary::c22])*SFin.right()*SFout.left() 
           + mj*(c[looplibrary::c1] + c[looplibrary::c11] + c[looplibrary::c12])*SFin.left()*SFout.right() 
           + mF*(c[looplibrary::c1] + c[looplibrary::c2])*SFin.right()*SFout.right());
  } else {
    const auto r = Power2(mF/mS);
    //if (std::max(mF,mS) > approx_limit * std::max(mi,mj)) {
      // eq. 19 of hep-ph/9510309 after replacement L <-> R (possibly with different sign)
      return - SFout.right() * SFin.left() * OneLoopFunctionE(r)/12. 
             - SFout.right() * SFin.right() * mF/mj * OneLoopFunctionF(r) * 2./3. 
             - mi/mj * SFout.left() * SFin.right() * OneLoopFunctionE(r)/12.; 
    //}
  }
}


std::complex<double> FFV_VVF_A1L(double mi, double mj, double mF, double mV, auto VFin, auto VFout)
{
    const auto r = Power2(mF/mV);
    //if (std::max(mV,mF) > approx_limit * std::max(mi,mj)) {
        return 8. * mF/mi * VFin.left() * VFout.right() * OneLoopFunctionI(r) 
               + VFin.left() * VFout.left() * OneLoopFunctionH(r) / 18.;
    //}
}  

std::complex<double> FFV_VVF_A1R(double mi, double mj, double mF, double mV, auto VFin, auto VFout)
{
    const auto r = Power2(mF/mV);
    //if (std::max(mV,mF) > approx_limit * std::max(mi,mj)) {
      return 8. * mF/mi * VFin.right() * VFout.left() * OneLoopFunctionI(r)
             + VFin.right() * VFout.right() * OneLoopFunctionH(r) / 18.;
    //}
}  

std::complex<double> FFV_VVF_A2L(double mi, double mj, double mF, double mV, auto VFin, auto VFout)
{
  const double Dim = 4.;
  // Massless emitter (in this case mV==0, mi==mj==mF) will fail
  // Massless mediator (in this case mF==0) case can be calculated
  if (mi==mj and mi==mV and mF==0) {
    return 2.*Power2(mV)*(VFin.left()*VFout.left() + VFin.right()*VFout.right()) / Power2(mi);
  } else if (not(Loop_library::get_type() == Loop_library::Library::Softsusy)) {
    std::array<std::complex<double>,C_N>c{};
    Loop_library::get().C(c,Power2(mj),0.,Power2(mi),Power2(mF),Power2(mV),Power2(mV),Power2(mV));
    return -2. * Power2(mV) / mj * (
             mi*(-c[looplibrary::c1] + (Dim-2.)*c[looplibrary::c12] + (Dim-4.)*c[looplibrary::c2] + (Dim-2.)*c[looplibrary::c22])*VFin.left()*VFout.left() 
           + mF*(-((Dim-4.)*c[looplibrary::c0]) - (Dim-1.)*(c[looplibrary::c1] + c[looplibrary::c2]))*VFin.left()*VFout.right() 
           + mj*((Dim-4.)*c[looplibrary::c1] + (Dim-2.)*(c[looplibrary::c11] + c[looplibrary::c12]) - c[looplibrary::c2])*VFin.right()*VFout.right());
  } else {
    const auto r = Power2(mF/mV);
    //if (std::max(mV,mF) > approx_limit * std::max(mi,mj)) {
      return 3. * mF/mj * VFin.left() * VFout.right() * OneLoopFunctionK(r)
             + mi/mj * VFin.left() * VFout.left() * OneLoopFunctionJ(r) / 6.
             + VFin.right() * VFout.right() * OneLoopFunctionJ(r) / 6.;  
    //}
  }          
}  


std::complex<double> FFV_VVF_A2R(double mi, double mj, double mF, double mV, auto VFin, auto VFout)
{
  const double Dim = 4.;
  // Massless emitter (in this case mV==0, mi==mj==mF) will fail
  // Massless mediator (in this case mF==0) case can be calculated
  if (mi==mj and mi==mV and mF==0) {
    return 2.*Power2(mV)*(VFin.left()*VFout.left() + VFin.right()*VFout.right()) / Power2(mi);
  } else if (not(Loop_library::get_type() == Loop_library::Library::Softsusy)) {
    std::array<std::complex<double>,C_N>c{};
    Loop_library::get().C(c,Power2(mj),0.,Power2(mi),Power2(mF),Power2(mV),Power2(mV),Power2(mV));
    return 2. * Power2(mV) / mj * (
             mj*(c[looplibrary::c2] - (Dim-4.)*c[looplibrary::c1] - (Dim-2.)*(c[looplibrary::c11]+c[looplibrary::c12]))*VFin.left()*VFout.left()
           + mF*((Dim-4.)*c[looplibrary::c0] + (Dim-1.)*(c[looplibrary::c1] + c[looplibrary::c2]))*VFin.right()*VFout.left()
           + mi*(c[looplibrary::c1] - (Dim-4.)*c[looplibrary::c2] - (Dim-2.)*(c[looplibrary::c12]+c[looplibrary::c22]))*VFin.right()*VFout.right());
  } else {
    const auto r = Power2(mF/mV);
    //if (std::max(mV,mF) > approx_limit * std::max(mi,mj)) {
      return 3. * mF/mj * VFin.right() * VFout.left() * OneLoopFunctionK(r)
             + mi/mj * VFin.right() * VFout.right() * OneLoopFunctionJ(r) / 6.
             + VFin.left() * VFout.left() * OneLoopFunctionJ(r) / 6.;   
    //}
  }
}


std::complex<double> FFV_FFV_A1L(double mi, double mj, double mF, double mV, auto VFin, auto VFout)
{
    const auto r = Power2(mF/mV);
    //if (std::max(mF,mV) > approx_limit * std::max(mi,mj)) {
    return   VFin.left() * VFout.left() * OneLoopFunctionL(r) / 9. 
           - mi/mj * VFin.right() * VFout.right() * OneLoopFunctionL(r) / 9.;   
    //}
}

std::complex<double> FFV_FFV_A1R(double mi, double mj, double mF, double mV, auto VFin, auto VFout)
{
    const auto r = Power2(mF/mV);
    return   VFin.right() * VFout.right() * OneLoopFunctionL(r) / 9.
           - mi/mj * VFin.left() * VFout.left() * OneLoopFunctionL(r) / 9.;  
}

std::complex<double> FFV_FFV_A2L(double mi, double mj, double mF, double mV, auto VFin, auto VFout)
{
  const double Dim = 4.;
  if (not(Loop_library::get_type() == Loop_library::Library::Softsusy)) {
    std::array<std::complex<double>,C_N>c{};
    Loop_library::get().C(c,Power2(mj),0.,Power2(mi),Power2(mV),Power2(mF),Power2(mF),Power2(mF));
    return -2. * Power2(mV) / mj * (
             mi*(2*c[looplibrary::c0] + 2*c[looplibrary::c1] + (Dim-2.)*c[looplibrary::c12] + Dim*c[looplibrary::c2] + (Dim-2.)*c[looplibrary::c22])*VFin.left()*VFout.left() 
           - mF*(4*c[looplibrary::c0] + Dim*(c[looplibrary::c1] + c[looplibrary::c2]))*VFin.left()*VFout.right() + 
             mj*(2*c[looplibrary::c0] + Dim*c[looplibrary::c1] + (Dim-2.)*c[looplibrary::c11] + (Dim-2.)*c[looplibrary::c12] + 2*c[looplibrary::c2])*VFin.right()*VFout.right());
  } else {
    const auto r = Power2(mF/mV);
    //if (std::max(mF,mV) > approx_limit * std::max(mi,mj)) {
      return - 4. * mF/mj * VFin.left() * VFout.right() * OneLoopFunctionC(r) / 3.
             + mi/mj * VFin.left() * VFout.left() * OneLoopFunctionM(r) / 3.
             + VFin.right() * VFout.right() * OneLoopFunctionM(r) / 3.; 
    //}
  }
}

std::complex<double> FFV_FFV_A2R(double mi, double mj, double mF, double mV, auto VFin, auto VFout)
{
  const double Dim = 4.;
  if (not(Loop_library::get_type() == Loop_library::Library::Softsusy)) {
    std::array<std::complex<double>,C_N>c{};
    Loop_library::get().C(c,Power2(mi),0.,Power2(mj),Power2(mV),Power2(mF),Power2(mF),Power2(mF));
    return -2. * Power2(mV) / mj * (
             mj*(2*c[looplibrary::c0] + Dim*c[looplibrary::c1] + (Dim-2.)*c[looplibrary::c11] + (Dim-2.)*c[looplibrary::c12] + 2*c[looplibrary::c2])*VFin.left()*VFout.left() 
           - mF*(4*c[looplibrary::c0] + Dim*(c[looplibrary::c1] + c[looplibrary::c2]))*VFin.right()*VFout.left() 
           + mi*(2*c[looplibrary::c0] + 2*c[looplibrary::c1] +(Dim-2.)*c[looplibrary::c12] + Dim*c[looplibrary::c2] + (Dim-2.)*c[looplibrary::c22])*VFin.right()*VFout.right());
  } else {
    const auto r = Power2(mF/mV);
    //if (std::max(mF,mV) > approx_limit * std::max(mi,mj)) {
      return - 4. * mF/mj * VFin.right() * VFout.left() * OneLoopFunctionC(r) / 3.
             + mi/mj * VFin.right() * VFout.right() * OneLoopFunctionM(r) / 3.
             + VFin.left() * VFout.left() * OneLoopFunctionM(r) / 3.;
    //}
  }
}


std::complex<double> FFV_VSF_A1L(double mi, double mj, double mF, double mV, double mG, auto VFin, auto SFout)
{
  if (is_zero(-mG + mV)) {
    const auto r = Power2(mF/mV);
      if (std::max(mV,mF) > approx_limit * std::max(mi,mj)) {
        return -1./mj * VFin.right() * SFout.right() * OneLoopFunctionN(r,r) / mV;
    } 
    } else {
    const auto r = Power2(mF/mV);
    const auto s = Power2(mF/mG);
      if (std::max(std::max(mV,mG),mF) > approx_limit * std::max(mi,mj)) {
        return -1./mj * VFin.right() * SFout.right() * OneLoopFunctionN(r,s) / mV;
      }
  }        
}

std::complex<double> FFV_VSF_A1R(double mi, double mj, double mF, double mV, double mG, auto VFin, auto SFout)
{
  if (is_zero(-mG + mV)) {
    const auto r = Power2(mF/mV);
      if (std::max(mV,mF) > approx_limit * std::max(mi,mj)) {
        return -1./mj * VFin.left() * SFout.left() * OneLoopFunctionN(r,r) / mV;
        }
    } else {
    const auto r = Power2(mF/mV);
    const auto s = Power2(mF/mG);
      if (std::max(std::max(mV,mG),mF) > approx_limit * std::max(mi,mj)) {
        return -1./mj * VFin.left() * SFout.left() * OneLoopFunctionN(r,s) / mV;
      } 
  }        
} 

std::complex<double> FFV_VSF_A2L(double mi, double mj, double mF, double mV, double mG, auto VFin, auto SFout)
{
  if ((mi == mj) and (mi == mF) and (mV == 0) and (mG == 0)) {
    return mV*mV;
  } else if (not(Loop_library::get_type() == Loop_library::Library::Softsusy)) {
    std::array<std::complex<double>,C_N>c{};
    Loop_library::get().C(c,Power2(mj),0.,Power2(mi),Power2(mF),Power2(mV),Power2(mG),std::max(Power2(mG),Power2(mV)));
    return 2. * Power2(mV) / mj * (c[looplibrary::c1] * SFout.left() * VFin.left());
  } else {
    const auto r = Power2(mF/mV);
    const auto s = Power2(mF/mG);
    //if (std::max(std::max(mV,mG),mF) > approx_limit * std::max(mi,mj)) {
      return  1. / mj * VFin.left() * SFout.left() * OneLoopFunctionN(r,s);
    //}
  }
}

std::complex<double> FFV_VSF_A2R(double mi, double mj, double mF, double mV, double mG, auto VFin, auto SFout)
{
  if ((mi == mj) and (mi == mF) and (mV == 0) and (mG == 0)) {
    return mV*mV; 
  } else if (not(Loop_library::get_type() == Loop_library::Library::Softsusy)) {
    std::array<std::complex<double>,C_N>c{};
    Loop_library::get().C(c,Power2(mj),0.,Power2(mi),Power2(mF),Power2(mV),Power2(mG),std::max(Power2(mG),Power2(mV)));
    return 2. * Power2(mV) / mj * (c[looplibrary::c1] * SFout.right() * VFin.right());
  } else {  
    const auto r = Power2(mF/mV);
    const auto s = Power2(mF/mG);
    //if (std::max(std::max(mV,mG),mF) > approx_limit * std::max(mi,mj)) {
      return 1. / mj * VFin.right() * SFout.right() * OneLoopFunctionN(r,s);
    //}
  }
}

std::complex<double> FFV_SVF_A1L(double mi, double mj, double mF, double mV, double mG, auto SFin, auto VFout)
{
  if (is_zero(-mG + mV)) {
  } else {
    if (is_zero(mF)) {
    } else {
    const auto r = Power2(mF/mV);
    const auto s = Power2(mF/mG);
      if (std::max(std::max(mV,mG),mF) > approx_limit * std::max(mi,mj)) {
        return 1./mj * SFin.right() * VFout.left() * OneLoopFunctionN(r,s) / mV;// / 2.;
      }
    }
  }
} 

std::complex<double> FFV_SVF_A1R(double mi, double mj, double mF, double mV, double mG, auto SFin, auto VFout)
{
  if (is_zero(-mG + mV)) {
  } else {
    if (is_zero(mF)) {
    } else {
    const auto r = Power2(mF/mV);
    const auto s = Power2(mF/mG);
      if (std::max(std::max(mV,mG),mF) > approx_limit * std::max(mi,mj)) {
        return 1./mj * SFin.left() * VFout.right() * OneLoopFunctionN(r,s) / mV;// / 2.;
      }
    }
  }        
} 

std::complex<double> FFV_SVF_A2L(double mi, double mj, double mF, double mV, double mG, auto SFin, auto VFout)
{
  if ((mi == mj) and (mi == mF) and (mV == 0) and (mG == 0)) {
    return mV*mV;
  } else if (not(Loop_library::get_type() == Loop_library::Library::Softsusy)) {
    std::array<std::complex<double>,C_N>c{};
    Loop_library::get().C(c,Power2(mi),0.,Power2(mj),Power2(mF),Power2(mG),Power2(mV),std::max(Power2(mG),Power2(mV)));
    return 2. * Power2(mV) / mj * (c[looplibrary::c2]*SFin.left()*VFout.right());
  } else {
    const auto r = Power2(mF/mV);
    const auto s = Power2(mF/mG);
    //if (std::max(std::max(mV,mG),mF) > approx_limit * std::max(mi,mj)) {
        return 1. / mj * SFin.left() * VFout.right() * OneLoopFunctionN(r,s);
    //}
  }
} 

std::complex<double> FFV_SVF_A2R(double mi, double mj, double mF, double mV, double mG, auto SFin, auto VFout)
{
  if ((mi == mj) and (mi == mF) and (mV == 0) and (mG == 0)) {
    return mV*mV; 
  } else if (not(Loop_library::get_type() == Loop_library::Library::Softsusy)) {
    std::array<std::complex<double>,C_N>c{};
    Loop_library::get().C(c,Power2(mi),0.,Power2(mj),Power2(mF),Power2(mG),Power2(mV),std::max(Power2(mG),Power2(mV)));
    return 2. * Power2(mV) / mj * (c[looplibrary::c2]*SFin.right()*VFout.left());
  } else {
    const auto r = Power2(mF/mV);
    const auto s = Power2(mF/mG);
    //if (std::max(std::max(mV,mG),mF) > approx_limit * std::max(mi,mj)) {
        return 1. / mj * SFin.right() * VFout.left() * OneLoopFunctionN(r,s);
    //}
  }
} 


/**
* @defgroup FFVContributions FFV diagram massless photon contributions
* @brief Contributions to the processes Fe_I -> Fe_J gamma at the one-loop level.
*
* Diagram contributions are of the form:
* \Gamma^\mu = gamma^\mu F1 + I sigma^\mu\nu (p-pp)_\nu / (2*mj) F2
*                A1L gamma^\mu P_L + A1R gamma^\mu P_R 
*              + A2L I sigma^\mu\nu (p-pp)_\nu / (2*mj) P_L
*              + A2R I sigma^\mu\nu (p-pp)_\nu / (2*mj) P_R 
*/


// emit massless vector boson from the internal scalar line
template <class Fj, class Fi, class V, class SA, class SB, class F>
std::valarray<std::complex<double>> FFV_SSF<Fj, Fi, V, SA, SB, F>::value(
   const typename field_indices<Fj>::type& indices_in,
   const typename field_indices<Fi>::type& indices_out,
   context_base const& context,
   bool discard_SM_contributions)
{

   static_assert(
      std::is_same<SA, SB>::type::value,
      "Internal scalars in the FFV_SSF instantiation must be of the same type."
   );

   using VertexFBarFjSBar = Vertex<typename F::lorentz_conjugate, typename SA::lorentz_conjugate, Fj>;
   using VertexFiBarFS    = Vertex<typename Fi::lorentz_conjugate, SB, F>;
   using VertexSBarSVBar  = Vertex<typename SB::lorentz_conjugate, SA, typename V::lorentz_conjugate>;

   // masses of external fermions
   const auto mj = context.mass<Fj>(indices_in);
   const auto mi = context.mass<Fi>(indices_out);

   // loop over all possible particle generations attached to both vertices
   std::valarray<std::complex<double>> res {0.0, 0.0, 0.0, 0.0};
   for (const auto& indexIn: index_range<VertexFBarFjSBar>()) {
      for (const auto& indexOut: index_range<VertexFiBarFS>()) {

         // cycle if generations of external fermions  are different then requested
         const auto jFieldIndices = VertexFBarFjSBar::template indices_of_field<2>(indexIn);
         const auto iFieldIndices = VertexFiBarFS::template indices_of_field<0>(indexOut);
         if (jFieldIndices != indices_in || iFieldIndices != indices_out)
            continue;

         // match indices of the fermion in the loop
         const auto fermionFieldIndicesIn = VertexFBarFjSBar::template indices_of_field<0>(indexIn);
         const auto fermionFieldIndicesOut = VertexFiBarFS::template indices_of_field<2>(indexOut);
         if (fermionFieldIndicesIn != fermionFieldIndicesOut)
            continue;

         // match indices of the scalar in the loop
         const auto scalarFieldIndicesIn = VertexFBarFjSBar::template indices_of_field<1>(indexIn);
         const auto scalarIndicesOut = VertexFiBarFS::template indices_of_field<1>(indexOut);
         if (scalarFieldIndicesIn != scalarIndicesOut)
            continue;

         if (discard_SM_contributions) {
            if (isSMField<SA>(scalarFieldIndicesIn) && isSMField<F>(fermionFieldIndicesIn)) {
               continue;
            }
         }

         const auto vertexIn = VertexFBarFjSBar::evaluate(indexIn, context);
         const auto vertexOut = VertexFiBarFS::evaluate(indexOut, context);

         const auto indexEmit = concatenate(scalarFieldIndicesIn, scalarFieldIndicesIn);
         const auto vertexEmit = VertexSBarSVBar::evaluate(indexEmit, context);

         const auto mS = context.mass<SA>(scalarFieldIndicesIn);
         const auto mF = context.mass<F>(fermionFieldIndicesIn);
         const auto x = Power2(mF/mS);
         const auto oneLoopFunctionA = OneLoopFunctionA(x);

         // TODO: check the sign convention of this coupling
         std::complex<double> vector_boson_coupling {-vertexEmit.value(1,0)}; 

         // eq. 15 of hep-ph/9510309 (possibly with different sign)
         const std::complex<double> A1L = - 1./18. * vertexOut.right() * vertexIn.left() * oneLoopFunctionA;
         const std::complex<double> A2L = FFV_SSF_A2L(mi, mj, mF, mS, vertexIn, vertexOut);

         // eq. 15 of hep-ph/9510309 after replacement L <-> R (possibly with different sign)
         const std::complex<double> A1R = - 1./18. * vertexOut.left() * vertexIn.right() * oneLoopFunctionA;
         const std::complex<double> A2R = FFV_SSF_A2R(mi, mj, mF, mS, vertexIn, vertexOut);

         const std::complex<double> massFactor = 1.0/Power2(mS);

         res += oneOver32PiSqr * vector_boson_coupling * massFactor
            * std::valarray<std::complex<double>> {A1L, A1R, A2L, A2R};
      }
   }

   return res;
}

// emit massless vector boson from the internal fermion line
template <class Fj, class Fi, class V, class FA, class FB, class S>
std::valarray<std::complex<double>> FFV_FFS<Fj, Fi, V, FA, FB, S>::value(
   const typename field_indices<Fj>::type& indices_in,
   const typename field_indices<Fi>::type& indices_out,
   context_base const& context,
   bool discard_SM_contributions)
{

   static_assert(
      std::is_same<FA, FB>::type::value,
      "Internal fermions in the FFV_FFS instantiation must be of the same type."
   );

   using VertexFBarFjSBar = Vertex<typename S::lorentz_conjugate, typename FA::lorentz_conjugate, Fj>;
   using VertexFiBarFS    = Vertex<typename Fi::lorentz_conjugate, FB, S>;
   using VertexFBarFVBar  = Vertex<typename FB::lorentz_conjugate, FA, typename V::lorentz_conjugate>;

   // masses of external fermions
   const auto mj = context.mass<Fj>(indices_in);
   const auto mi = context.mass<Fi>(indices_out);

   // loop over all possible particle generations attached to both vertices
   std::valarray<std::complex<double>> res {0.0, 0.0, 0.0, 0.0};
   for (const auto& indexIn: index_range<VertexFBarFjSBar>()) {
      for (const auto& indexOut: index_range<VertexFiBarFS>()) {

         // cycle if generations of external fermions are different then requested
         const auto jFieldIndices = VertexFBarFjSBar::template indices_of_field<2>(indexIn);
         const auto iFieldIndices = VertexFiBarFS::template indices_of_field<0>(indexOut);
         if (jFieldIndices != indices_in || iFieldIndices != indices_out)
            continue;

         const auto fermionFieldIndicesIn = VertexFBarFjSBar::template indices_of_field<1>(indexIn);
         const auto fermionFieldIndicesOut = VertexFiBarFS::template indices_of_field<1>(indexOut);
         if (fermionFieldIndicesIn != fermionFieldIndicesOut )
            continue;

         const auto scalarFieldIndicesIn = VertexFBarFjSBar::template indices_of_field<0>(indexIn);
         const auto scalarIndicesOut = VertexFiBarFS::template indices_of_field<2>(indexOut);
         if (scalarFieldIndicesIn != scalarIndicesOut)
            continue;

         if (discard_SM_contributions) {
            if (isSMField<S>(scalarFieldIndicesIn) && isSMField<FA>(fermionFieldIndicesIn)) {
               continue;
            }
         }

         const auto vertexIn = VertexFBarFjSBar::evaluate(indexIn, context);
         const auto vertexOut = VertexFiBarFS::evaluate(indexOut, context);

         const auto indexEmit = concatenate(fermionFieldIndicesIn, fermionFieldIndicesIn);
         const auto vertexEmit = VertexFBarFVBar::evaluate(indexEmit, context);

         const auto mF = context.mass<FA>(fermionFieldIndicesIn);
         const auto mS = context.mass<S>(scalarFieldIndicesIn);
         const auto x = Power2(mF/mS);
         const auto oneLoopFunctionD = OneLoopFunctionD(x);
         const auto oneLoopFunctionE = OneLoopFunctionE(x);
         const auto oneLoopFunctionF = OneLoopFunctionF(x);

         std::complex<double> vector_boson_coupling {vertexEmit.left()};

         // eq. 18 of hep-ph/9510309 (possibly with different sign)
         const std::complex<double> A1L =
            - 1./18. * vertexOut.right() * vertexIn.left() * oneLoopFunctionD;
         // eq. 19 of hep-ph/9510309 (possibly with different sign)
         const std::complex<double> A2L =
            - vertexOut.left() * vertexIn.right() * oneLoopFunctionE/12.0
            - vertexOut.left()* vertexIn.left() * mF/mj * oneLoopFunctionF * 2./3.
            - mi/mj * vertexOut.right() * vertexIn.left() * oneLoopFunctionE/12.0;

         // eq. 18 & 18 of hep-ph/9510309 after replacement L <-> R (possibly with different sign)
         const std::complex<double> A1R =
            - 1./18. * vertexOut.left() * vertexIn.right() * oneLoopFunctionD;
         const std::complex<double> A2R =
            - vertexOut.right() * vertexIn.left() * oneLoopFunctionE/12.0
            - vertexOut.right()* vertexIn.right() * mF/mj * oneLoopFunctionF * 2./3.
            - mi/mj * vertexOut.left() * vertexIn.right() * oneLoopFunctionE/12.0;

         const std::complex<double> massFactor = 1.0/Power2(mS);

         res += oneOver32PiSqr * vector_boson_coupling * massFactor
            * std::valarray<std::complex<double>> {A1L, A1R, A2L, A2R};
      }
   }

   return res;
}

// emit massless vector boson from the internal vector line in a fermion-vector loop
template <class Fj, class Fi, class P, class VA, class VB, class F>
std::valarray<std::complex<double>> FFV_VVF<Fj, Fi, P, VA, VB, F>::value(
   const typename field_indices<Fj>::type& indices_in,
   const typename field_indices<Fi>::type& indices_out,
   context_base const& context,
   bool discard_SM_contributions)
{

   static_assert(
       std::is_same<VA, VB>::type::value,
       "Internal vectors in the FFV_VVF instantiation must be of the same type."
   );

   // use P for external massless vector so as not to confuse with the internal vectors
   using VertexFBarFjVBar = Vertex<typename F::lorentz_conjugate, typename VA::lorentz_conjugate, Fj>;
   using VertexFiBarFV = Vertex<typename Fi::lorentz_conjugate, VB, F>;
   using VertexVBarVPBar = Vertex<typename VB::lorentz_conjugate, VA, typename P::lorentz_conjugate>;

   // masses of external fermions
   const auto mj = context.mass<Fj>(indices_in);
   const auto mi = context.mass<Fi>(indices_out);

   // loop over all possible particle generations attached to both vertices
   std::valarray<std::complex<double>> res {0.0, 0.0, 0.0, 0.0};
   for (const auto& indexIn: index_range<VertexFBarFjVBar>()) {
      for (const auto& indexOut: index_range<VertexFiBarFV>()) {
          
         // cycle if generations of external fermions are different then requested
         const auto jFieldIndices = VertexFBarFjVBar::template indices_of_field<2>(indexIn);
         const auto iFieldIndices = VertexFiBarFV::template indices_of_field<0>(indexOut);
         if (jFieldIndices != indices_in || iFieldIndices != indices_out)
            continue;
         
         // match indices of the fermion in the loop
         const auto fermionFieldIndicesIn = VertexFBarFjVBar::template indices_of_field<0>(indexIn);
         const auto fermionFieldIndicesOut = VertexFiBarFV::template indices_of_field<2>(indexOut);
         if (fermionFieldIndicesIn != fermionFieldIndicesOut)
            continue;

         // match indices of the vector in the loop
         const auto vectorFieldIndicesIn = VertexFBarFjVBar::template indices_of_field<1>(indexIn);
         const auto vectorFieldIndicesOut = VertexFiBarFV::template indices_of_field<1>(indexOut);
         if (vectorFieldIndicesIn != vectorFieldIndicesOut)
            continue;

         // ignore contribution if both vector and fermion are SM particles
         if (discard_SM_contributions) {
            if (isSMField<VA>(vectorFieldIndicesIn) && isSMField<F>(fermionFieldIndicesIn)) {
               continue;
            }
         }

         const auto vertexIn = VertexFBarFjVBar::evaluate(indexIn, context);
         const auto vertexOut = VertexFiBarFV::evaluate(indexOut, context);

         const auto indexEmit = concatenate(vectorFieldIndicesIn, vectorFieldIndicesIn);
         const auto vertexEmit = VertexVBarVPBar::evaluate(indexEmit, context);

         const auto mV = context.mass<VA>(vectorFieldIndicesIn);
         const auto mF = context.mass<F>(fermionFieldIndicesIn);

         // triple gauge boson vertex
         // need to check that the sign and function call are correct
         std::complex<double> vector_boson_coupling {-vertexEmit.value( TripleVectorVertex::even_permutation{} )};

         const std::complex<double> A1L = FFV_VVF_A1L(mi, mj, mF, mV, vertexIn, vertexOut);
         const std::complex<double> A2L = FFV_VVF_A2L(mi, mj, mF, mV, vertexIn, vertexOut);
         
         const std::complex<double> A1R = FFV_VVF_A1R(mi, mj, mF, mV, vertexIn, vertexOut);
         const std::complex<double> A2R = FFV_VVF_A2R(mi, mj, mF, mV, vertexIn, vertexOut);

         const std::complex<double> massFactor = 1.0/Power2(mV);

         res += oneOver32PiSqr * vector_boson_coupling * massFactor * std::valarray<std::complex<double>> {A1L,A1R,A2L,A2R};
      }
   }

   return res;

}

// emit massless vector boson from the internal vector line in a fermion-vector loop
template <class Fj, class Fi, class P, class FA, class FB, class V>
std::valarray<std::complex<double>> FFV_FFV<Fj, Fi, P, FA, FB, V>::value(
   const typename field_indices<Fj>::type& indices_in,
   const typename field_indices<Fi>::type& indices_out,
   context_base const& context,
   bool discard_SM_contributions)
{

   static_assert(
      std::is_same<FA, FB>::type::value,
      "Internal fermions in the FFV_FFV instantiation must be of the same type."
   );

   // use P for external massless vector so as not to confuse with the internal vectors
   using VertexFBarFjVBar = Vertex<typename V::lorentz_conjugate, typename FA::lorentz_conjugate, Fj>;
   using VertexFiBarFV = Vertex<typename Fi::lorentz_conjugate, FB, V>;
   using VertexFBarFPBar = Vertex<typename FB::lorentz_conjugate, FA, typename P::lorentz_conjugate>;

   // masses of external fermions
   const auto mj = context.mass<Fj>(indices_in);
   const auto mi = context.mass<Fi>(indices_out);

   // loop over all possible particle generations attached to both vertices
   std::valarray<std::complex<double>> res {0.0, 0.0, 0.0, 0.0};
   for (const auto& indexIn: index_range<VertexFBarFjVBar>()) {
      for (const auto& indexOut: index_range<VertexFiBarFV>()) {
           
         // cycle if generations of external fermions are different then requested
         const auto jFieldIndices = VertexFBarFjVBar::template indices_of_field<2>(indexIn);
         const auto iFieldIndices = VertexFiBarFV::template indices_of_field<0>(indexOut);
         if (jFieldIndices != indices_in || iFieldIndices != indices_out)
            continue;

         // match indices of the fermion in the loop
         const auto fermionFieldIndicesIn = VertexFBarFjVBar::template indices_of_field<1>(indexIn);
         const auto fermionFieldIndicesOut = VertexFiBarFV::template indices_of_field<1>(indexOut);
         if (fermionFieldIndicesIn != fermionFieldIndicesOut)
            continue;

         // match indices of the vector in the loop
         const auto vectorFieldIndicesIn = VertexFBarFjVBar::template indices_of_field<0>(indexIn);
         const auto vectorFieldIndicesOut = VertexFiBarFV::template indices_of_field<2>(indexOut);
         if (vectorFieldIndicesIn != vectorFieldIndicesOut)
            continue;

         // ignore contribution if both vector and fermion are SM particles
         if (discard_SM_contributions) {
            if (isSMField<FA>(fermionFieldIndicesIn) && isSMField<V>(vectorFieldIndicesIn)) {
               continue;
            }
         }

         const auto vertexIn = VertexFBarFjVBar::evaluate(indexIn, context);
         const auto vertexOut = VertexFiBarFV::evaluate(indexOut, context);

         const auto indexEmit = concatenate(fermionFieldIndicesIn, fermionFieldIndicesIn);
         const auto vertexEmit = VertexFBarFPBar::evaluate(indexEmit, context);

         const auto mV = context.mass<V>(vectorFieldIndicesIn);
         const auto mF = context.mass<FA>(fermionFieldIndicesIn);

         std::complex<double> vector_boson_coupling {vertexEmit.left()};

         const std::complex<double> A1L = FFV_FFV_A1L(mi, mj, mF, mV, vertexIn, vertexOut);
         const std::complex<double> A2L = FFV_FFV_A2L(mi, mj, mF, mV, vertexIn, vertexOut);

         const std::complex<double> A1R = FFV_FFV_A1R(mi, mj, mF, mV, vertexIn, vertexOut);
         const std::complex<double> A2R = FFV_FFV_A2R(mi, mj, mF, mV, vertexIn, vertexOut);

         std::complex<double> massFactor = 1.0/Power2(mV);

         res += oneOver32PiSqr * vector_boson_coupling * massFactor * std::valarray<std::complex<double>> {A1L,A1R,A2L,A2R};
      }
   }

   return res;

}

// emit massless vector boson from the internal vector line in a fermion-vector loop
template <class Fj, class Fi, class P, class VA, class GB, class F>
std::valarray<std::complex<double>> FFV_VSF<Fj, Fi, P, VA, GB, F>::value(
   const typename field_indices<Fj>::type& indices_in,
   const typename field_indices<Fi>::type& indices_out,
   context_base const& context,
   bool discard_SM_contributions)
{

   // do not assert that VA and GB are the same
   // static_assert(
   //     std::is_same<VA, GB>::type::value,
   //     "Internal vectors in the FFV_VGF instantiation must be of the same type."
   // );

   // use P for external massless vector so as not to confuse with the internal vectors
   using VertexFBarFjVBar = Vertex<typename F::lorentz_conjugate, typename VA::lorentz_conjugate, Fj>;
   using VertexFiBarFG = Vertex<typename Fi::lorentz_conjugate, GB, F>;
   using VertexGBarVPBar = Vertex<typename GB::lorentz_conjugate, VA, typename P::lorentz_conjugate>;

   // masses of external fermions
   const auto mj = context.mass<Fj>(indices_in);
   const auto mi = context.mass<Fi>(indices_out);

   // loop over all possible particle generations attached to both vertices
   std::valarray<std::complex<double>> res {0.0, 0.0, 0.0, 0.0};
   for (const auto& indexIn: index_range<VertexFBarFjVBar>()) {
      for (const auto& indexOut: index_range<VertexFiBarFG>()) {
          
         // cycle if generations of external fermions are different then requested
         const auto jFieldIndices = VertexFBarFjVBar::template indices_of_field<2>(indexIn);
         const auto iFieldIndices = VertexFiBarFG::template indices_of_field<0>(indexOut);
         if (jFieldIndices != indices_in || iFieldIndices != indices_out)
            continue;
         
         // match indices of the fermion in the loop
         const auto fermionFieldIndicesIn = VertexFBarFjVBar::template indices_of_field<0>(indexIn);
         const auto fermionFieldIndicesOut = VertexFiBarFG::template indices_of_field<2>(indexOut);
         if (fermionFieldIndicesIn != fermionFieldIndicesOut)
            continue;

         // cannot match indices if scalar is not would-be-goldstone corresponding to vector
         const auto vectorFieldIndicesIn = VertexFBarFjVBar::template indices_of_field<1>(indexIn);
         const auto goldstoneFieldIndicesOut = VertexFiBarFG::template indices_of_field<1>(indexOut);
         // if (vectorFieldIndicesIn != goldstoneFieldIndicesOut)
         //   continue;

         // ignore contribution if both vector and fermion are SM particles
         if (discard_SM_contributions) {
            if (isSMField<VA>(vectorFieldIndicesIn) && isSMField<GB>(goldstoneFieldIndicesOut) && isSMField<F>(fermionFieldIndicesIn)) {
               continue;
            }
         }

         const auto vertexIn = VertexFBarFjVBar::evaluate(indexIn, context);
         const auto vertexOut = VertexFiBarFG::evaluate(indexOut, context);

         const auto indexEmit = concatenate(vectorFieldIndicesIn, goldstoneFieldIndicesOut);
         const auto vertexEmit = VertexGBarVPBar::evaluate(indexEmit, context);

         const auto mV = context.mass<VA>(vectorFieldIndicesIn);
         const auto mG = context.mass<GB>(goldstoneFieldIndicesOut);
         const auto mF = context.mass<F>(fermionFieldIndicesIn);

         // scalar-vector-vector vertex
         // check that definition and sign is correct
         std::complex<double> vector_boson_coupling {-vertexEmit.value()};

         const std::complex<double> A1L = FFV_VSF_A1L(mi, mj, mF, mV, mG, vertexIn, vertexOut);
         const std::complex<double> A2L = FFV_VSF_A2L(mi, mj, mF, mV, mG, vertexIn, vertexOut);
      
         const std::complex<double> A1R = FFV_VSF_A1R(mi, mj, mF, mV, mG, vertexIn, vertexOut);
         const std::complex<double> A2R = FFV_VSF_A2R(mi, mj, mF, mV, mG, vertexIn, vertexOut);

         const std::complex<double> massFactor = 1.0/mV;
          
         res += oneOver32PiSqr * vector_boson_coupling * massFactor * std::valarray<std::complex<double>> {A1L,A1R,A2L,A2R};
      }
   }

   return res;

}

// emit massless vector boson from the internal vector line in a fermion-vector loop
template <class Fj, class Fi, class P, class GA, class VB, class F>
std::valarray<std::complex<double>> FFV_SVF<Fj, Fi, P, GA, VB, F>::value(
   const typename field_indices<Fj>::type& indices_in,
   const typename field_indices<Fi>::type& indices_out,
   context_base const& context,
   bool discard_SM_contributions)
{

   // do not assert that GA and VB are the same
   // static_assert(
   //     std::is_same<GA, VB>::type::value,
   //     "Internal vectors in the FFV_VGF instantiation must be of the same type."
   // );

   // use P for external massless vector so as not to confuse with the internal vectors
   using VertexFBarFjGBar = Vertex<typename F::lorentz_conjugate, typename GA::lorentz_conjugate, Fj>;
   using VertexFiBarFV = Vertex<typename Fi::lorentz_conjugate, VB, F>;
   using VertexVBarGPBar = Vertex<typename VB::lorentz_conjugate, GA, typename P::lorentz_conjugate>;

   // masses of external fermions
   const auto mj = context.mass<Fj>(indices_in);
   const auto mi = context.mass<Fi>(indices_out);

   // loop over all possible particle generations attached to both vertices
   std::valarray<std::complex<double>> res {0.0, 0.0, 0.0, 0.0};
   for (const auto& indexIn: index_range<VertexFBarFjGBar>()) {
      for (const auto& indexOut: index_range<VertexFiBarFV>()) {
          
         // cycle if generations of external fermions are different then requested
         const auto jFieldIndices = VertexFBarFjGBar::template indices_of_field<2>(indexIn);
         const auto iFieldIndices = VertexFiBarFV::template indices_of_field<0>(indexOut);
         if (jFieldIndices != indices_in || iFieldIndices != indices_out)
            continue;
         
         // match indices of the fermion in the loop
         const auto fermionFieldIndicesIn = VertexFBarFjGBar::template indices_of_field<0>(indexIn);
         const auto fermionFieldIndicesOut = VertexFiBarFV::template indices_of_field<2>(indexOut);
         if (fermionFieldIndicesIn != fermionFieldIndicesOut)
            continue;

         // cannot match indices if scalar is not would-be-goldstone corresponding to vector
         const auto goldstoneFieldIndicesIn = VertexFBarFjGBar::template indices_of_field<1>(indexIn);
         const auto vectorFieldIndicesOut = VertexFiBarFV::template indices_of_field<1>(indexOut);
         // if (goldstoneFieldIndicesIn != vectorFieldIndicesOut)
         //    continue;

         // ignore contribution if both vector and fermion are SM particles
         if (discard_SM_contributions) {
            if (isSMField<GA>(goldstoneFieldIndicesIn) && isSMField<VB>(vectorFieldIndicesOut) && isSMField<F>(fermionFieldIndicesIn)) {
               continue;
            }
         }
   
         const auto vertexIn = VertexFBarFjGBar::evaluate(indexIn, context);
         const auto vertexOut = VertexFiBarFV::evaluate(indexOut, context);

         const auto indexEmit = concatenate(goldstoneFieldIndicesIn, vectorFieldIndicesOut);
         const auto vertexEmit = VertexVBarGPBar::evaluate(indexEmit, context);
   
         const auto mV = context.mass<GA>(goldstoneFieldIndicesIn);
         const auto mG = context.mass<VB>(vectorFieldIndicesOut);
         const auto mF = context.mass<F>(fermionFieldIndicesIn);

         // scalar-vector-vector vertex
         // check that definition and sign is correct
         std::complex<double> vector_boson_coupling {-vertexEmit.value()};

         const std::complex<double> A1L = FFV_SVF_A1L(mi, mj, mF, mV, mG, vertexIn, vertexOut);
         const std::complex<double> A2L = FFV_SVF_A2L(mi, mj, mF, mV, mG, vertexIn, vertexOut);
      
         const std::complex<double> A1R = FFV_SVF_A1R(mi, mj, mF, mV, mG, vertexIn, vertexOut);
         const std::complex<double> A2R = FFV_SVF_A2R(mi, mj, mF, mV, mG, vertexIn, vertexOut);

         const std::complex<double> massFactor = 1.0/mV;
          
         res += oneOver32PiSqr * vector_boson_coupling * massFactor * std::valarray<std::complex<double>> {A1L,A1R,A2L,A2R};
      }
   }

   return res;

}


} // anonymous namespace
