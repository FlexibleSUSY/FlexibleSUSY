// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================


/**
 * @file @ModelName@_decays.cpp
 * @brief implementation of particle decays in the @ModelName@
 *
 * Contains the definition of @ModelName@ decays class methods,
 * which calculate the decay rates for particles in the model.
 *
 * This file was generated with FlexibleSUSY @FlexibleSUSYVersion@ and SARAH @SARAHVersion@ .
 */

#include <cmath>

#include <boost/range/algorithm.hpp>
#define BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS
#define BOOST_MPL_LIMIT_LIST_SIZE 50
#include <boost/mpl/for_each.hpp>
#include <boost/mpl/int.hpp>
#include <boost/mpl/at.hpp>
#include <boost/mpl/list.hpp>

#include "@ModelName@_decays.hpp"
#include "@ModelName@_info.hpp"
#include "decays/one_loop_decay_diagrams.hpp"
#include "concatenate.hpp"
#include "decays/decay_functions.hpp"
#include "dilog.hpp"
#include "trilog.hpp"
#include "Li4.hpp"
#include "config.h"
#include "thread_pool.hpp"
#include "wrappers.hpp"
#include "standard_model.hpp"
#include <gsl/gsl_monte_miser.h>

namespace flexiblesusy {

#define CLASSNAME @ModelName@_decays
#define PHYSICAL(parameter) model.get_physical().parameter

using namespace @ModelName@_cxx_diagrams;
using namespace @ModelName@_cxx_diagrams::fields;
namespace info = @ModelName@_info;
using namespace std::complex_literals;

const @ModelName@_decay_table& CLASSNAME::get_decay_table() const
{
   return decay_table;
}

void CLASSNAME::set_loop_corrections(const Decays_loop_corrections& loop_corrections_)
{
   loop_corrections = loop_corrections_;
}

const Decays_loop_corrections& CLASSNAME::get_loop_corrections() const
{
   return loop_corrections;
}

const Decays_problems& CLASSNAME::get_problems() const
{
   return problems;
}

void CLASSNAME::clear_problems()
{
   problems.clear();
}

void CLASSNAME::clear()
{
   clear_problems();
   decay_table.clear();
}

void CLASSNAME::calculate_decays()
{
#ifdef ENABLE_THREADS
@callAllDecaysFunctionsInThreads@
#else
@callAllDecaysFunctions@
#endif
}

double get_alphas(context_base const&  context)
{
   return Sqr(context.model.get_@gs_name@())/(4.*Pi);
}

double get_alpha(context_base const&  context)
{
   return Sqr(unit_charge(context))/(4.*Pi);
}

/* 1-loop BSM amplitudes
 *
 * Notes:
 *    - Since FS removes a factor of i from every vertex we reintroduce it
 *      calls to one loop amplitudes
 */

@calcAmplitudeSpecializationDefs@

// -------- specializations for decays needing higher order SM corrections --------

@create_SM_particle_usings@

@create_BSM_particle_list@

template <typename DecayProds, typename V>
bool check_3body_Vff_decay(const context_base& context, double  mHOS, const typename field_indices<V>::type& idx)  {
   bool found_problem = false;
   const double mVOS {context.physical_mass<V>(idx)};
   boost::mpl::for_each<DecayProds>(
      [mHOS, mVOS, &idx, &context, &found_problem](auto arg) {
         using T = decltype(arg);
         using Field1 = typename boost::mpl::at<T, boost::mpl::int_<0>>::type;
         using Field2 = typename boost::mpl::at<T, boost::mpl::int_<1>>::type;
         using vertexId1 = Vertex<V, Field1, Field2>;
         for (const auto& indexId1: index_range<vertexId1>()) {
            const auto externalFieldIndicesIn1 = vertexId1::template indices_of_field<0>(indexId1);
            if (externalFieldIndicesIn1 != idx) {
               continue;
            }
            const auto externalFieldIndicesIn2 = vertexId1::template indices_of_field<1>(indexId1);
            const auto externalFieldIndicesIn3 = vertexId1::template indices_of_field<2>(indexId1);

            const double mInternal2 {context.physical_mass<Field1>(externalFieldIndicesIn2)};
            const double mInternal3 {context.physical_mass<Field2>(externalFieldIndicesIn3)};

            if (mHOS-mVOS > mInternal2 + mInternal3
                && !Vertex<V, Field1, Field2>::evaluate(indexId1, context).isZero()) {
               found_problem = true;
            }
         }
      }
   );
   return found_problem;
}

@partialWidthSpecializationDefs@

template <>
double CLASSNAME::get_partial_width<H, A, A>(
      const context_base& context,
      const typename field_indices<H>::type& in_idx,
      const typename field_indices<A>::type& out1_idx,
      const typename field_indices<A>::type& out2_idx) const
{
   const auto amp = calculate_amplitude<H, A, A>(context, in_idx, out1_idx, out2_idx);
   const double mH = context.physical_mass<H>(in_idx);
   constexpr double ps {1./(8.*Pi)};
   constexpr double ps_symmetry {1./2.};
   constexpr double color_gen_sqr = squared_color_generator<H, A, A>();
   const double flux = 0.5/mH;
   const auto res = flux * color_gen_sqr * ps * ps_symmetry * amp.square();

   return res;
}

template <>
double CLASSNAME::get_partial_width<H, A, Z>(
      const context_base& context,
      const typename field_indices<H>::type& in_idx,
      const typename field_indices<A>::type& out1_idx,
      const typename field_indices<Z>::type& out2_idx) const
{
   const double mH = context.physical_mass<H>(in_idx);
   const double mA = context.physical_mass<A>(out1_idx);
   const double mZ = context.physical_mass<Z>(out2_idx);

   const double ps {1./(8.*Pi) * sqrt(KallenLambda(1., Sqr(mA/mH), Sqr(mZ/mH)))};
   constexpr double ps_symmetry {1.};
   constexpr double color_gen_sqr = squared_color_generator<H, A, Z>();
   const double flux = 0.5/mH;

   const auto amp = calculate_amplitude<H, A, Z>(context, in_idx, out1_idx, out2_idx);

   const auto res = flux * color_gen_sqr * ps * ps_symmetry * amp.square();

   return res;
}

template <>
double CLASSNAME::get_partial_width<H, G, G>(
      const context_base& context,
      const typename field_indices<H>::type& in_idx,
      const typename field_indices<G>::type& out1_idx,
      const typename field_indices<G>::type& out2_idx) const
{
   const auto amp = calculate_amplitude<H, G, G>(context, in_idx, out1_idx, out2_idx);
   const double mH = context.physical_mass<H>(in_idx);
   constexpr double ps {1./(8.*Pi)};
   constexpr double ps_symmetry {1./2.};
   constexpr double color_fact = squared_color_generator<H, G, G>();
   const double flux = 0.5/mH;

   double result = flux * color_fact * ps * ps_symmetry * amp.square();

   // higher order corrections to CP-even Higgs
   // in models with CP-violating Higgs sector H multiplet contains
   // both H and A states, while the corrections below apply only to H.
   // Hence the if.
   if (!info::is_CP_violating_Higgs_sector) {

      // higher order QCD corrections


      const double mtpole {qedqcd.displayPoleMt()};
      const double mt {context.mass<uq>({2})};
      const double tau = Sqr(mH/(2.*mt));
      // the analytic form o corrections is valid for small tau
      if (tau < 0.7) {
         // number of active light flavours
         unsigned int Nf;
         if (mH > 5 && mH < mtpole) {
            Nf = 5;
         } else if (mH > mtpole) {
            Nf = 6;
         } else {
            throw;
         }

         const auto indices = concatenate(in_idx, std::array<int, 1> {2}, std::array<int, 1> {2});
         const auto HGGVertex = Vertex<H, bar<uq>::type, uq>::evaluate(indices, context);
         std::complex<double> const HGGVertexVal = 0.5*(HGGVertex.left() + HGGVertex.right());

         // eq. 5 of https://arxiv.org/pdf/1109.5304.pdf
         const std::complex<double> Ff = -2.*(1.+(1.-1./tau)*f(tau))/std::sqrt(tau);

         // LO width comming only from the top-loop
         // agrees up to a full double precision with autmatically generated one
         const double Gamma_SM_LO = mH  /(32.*Power3(Pi))*std::norm(get_alphas(context)*HGGVertexVal*Ff);
         std::cout << "hh " << result << ' ' << Gamma_SM_LO << ' ' << 1 - result/Gamma_SM_LO << std::endl;

         const double mu = mH;
         const double LH = std::log(Sqr(mu/mH));
         const double Lt = std::log(Sqr(mu/mt));

         // eq. 5 of 0708.0916
         const double hnlo0 =
            95./4. - 7./6.*Nf + (33 - 2*Nf)/6.*LH;
         const double hnlo1 =
            5803./540. + 77./30.*LH - 14./15.*Lt + Nf*(-29./60. - 7./45.*LH);
         const double hnlo2 =
            1029839./189000. + 16973./12600.*LH - 1543./1575.*Lt + Nf*(-89533./378000. - 1543./18900.*LH);
         const double hnlo3 =
            9075763./2976750. + 1243./1575*LH - 452./525.*Lt + Nf*(-3763./28350. - 226./4725.*LH);
         const double hnlo4 =
            50854463./27783000. + 27677./55125.*LH - 442832./606375.*Lt + Nf*(-10426231./127338750. - 55354./1819125.*LH);
         const double hnlo5 =
            252432553361./218513295000. + 730612./2149875.*LH - 2922448./4729725.*Lt + Nf*(-403722799./7449316875. - 1461224./70945875.*LH);
         const double deltaNLO {
            hnlo0 + tau*(hnlo1 + tau*(hnlo2 + tau*(hnlo3 + tau*(hnlo4 + tau*hnlo5))))
         };

         // eq. 9 of 0708.0916
         const double log_mH2OverMT2 {std::log(Sqr(mH/mtpole))};
         const double hnnlo0 =
            149533./288. - 121./16.*Sqr(Pi) - 495./8.*zeta3 + 3301./16.*LH + 363./16.*Sqr(LH) + 19./8.*Lt
            + Nf*(-4157./72. + 11./12.*Sqr(Pi) + 5./4.*zeta3 - 95./4.*LH - 11./4.*Sqr(LH) + 2./3.*Lt)
            + Sqr(Nf)*(127./108. - Sqr(Pi)/36. + 7./12.*LH + Sqr(LH)/12);
         const double hnnlo1 =
            104358341./1555200. - 847./240*Sqr(Pi) + 7560817./69120.*zeta3 + LH*(203257./2160. - 77./15.*Lt) + 847./80.*Sqr(LH)
            - 24751./1080.*Lt - 77./180.*Sqr(Lt) + Nf*(-9124273./388800. + 77./180.*Sqr(Pi) + 7./12.*zeta3 + LH*(-67717./6480.
                     + 14./45*Lt) - 77./60.*Sqr(LH) + 586./405.*Lt + 7./90.*Sqr(Lt)) + Sqr(Nf)*(5597./12960. - 7./540.*Sqr(Pi) + 29./120.*LH
                     + 7./180.*Sqr(LH));
         const double hnnlo2 =
            -1279790053883./12192768000. - 186703./100800.*Sqr(Pi) + 39540255113./232243200.*zeta3 + LH*(9158957./189000.
                  - 16973./3150.*Lt) + 186703./33600.*Sqr(LH) - 10980293./453600.*Lt + 20059./37800.*Sqr(Lt) + Nf*(-64661429393./5715360000.
                     - 16973./25200.*Sqr(LH) + 16973./75600.*Sqr(Pi) + 1543./5040.*zeta3 + LH*(- 10306537./1944000. + 1543./4725.*Lt)
                     +8973773./6804000.*Lt + 1543./18900.*Sqr(Lt)) + Sqr(Nf)*(3829289./19440000. - 1543./226800.*Sqr(Pi) + 89533./756000.*LH + 1543./75600.*Sqr(LH));

         const double deltaNNLO {
            hnnlo0 + tau*(hnnlo1 + tau*hnnlo2)
         };
         // eq. 4.20 from Adam's thesis
         const double deltaNNNLO {467.683620788 + 122.440972222*log_mH2OverMT2 + 10.9409722222*Sqr(log_mH2OverMT2)};

         const double alpha_s_red = get_alphas(context)/Pi;

         switch (include_higher_order_corrections) {
            case SM_higher_order_corrections::enable:
               result += Gamma_SM_LO*(deltaNLO*alpha_s_red + deltaNNLO*Sqr(alpha_s_red) + deltaNNNLO*Cube(alpha_s_red));
               break;
            case SM_higher_order_corrections::disable:
               break;
            default:
               break;
         }
      }
   }

   return result;
}

@decaysCalculationFunctions@
@partialWidthCalculationFunctions@

} // namespace flexiblesusy
