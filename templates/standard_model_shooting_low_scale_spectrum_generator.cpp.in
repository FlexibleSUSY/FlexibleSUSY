// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

#include "@ModelName@_shooting_spectrum_generator.hpp"
#include "@ModelName@_input_parameters.hpp"
#include "@ModelName@_shooting_ewsb_solver.hpp"
// #include "@ModelName@_shooting_initial_guesser.hpp"
#include "@ModelName@_shooting_susy_scale_constraint.hpp"
#include "@ModelName@_standard_model_matching.hpp"
// #include "@ModelName@_standard_model_two_scale_matching.hpp"
#include "standard_model_shooting_low_scale_constraint.hpp"

#include "error.hpp"
#include "lowe.h"
#include "numerics2.hpp"
#include "rkf_integrator.hpp"
#include "shooting_solver.hpp"

#include <limits>
#include <tuple>
#include <utility>

namespace flexiblesusy {

double @ModelName@_spectrum_generator<Shooting>::get_pole_mass_scale(double susy_scale) const
{
   return settings.get(Spectrum_generator_settings::pole_mass_scale) != 0. ?
      settings.get(Spectrum_generator_settings::pole_mass_scale) :
      susy_scale;
}

double @ModelName@_spectrum_generator<Shooting>::get_eft_pole_mass_scale(double susy_scale, double Mt) const
{
   double Q_higgs =
      settings.get(Spectrum_generator_settings::eft_pole_mass_scale);

   if (Q_higgs == 0.)
      Q_higgs = std::min(susy_scale, Mt);

   return Q_higgs;
}

double @ModelName@_spectrum_generator<Shooting>::get_matching_scale() const
{
   return settings.get(Spectrum_generator_settings::eft_matching_scale);
}

void @ModelName@_spectrum_generator<Shooting>::clear(
   @ModelName@<Shooting>& model,
   const @ModelName@_input_parameters& input) const
{
   model.clear();
   model.set_input_parameters(input);
   model.do_calculate_sm_pole_masses(
      settings.get(Spectrum_generator_settings::calculate_sm_masses));
   model.do_calculate_bsm_pole_masses(
      settings.get(Spectrum_generator_settings::calculate_bsm_masses));
   model.do_force_output(
      settings.get(Spectrum_generator_settings::force_output));
   model.set_loops(settings.get(Spectrum_generator_settings::beta_loop_order));
   model.set_thresholds(
      settings.get(
         Spectrum_generator_settings::threshold_corrections_loop_order));
   model.set_zero_threshold(
      settings.get(Spectrum_generator_settings::beta_zero_threshold));

   @ModelName@_ewsb_solver<Shooting> ewsb_solver;
   model.set_ewsb_solver(
      std::make_shared<@ModelName@_ewsb_solver<Shooting> >(ewsb_solver));
}


/**
 * @brief Run's the RG solver with the given input parameters
 *
 * This function sets up the RG solver using a susy-scale
 * and low-scale constraint.  Afterwards the solver is run until
 * convergence is reached or an error occours.  Finally the particle
 * spectrum (pole masses) is calculated.
 *
 * @param qedqcd Standard Model input parameters
 * @param input model input parameters
 */
void @ModelName@_spectrum_generator<Shooting>::run_except(const softsusy::QedQcd& qedqcd,
                                const @ModelName@_input_parameters& input)
{
   VERBOSE_MSG("Solving BVP using shooting solver");

   problems.set_bvp_solver_problems({ BVP_solver_problems("ShootingSolver") });

   clear(model, input);

   eft.clear();
   eft.do_force_output(
      settings.get(Spectrum_generator_settings::force_output));
   eft.set_loops(settings.get(Spectrum_generator_settings::beta_loop_order));
   eft.set_thresholds(
      settings.get(
         Spectrum_generator_settings::threshold_corrections_loop_order));
   eft.set_zero_threshold(
      settings.get(Spectrum_generator_settings::beta_zero_threshold));
   eft.set_pole_mass_loop_order(this->model.get_pole_mass_loop_order());
   eft.set_ewsb_loop_order(this->model.get_ewsb_loop_order());
   eft.set_ewsb_iteration_precision(this->model.get_ewsb_iteration_precision());
   eft.set_loop_corrections(this->model.get_loop_corrections());
   eft.set_threshold_corrections(this->model.get_threshold_corrections());

   standard_model::Standard_model_low_scale_constraint<Shooting>
      low_scale_constraint(&eft, qedqcd);
   low_scale_constraint.initialize();

   susy_scale = 0.;
   low_scale = low_scale_constraint.get_scale();

   // function to find root of
   auto dev_from_input = [&](const Vec_t& pars) {
      return deviation_from_observables(pars, qedqcd);
   };

   Shooting_solver<N> solver;
   solver.set_max_iterations(settings.get(Spectrum_generator_settings::max_iterations));
   solver.set_precision(settings.get(Spectrum_generator_settings::precision));
   solver.solve(dev_from_input, initial_guess());

   std::tie(model, eft) = run_down(solver.get_solution(), qedqcd, input);

   susy_scale = model.get_scale();

   const double Mt = qedqcd.displayPoleMt();

   calculate_spectrum(Mt);

   // run to output scale (if scale > 0)
   if (!is_zero(parameter_output_scale)) {
      model.run_to(parameter_output_scale);
      eft.run_to(parameter_output_scale);
   }
}

/**
 * Create a text file which contains the values of all model
 * parameters at all scales between the low-scale and the high-scale.
 *
 * @param filename name of output file
 */
void @ModelName@_spectrum_generator<Shooting>::write_running_couplings(
   const std::string& filename) const
{
   @ModelName@_spectrum_generator_interface<Shooting>::write_running_couplings(
      filename, get_low_scale(), get_susy_scale());
}

void @ModelName@_spectrum_generator<Shooting>::calculate_spectrum(double Mt)
{
   model.run_to(get_pole_mass_scale(susy_scale));
   model.solve_ewsb();
   model.calculate_spectrum();

   eft.run_to(get_eft_pole_mass_scale(susy_scale, Mt));

   // computation of pole mass spectrum in the SM
   const int eft_pole_loops = eft.get_pole_mass_loop_order();
   const int eft_ewsb_loops = eft.get_ewsb_loop_order();

   eft.calculate_DRbar_masses();
   eft.solve_ewsb();
   eft.calculate_spectrum();

   eft.set_pole_mass_loop_order(eft_pole_loops);
   eft.set_ewsb_loop_order(eft_ewsb_loops);

   const int index = settings.get(Spectrum_generator_settings::eft_higgs_index);

   model.get_physical().M@HiggsBoson_index@ = eft.get_physical().Mhh;
   model.get_physical().M@VectorZ_0@ = eft.get_physical().MVZ;
   model.get_physical().M@VectorW_0@ = eft.get_physical().MVWp;
@fillSMFermionPoleMasses@
   if (eft.get_problems().is_running_tachyon(standard_model_info::hh))
      model.get_problems().flag_running_tachyon(@ModelName@_info::@HiggsBoson@);
   if (eft.get_problems().is_pole_tachyon(standard_model_info::hh))
      model.get_problems().flag_pole_tachyon(@ModelName@_info::@HiggsBoson@);
   if (eft.get_problems().is_running_tachyon(standard_model_info::VZ))
      model.get_problems().flag_running_tachyon(@ModelName@_info::@VectorZ@);
   if (eft.get_problems().is_pole_tachyon(standard_model_info::VZ))
      model.get_problems().flag_pole_tachyon(@ModelName@_info::@VectorZ@);
   if (eft.get_problems().is_running_tachyon(standard_model_info::VWp))
      model.get_problems().flag_running_tachyon(@ModelName@_info::@VectorW@);
   if (eft.get_problems().is_pole_tachyon(standard_model_info::VWp))
      model.get_problems().flag_pole_tachyon(@ModelName@_info::@VectorW@);
}

/**
 * @brief returns initial guess for SM-like BSM parameters
 *
 * @return vector of SM-like BSM parameters
 */
@ModelName@_spectrum_generator<Shooting>::Vec_t
@ModelName@_spectrum_generator<Shooting>::initial_guess() const
{
   // TODO
   return Vec_t::Zero();
}

/**
 * @brief calculate lambda and run down
 *
 * @param model runnign BSM parameters
 *
 * @return SM at Q_low
 */
standard_model::StandardModel<Shooting>
@ModelName@_spectrum_generator<Shooting>::run_down(
   const @ModelName@<Shooting>& model) const
{
   standard_model::StandardModel<Shooting> sm;
   // TODO: impose matchign condition

   sm.run_to(get_low_scale());

   return sm;
}

std::pair<@ModelName@<Shooting>, standard_model::StandardModel<Shooting>>
@ModelName@_spectrum_generator<Shooting>::run_down(
   const Vec_t& bsm_pars, const softsusy::QedQcd& qedqcd,
   const @ModelName@_input_parameters& bsm_input) const
{
   @ModelName@<Shooting> model;
   clear(model, bsm_input);
   fill_parameters(model, bsm_pars);  // overwrite SM-like parameters
   fill_parameters(model, bsm_input); // impose susy-scale boundary condition

   model.calculate_DRbar_masses();
   model.solve_ewsb();
   model.set_integrator(runge_kutta::RKF_integrator());
   model.run_to(get_matching_scale());
   model.calculate_DRbar_masses();
   model.solve_ewsb();

   // calculate lambda and run down
   return std::make_pair(model, run_down(model));
}

void @ModelName@_spectrum_generator<Shooting>::fill_parameters(
   @ModelName@<Shooting>& model, const Vec_t& vec) const
{
   int idx = 0;

   // TODO: check normalization
   model.set_@hyperchargeCoupling@(vec(idx++));
   model.set_@leftCoupling@(vec(idx++));
   model.set_@strongCoupling@(vec(idx++));
   model.set_@UpYukawa@(2, 2, vec(idx++));
   model.set_@DownYukawa@(2, 2, vec(idx++));
   model.set_@ElectronYukawa@(2, 2, vec(idx++));

   const double VEV = vec(idx++);

   model.set_v(VEV);

   // TODO: generate this from MatchingScaleInput
   // const double tb = model.get_vu() == 0. || model.get_vd() == 0.
   //                      ? 1
   //                      : model.get_vu() / model.get_vd();
   // model.set_vu(VEV * tb/Sqrt(1 + Sqr(tb)));
   // model.set_vd(VEV *  1/Sqrt(1 + Sqr(tb)));
}

void @ModelName@_spectrum_generator<Shooting>::fill_parameters(
   @ModelName@<Shooting>& model,
   const @ModelName@_input_parameters& input) const
{
   // TODO
}

@ModelName@_spectrum_generator<Shooting>::Vec_t
@ModelName@_spectrum_generator<Shooting>::deviation_from_observables(
   const Vec_t& bsm_pars, const softsusy::QedQcd& qedqcd) const
{
   const double Q_match = get_matching_scale();
   const double Q_low = get_low_scale();
   const auto bsm_input = model.get_input();

   auto eft = run_down(bsm_pars, qedqcd, bsm_input).second;
   eft.run_to(Q_low);
   eft.solve_ewsb();
   eft.calculate_pole_masses();

   Vec_t diff(Vec_t::Zero());

   const double Pi             = 3.141592653589793;
   const double gY             = eft.get_g1() * standard_model_info::normalization_g1;
   const double g2             = eft.get_g2() * standard_model_info::normalization_g2;
   const double g3             = eft.get_g3() * standard_model_info::normalization_g3;
   const double e              = gY*g2 / Sqrt(Sqr(gY) + Sqr(g2));
   const double alpha_em_msbar = Sqr(e) / (4*Pi);
   const double alpha_s_msbar  = Sqr(g3) / (4*Pi);

   auto qedqcd_GF = qedqcd;
   qedqcd_GF.setPoleMt(eft.get_physical().MFu(2));
   qedqcd_GF.setPoleMW(eft.get_physical().MVWp);
   qedqcd_GF.setPoleMZ(eft.get_physical().MVZ);

   const double g_fermi        = eft.calculate_G_fermi(qedqcd_GF);

   auto qedqcd_Q_low = qedqcd; // TODO: why necessary for mb?
   qedqcd_Q_low.to(Q_low);

   const double Mtop           = qedqcd.displayPoleMt();
   const double mb_qedqcd      = qedqcd_Q_low.displayMass(softsusy::mBottom);
   const double alpha_em_SM5   = qedqcd.displayAlpha(softsusy::ALPHA);
   const double alpha_s_SM5    = qedqcd.displayAlpha(softsusy::ALPHAS);
   const double delta_alpha_em = eft.calculate_delta_alpha_em(alpha_em_msbar);
   const double delta_alpha_s  = eft.calculate_delta_alpha_s(alpha_s_SM5);
   const double alpha_em_SM5_p = alpha_em_msbar / (1 + delta_alpha_em);
   const double alpha_s_SM5_p  = alpha_s_msbar * (1 - delta_alpha_s);

   diff(0) = (alpha_em_SM5 - alpha_em_SM5_p)/alpha_em_SM5;
   diff(1) = (alpha_s_SM5 - alpha_s_SM5_p)/alpha_s_SM5;
   diff(2) = (qedqcd.displayFermiConstant() -  g_fermi)/qedqcd.displayFermiConstant();
   diff(3) = (Mtop -  eft.get_physical().MFu(2))/Mtop;
   diff(4) = (qedqcd.displayPoleMZ() - eft.get_physical().MVZ)/qedqcd.displayPoleMZ();
   diff(5) = (eft.calculate_MFd_DRbar(mb_qedqcd, 2) - eft.get_MFd(2))/eft.calculate_MFd_DRbar(mb_qedqcd, 2) ;
   diff(6) = (qedqcd.displayPoleMtau() - eft.get_physical().MFe(2))/(qedqcd.displayPoleMtau());

   return diff;
}

} // namespace flexiblesusy
