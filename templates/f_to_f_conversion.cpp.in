// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

/**
 * @file @ModelName@_f_to_f_conversion.cpp
 *
 * This file was generated at @DateAndTime@ with FlexibleSUSY
 * @FlexibleSUSYVersion@ and SARAH @SARAHVersion@
 */

#include <valarray>
#include <complex>
#include <iostream>
#include <iomanip> // TODO: remove

#include "@ModelName@_mass_eigenstates.hpp"
#include "cxx_qft/@ModelName@_qft.hpp"

#include "@ModelName@_f_to_f_conversion.hpp"
#include "@ModelName@_FFV_form_factors.hpp"
#include "@ModelName@_FFMassiveV_form_factors.hpp"

#include "wrappers.hpp"

using namespace flexiblesusy;
using namespace @ModelName@_cxx_diagrams;
using namespace @ModelName@_FFV_form_factors;
using namespace @ModelName@_FFMassiveV_form_factors;

namespace flexiblesusy {
using namespace @ModelName@_cxx_diagrams::fields;
namespace @ModelName@_f_to_f_conversion {

struct overlap_integrals {
   double D;
   double Vp;
   double Vn;
   double Sp;
   double Sn;
};

overlap_integrals get_overlap_integrals(const Nucleus N, const softsusy::QedQcd& qedqcd) {
   overlap_integrals res; 

   // get muon pole mass from input slha file
   const auto muon_pole_mass_5o2 = pow(qedqcd.displayMass(softsusy::mMuon), 5./2.);

   // Tab. 2 of hep-ph/0203110
   switch (N) {
      case Nucleus::Au:
         res.D  = 0.1670 * muon_pole_mass_5o2;
         res.Vp = 0.0859 * muon_pole_mass_5o2;
         res.Vn = 0.1080 * muon_pole_mass_5o2;
         res.Sp = 0.0523 * muon_pole_mass_5o2;
         res.Sn = 0.0610 * muon_pole_mass_5o2;
         return res;
      case Nucleus::Al:
         res.D  = 0.0357 * muon_pole_mass_5o2;
         res.Vp = 0.0159 * muon_pole_mass_5o2;
         res.Vn = 0.0169 * muon_pole_mass_5o2;
         res.Sp = 0.0153 * muon_pole_mass_5o2;
         res.Sn = 0.0163 * muon_pole_mass_5o2;
         return res;
      default:
         throw std::invalid_argument("Unknown nucleus");
   } 
}

double get_capture_rate (const Nucleus N) {
   switch (N) {
      case Nucleus::Au:
         return 8.84868e-18;
      case Nucleus::Al:
         return 4.64079e-19;
      default:
         throw std::invalid_argument("Unknown nucleus");
   }
}

template <class FOutBar, class FIn, class VBar>
std::complex<double> vectorCurrent(const @ModelName@_mass_eigenstates& model) {
    context_base context {model};
    using vertex = Vertex<FOutBar, FIn, VBar>;
    std::array<int, 4> indices {0, 0, 0, 0};
    const auto value =  vertex::evaluate(indices, context);
    return 0.5*(value.left() + value.right());
}

template <class V, class FormFactor>
std::valarray<std::complex<double>> create_massive_penguin_amp(
      FormFactor V_exchange,
      const @ModelName@_mass_eigenstates& model, 
      const softsusy::QedQcd& qedqcd) {

   context_base context {model};

   const auto uVectorCurrent = 
      vectorCurrent<typename Fu::lorentz_conjugate, Fu, typename V::lorentz_conjugate>(model);
   const auto dVectorCurrent = 
      vectorCurrent<typename Fd::lorentz_conjugate, Fd, typename V::lorentz_conjugate>(model);

   const auto mVsqr = pow(context.mass<V>({}), 2);
   const auto GF = qedqcd.displayFermiConstant();

   /* The vector-q-q and effective vertex have factor I removed from them.
      Therefore we miss I^2 = -1 from verices and -I from the numerator
      of vector propagator which in total gives +I. This 'I' will be used for
      converting back from amplitude to term in the lagrangian.
      In our convention, the effective 4-fermion operator is defined as
         L = - GF/sqrt2 * O
   */
   std::complex<double> guLV = -sqrt(2.0)/GF * 1./(-mVsqr) * V_exchange[0] * uVectorCurrent;
   std::complex<double> guRV = -sqrt(2.0)/GF * 1./(-mVsqr) * V_exchange[1] * uVectorCurrent;
   std::complex<double> gdLV = -sqrt(2.0)/GF * 1./(-mVsqr) * V_exchange[0] * dVectorCurrent;
   std::complex<double> gdRV = -sqrt(2.0)/GF * 1./(-mVsqr) * V_exchange[1] * dVectorCurrent;

   return {guLV, guRV, gdLV, gdRV};
}

@FToFConversion_InterfaceDefinitions@
} // namespace @ModelName@_f_to_f_conversion
} // namespace flexiblesusy
