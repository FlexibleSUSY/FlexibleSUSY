// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

#include "@ModelName@_standard_model_matching.hpp"
#include "wrappers.hpp"
#include "single_scale_matching.hpp"
#include "linalg2.hpp"
#include "logger.hpp"
#include "loop_corrections.hpp"
#include "standard_model.hpp"
#include "@ModelName@_mass_eigenstates.hpp"
#include "@ModelName@_info.hpp"
#include "config.h"
#ifdef ENABLE_THREADS
#include "global_thread_pool.hpp"
#endif
#include <cmath>

using namespace flexiblesusy::standard_model;

namespace flexiblesusy {
namespace @ModelName@_standard_model_matching {

#define MODELPARAMETER(p) model.get_##p()
#define EXTRAPARAMETER(parameter) model.get_##parameter()
#define SMPARAMETER(p) sm.get_##p()
#define INPUTPARAMETER(p) model.get_input().p
#define PHASE(p) model.get_##p()
#define LowEnergyConstant(p) Electroweak_constants::p
#define Pole(p) model.get_physical().p
#define SCALE model.get_scale()

namespace {

/// calculates quartic Higgs coupling of SM at 0l
double calculate_lambda_0l(
   const @ModelName@_mass_eigenstates& model,
   const standard_model::Standard_model sm,
   int idx)
{
   const double v = sm.get_v();
   const double lambda = Sqr(model.get_M@HiggsBoson(idx)@) / Sqr(v);

   return lambda;
}

Eigen::Matrix<double,3,3> calculate_MFu_DRbar_tree_level(const @ModelName@_mass_eigenstates& model)
{
   Eigen::Matrix<double,3,3> mf = ZEROMATRIX(3,3);

@setRunningUpQuarkMasses@

   return mf;
}

Eigen::Matrix<double,3,3> calculate_MFd_DRbar_tree_level(const @ModelName@_mass_eigenstates& model)
{
   Eigen::Matrix<double,3,3> mf = ZEROMATRIX(3,3);

@setRunningUpQuarkMasses@

   return mf;
}

Eigen::Matrix<double,3,3> calculate_MFe_DRbar_tree_level(const @ModelName@_mass_eigenstates& model)
{
   Eigen::Matrix<double,3,3> mf = ZEROMATRIX(3,3);

@setRunningUpQuarkMasses@

   return mf;
}

} // anonymous namespace

/**
 * Calculates \f$\lambda(Q)\f$ at the tree level from the lightest
 * CP-even Higgs boson mass of the @ModelName@.
 *
 * @param sm Standard Model parameters
 * @param model_input @ModelName@ parameters
 * @param idx Higgs index (in mass ordered Higgs multiplet)
 */
void match_high_to_low_scale_model_tree_level(
   Standard_model& sm, const @ModelName@_mass_eigenstates& model_input, int idx)
{
   auto model = model_input;

   sm.set_g1(model.get_@hyperchargeCoupling@()*@ModelName@_info::normalization_@hyperchargeCoupling@/standard_model_info::normalization_g1);
   sm.set_g2(model.get_@leftCoupling@()*@ModelName@_info::normalization_@leftCoupling@/standard_model_info::normalization_g2);
   sm.set_g3(model.get_@strongCoupling@()*@ModelName@_info::normalization_@strongCoupling@/standard_model_info::normalization_g3);

   const double g2 = sm.get_g2() * standard_model_info::normalization_g2;
   const double mW = model.get_M@VectorW(0)@;
   const double v  = 2.*mW/g2 ;

   model.calculate_DRbar_masses();

   const auto upQuarksDRbar    = calculate_MFu_DRbar_tree_level(model);
   const auto downQuarksDRbar  = calculate_MFd_DRbar_tree_level(model);
   const auto downLeptonsDRbar = calculate_MFe_DRbar_tree_level(model);

   sm.set_Yu(1.4142135623730951/v*upQuarksDRbar);
   sm.set_Yd(1.4142135623730951/v*downQuarksDRbar);
   sm.set_Ye(1.4142135623730951/v*downLeptonsDRbar);
   sm.set_v(v);
   sm.set_Lambdax(calculate_lambda_0l(model, sm, idx));

   sm.calculate_DRbar_masses();
}

/**
 * Calculates \f$\lambda(Q)\f$ at the 1-loop level from the lightest
 * CP-even Higgs boson mass of the @ModelName@ by requiring that the
 * 1-loop Higgs pole masses are equal in both models.
 *
 * @param sm Standard Model
 * @param model @ModelName@ parameters
 * @param loop_order downwards matching loop order
 * @param idx Higgs index (in mass ordered Higgs multiplet)
 */
void match_high_to_low_scale_model(
   Standard_model& sm, const @ModelName@_mass_eigenstates& model, int loop_order, int idx)
{
   if (loop_order == 0) {
      match_high_to_low_scale_model_tree_level(sm, model, idx);
      return;
   }

   WARNING("Using only tree-level matching, because 1-loop is not yet implemented.");
   match_high_to_low_scale_model_tree_level(sm, model, idx);
   // match_high_to_low_scale_model_1loop(sm, model, idx);
}

/**
 * Calculates the gauge and Yukawa couplings and the SM-like VEV in
 * the @ModelName@ at the tree level from the known Standard Model
 * couplings and the SM vev.
 */
void match_low_to_high_scale_model_tree_level(
   @ModelName@_mass_eigenstates& model, const Standard_model& sm_input)
{
   auto sm = sm_input;
   sm.calculate_DRbar_masses();

   model.set_@hyperchargeCoupling@(sm.get_g1()*standard_model_info::normalization_g1/@ModelName@_info::normalization_@hyperchargeCoupling@);
   model.set_@leftCoupling@(sm.get_g2()*standard_model_info::normalization_g2/@ModelName@_info::normalization_@leftCoupling@);
   model.set_@strongCoupling@(sm.get_g3()*standard_model_info::normalization_g3/@ModelName@_info::normalization_@strongCoupling@);

   {
      auto MODEL = &model;
      const double VEV = sm.get_v();

@applyUserMatching@
   }

   Eigen::Matrix<double, 3, 3> upQuarksDRbar    = ZEROMATRIX(3,3);
   Eigen::Matrix<double, 3, 3> downQuarksDRbar  = ZEROMATRIX(3,3);
   Eigen::Matrix<double, 3, 3> downLeptonsDRbar = ZEROMATRIX(3,3);

   upQuarksDRbar.diagonal()    = sm.get_MFu();
   downQuarksDRbar.diagonal()  = sm.get_MFd();
   downLeptonsDRbar.diagonal() = sm.get_MFe();

@setYukawas@

   model.calculate_DRbar_masses();
}

/**
 * Imposes the user-defined matching conditions, defined in
 * MatchingScaleInput.
 */
void impose_user_matching(@ModelName@_mass_eigenstates& model, double VEV)
{
   {
      auto MODEL = &model;

@applyUserMatching@
   }
}

} // namespace @ModelName@_standard_model_matching
} // namespace flexiblesusy
