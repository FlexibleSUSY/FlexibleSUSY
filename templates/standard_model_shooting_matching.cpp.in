// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================

// File generated at @DateAndTime@

#include "@ModelName@_standard_model_matching.hpp"
#include "wrappers.hpp"
#include "single_scale_matching.hpp"
#include "linalg2.hpp"
#include "logger.hpp"
#include "loop_corrections.hpp"
#include "standard_model.hpp"
#include "@ModelName@_mass_eigenstates.hpp"
#include "@ModelName@_info.hpp"
#include "config.h"
#ifdef ENABLE_THREADS
#include "global_thread_pool.hpp"
#endif
#include <cmath>

using namespace flexiblesusy::standard_model;

namespace flexiblesusy {
namespace @ModelName@_standard_model_matching {

#define MODELPARAMETER(p) model.get_##p()
#define EXTRAPARAMETER(parameter) model.get_##parameter()
#define SMPARAMETER(p) sm.get_##p()
#define INPUTPARAMETER(p) model.get_input().p
#define PHASE(p) model.get_##p()
#define LowEnergyConstant(p) Electroweak_constants::p
#define Pole(p) model.get_physical().p
#define SCALE model.get_scale()

namespace {




/**
 * Calculates squared Higgs pole mass in the SM,
 * \f$(M_h^{\text{SM}})^2\f$.
 *
 * @param sm_0l SM parameters with tree-level lambda
 *
 * @return squared Higgs pole mass in the SM
 */
double calculate_Mh2_pole(const Standard_model& sm_0l)
{
   const double p = sm_0l.get_Mhh();
   const double self_energy = Re(sm_0l.self_energy_hh_1loop(p));
   const double tadpole = Re(sm_0l.tadpole_hh_1loop() / sm_0l.get_v());
   const double mh2_tree = Sqr(sm_0l.get_Mhh());
   const double Mh2_pole = mh2_tree - self_energy + tadpole;

   return Mh2_pole;
}

/**
 * Calculates tadpoles over vevs (at given fixed loop order)
 *
 * @param model model parameters
 * @param loop_order loop order
 *
 * @return tadpole at loop order
 */
Eigen::Matrix<double,@numberOfEWSBEquations@,1> calculate_tadpole_over_vevs(
   @ModelName@_mass_eigenstates model, int loop_order)
{
   if (loop_order == 0) {
      model.set_ewsb_loop_order(loop_order);
      return model.tadpole_equations_over_vevs();
   }

   model.set_ewsb_loop_order(loop_order);
   const auto tadpole_lo = model.tadpole_equations_over_vevs(); // nL

   model.set_ewsb_loop_order(loop_order - 1);
   const auto tadpole_lom1 = model.tadpole_equations_over_vevs(); // (n-1)L

   return (tadpole_lo - tadpole_lom1).eval();
}





double calculate_MW_pole_1l(const Standard_model& sm_0l)
{
   const double mw = sm_0l.get_MVWp();
   const double p = sm_0l.get_MVWp();
   const double self_energy = Re(sm_0l.self_energy_VWp_1loop(p));
   const double M_loop = Sqr(mw) - self_energy;

   return SignedAbsSqrt(M_loop);
}

double calculate_MW_pole_1l(const @ModelName@_mass_eigenstates& model_0l)
{
   const double mw = model_0l.get_M@VectorW(0)@;
   const double p = model_0l.get_M@VectorW(0)@;
   const double self_energy = Re(model_0l.self_energy_@VectorW@_1loop(p));
   const double M_loop = Sqr(mw) - self_energy;

   return SignedAbsSqrt(M_loop);
}

double calculate_MZ_pole_1l(const Standard_model& sm_0l)
{
   const double mz = sm_0l.get_MVZ();
   const double p = sm_0l.get_MVZ();
   const double self_energy = Re(sm_0l.self_energy_VZ_1loop(p));
   const double M_loop = Sqr(mz) - self_energy;

   return SignedAbsSqrt(M_loop);
}

double calculate_MZ_pole_1l(const @ModelName@_mass_eigenstates& model_0l)
{
   const double mz = model_0l.get_M@VectorZ(0)@;
   const double p = model_0l.get_M@VectorZ(0)@;
   const double self_energy = Re(model_0l.self_energy_@VectorZ@_1loop(p));
   const double M_loop = Sqr(mz) - self_energy;

   return SignedAbsSqrt(M_loop);
}

double calculate_MW_DRbar_1l(
   const Standard_model& sm_0l,
   const @ModelName@_mass_eigenstates& model_0l)
{
   const double MW_sm = calculate_MW_pole_1l(sm_0l);
   const double MW_bsm = calculate_MW_pole_1l(model_0l);
   const double mw2 = Sqr(MW_bsm) - Sqr(MW_sm) + Sqr(sm_0l.get_MVWp());

   return AbsSqrt(mw2);
}

double calculate_MZ_DRbar_1l(
   const Standard_model& sm_0l,
   const @ModelName@_mass_eigenstates& model_0l)
{
   const double MZ_sm = calculate_MZ_pole_1l(sm_0l);
   const double MZ_bsm = calculate_MZ_pole_1l(model_0l);
   const double mz2 = Sqr(MZ_bsm) - Sqr(MZ_sm) + Sqr(sm_0l.get_MVZ());

   return AbsSqrt(mz2);
}



double calculate_delta_alpha_em(double alpha_em, const @ModelName@_mass_eigenstates& model)
{
   const double currentScale = model.get_scale();
   double delta_alpha_em = 0.;

@alphaEM1Lmatching@

   return delta_alpha_em;
}

double calculate_delta_alpha_s(double alpha_s, const @ModelName@_mass_eigenstates& model)
{
   const double currentScale = model.get_scale();
   double delta_alpha_s = 0.;

@alphaS1Lmatching@

   return delta_alpha_s;
}

Eigen::Matrix<double,3,3> calculate_MFu_DRbar_0l(const @ModelName@_mass_eigenstates& model)
{
   Eigen::Matrix<double,3,3> mf = ZEROMATRIX(3,3);

@setRunningUpQuarkMasses@

   return mf;
}

Eigen::Matrix<double,3,3> calculate_MFd_DRbar_0l(const @ModelName@_mass_eigenstates& model)
{
   Eigen::Matrix<double,3,3> mf = ZEROMATRIX(3,3);

@setRunningDownQuarkMasses@

   return mf;
}

Eigen::Matrix<double,3,3> calculate_MFe_DRbar_0l(const @ModelName@_mass_eigenstates& model)
{
   Eigen::Matrix<double,3,3> mf = ZEROMATRIX(3,3);

@setRunningDownLeptonMasses@

   return mf;
}

double calculate_MFu_pole_1l(
   int i,
   const Standard_model& sm_0l)
{
   const double p = sm_0l.get_MFu(i);
   const auto self_energy_1  = Re(sm_0l.self_energy_Fu_1loop_1(p));
   const auto self_energy_PL = Re(sm_0l.self_energy_Fu_1loop_PL(p));
   const auto self_energy_PR = Re(sm_0l.self_energy_Fu_1loop_PR(p));
   const auto M_tree = sm_0l.get_mass_matrix_Fu();
   const auto M_loop = (M_tree - self_energy_PR * M_tree
                        - M_tree * self_energy_PL - self_energy_1).eval();

   Eigen::Array<double,3,1> MFu_pole;
   fs_svd(M_loop, MFu_pole);

   return MFu_pole(i);
}

double calculate_MFd_pole_1l(
   int i,
   const Standard_model& sm_0l)
{
   const double p = sm_0l.get_MFd(i);
   const auto self_energy_1  = Re(sm_0l.self_energy_Fd_1loop_1(p));
   const auto self_energy_PL = Re(sm_0l.self_energy_Fd_1loop_PL(p));
   const auto self_energy_PR = Re(sm_0l.self_energy_Fd_1loop_PR(p));
   const auto M_tree = sm_0l.get_mass_matrix_Fd();
   const auto M_loop = (M_tree - self_energy_PR * M_tree
                        - M_tree * self_energy_PL - self_energy_1).eval();

   Eigen::Array<double,3,1> MFd_pole;
   fs_svd(M_loop, MFd_pole);

   return MFd_pole(i);
}

double calculate_MFe_pole_1l(
   int i,
   const Standard_model& sm_0l)
{
   const double p = sm_0l.get_MFe(i);
   const auto self_energy_1  = Re(sm_0l.self_energy_Fe_1loop_1(p));
   const auto self_energy_PL = Re(sm_0l.self_energy_Fe_1loop_PL(p));
   const auto self_energy_PR = Re(sm_0l.self_energy_Fe_1loop_PR(p));
   const auto M_tree = sm_0l.get_mass_matrix_Fe();
   const auto M_loop = (M_tree - self_energy_PR * M_tree
                        - M_tree * self_energy_PL - self_energy_1).eval();

   Eigen::Array<double,3,1> MFe_pole;
   fs_svd(M_loop, MFe_pole);

   return MFe_pole(i);
}

double calculate_MFu_pole_1l(
   int i,
   const @ModelName@_mass_eigenstates& model_0l)
{
   double m_pole = 0.;

@calculateMUpQuarkPole1L@

   return m_pole;
}

double calculate_MFd_pole_1l(
   int i,
   const @ModelName@_mass_eigenstates& model_0l)
{
   double m_pole = 0.;

@calculateMDownQuarkPole1L@

   return m_pole;
}

double calculate_MFe_pole_1l(
   int i,
   const @ModelName@_mass_eigenstates& model_0l)
{
   double m_pole = 0.;

@calculateMDownLeptonPole1L@

   return m_pole;
}

Eigen::Matrix<double,3,3> calculate_MFu_pole_1l(const Standard_model& sm_0l)
{
   Eigen::Matrix<double,3,1> M_pole;

#ifdef ENABLE_THREADS
   auto M_0 = global_thread_pool().run_packaged_task([&sm_0l]{ return calculate_MFu_pole_1l(0, sm_0l); });
   auto M_1 = global_thread_pool().run_packaged_task([&sm_0l]{ return calculate_MFu_pole_1l(1, sm_0l); });
   auto M_2 = global_thread_pool().run_packaged_task([&sm_0l]{ return calculate_MFu_pole_1l(2, sm_0l); });
   M_pole << M_0.get(), M_1.get(), M_2.get();
#else
   M_pole << calculate_MFu_pole_1l(0, sm_0l),
             calculate_MFu_pole_1l(1, sm_0l),
             calculate_MFu_pole_1l(2, sm_0l);
#endif

   return M_pole.asDiagonal();
}

Eigen::Matrix<double,3,3> calculate_MFd_pole_1l(const Standard_model& sm_0l)
{
   Eigen::Matrix<double,3,1> M_pole;

#ifdef ENABLE_THREADS
   auto M_0 = global_thread_pool().run_packaged_task([&sm_0l]{ return calculate_MFd_pole_1l(0, sm_0l); });
   auto M_1 = global_thread_pool().run_packaged_task([&sm_0l]{ return calculate_MFd_pole_1l(1, sm_0l); });
   auto M_2 = global_thread_pool().run_packaged_task([&sm_0l]{ return calculate_MFd_pole_1l(2, sm_0l); });
   M_pole << M_0.get(), M_1.get(), M_2.get();
#else
   M_pole << calculate_MFd_pole_1l(0, sm_0l),
             calculate_MFd_pole_1l(1, sm_0l),
             calculate_MFd_pole_1l(2, sm_0l);
#endif

   return M_pole.asDiagonal();
}

Eigen::Matrix<double,3,3> calculate_MFe_pole_1l(const Standard_model& sm_0l)
{
   Eigen::Matrix<double,3,1> M_pole;

#ifdef ENABLE_THREADS
   auto M_0 = global_thread_pool().run_packaged_task([&sm_0l]{ return calculate_MFe_pole_1l(0, sm_0l); });
   auto M_1 = global_thread_pool().run_packaged_task([&sm_0l]{ return calculate_MFe_pole_1l(1, sm_0l); });
   auto M_2 = global_thread_pool().run_packaged_task([&sm_0l]{ return calculate_MFe_pole_1l(2, sm_0l); });
   M_pole << M_0.get(), M_1.get(), M_2.get();
#else
   M_pole << calculate_MFe_pole_1l(0, sm_0l),
             calculate_MFe_pole_1l(1, sm_0l),
             calculate_MFe_pole_1l(2, sm_0l);
#endif

   return M_pole.asDiagonal();
}

Eigen::Matrix<double,3,3> calculate_MFu_pole_1l(
   const @ModelName@_mass_eigenstates& model_0l)
{
   Eigen::Matrix<double,3,1> M_pole;

#ifdef ENABLE_THREADS
   auto M_0 = global_thread_pool().run_packaged_task([&model_0l]{ return calculate_MFu_pole_1l(0, model_0l); });
   auto M_1 = global_thread_pool().run_packaged_task([&model_0l]{ return calculate_MFu_pole_1l(1, model_0l); });
   auto M_2 = global_thread_pool().run_packaged_task([&model_0l]{ return calculate_MFu_pole_1l(2, model_0l); });
   M_pole << M_0.get(), M_1.get(), M_2.get();
#else
   M_pole << calculate_MFu_pole_1l(0, model_0l),
             calculate_MFu_pole_1l(1, model_0l),
             calculate_MFu_pole_1l(2, model_0l);
#endif

   return M_pole.asDiagonal();
}

Eigen::Matrix<double,3,3> calculate_MFd_pole_1l(
   const @ModelName@_mass_eigenstates& model_0l)
{
   Eigen::Matrix<double,3,1> M_pole;

#ifdef ENABLE_THREADS
   auto M_0 = global_thread_pool().run_packaged_task([&model_0l]{ return calculate_MFd_pole_1l(0, model_0l); });
   auto M_1 = global_thread_pool().run_packaged_task([&model_0l]{ return calculate_MFd_pole_1l(1, model_0l); });
   auto M_2 = global_thread_pool().run_packaged_task([&model_0l]{ return calculate_MFd_pole_1l(2, model_0l); });
   M_pole << M_0.get(), M_1.get(), M_2.get();
#else
   M_pole << calculate_MFd_pole_1l(0, model_0l),
             calculate_MFd_pole_1l(1, model_0l),
             calculate_MFd_pole_1l(2, model_0l);
#endif

   return M_pole.asDiagonal();
}

Eigen::Matrix<double,3,3> calculate_MFe_pole_1l(
   const @ModelName@_mass_eigenstates& model_0l)
{
   Eigen::Matrix<double,3,1> M_pole;

#ifdef ENABLE_THREADS
   auto M_0 = global_thread_pool().run_packaged_task([&model_0l]{ return calculate_MFe_pole_1l(0, model_0l); });
   auto M_1 = global_thread_pool().run_packaged_task([&model_0l]{ return calculate_MFe_pole_1l(1, model_0l); });
   auto M_2 = global_thread_pool().run_packaged_task([&model_0l]{ return calculate_MFe_pole_1l(2, model_0l); });
   M_pole << M_0.get(), M_1.get(), M_2.get();
#else
   M_pole << calculate_MFe_pole_1l(0, model_0l),
             calculate_MFe_pole_1l(1, model_0l),
             calculate_MFe_pole_1l(2, model_0l);
#endif

   return M_pole.asDiagonal();
}


Eigen::Matrix<double, 3, 3>
calculate_MFu_DRbar_1l(
   const Standard_model& sm_0l,
   const @ModelName@_mass_eigenstates& model) {
  Eigen::Matrix<double, 3, 3> mf_sm_1l = ZEROMATRIX(3, 3);

  const auto Mf_sm = calculate_MFu_pole_1l(sm_0l);
  const auto Mf_bsm = calculate_MFu_pole_1l(model);
  const auto mf_sm_0l =
      calculate_MFu_DRbar_0l(model); // treelevel matching

  mf_sm_1l = Mf_bsm - Mf_sm + mf_sm_0l;

  return Abs(mf_sm_1l);
}

Eigen::Matrix<double, 3, 3>
calculate_MFd_DRbar_1l(
   const Standard_model& sm_0l,
   const @ModelName@_mass_eigenstates& model) {
  Eigen::Matrix<double, 3, 3> mf_sm_1l = ZEROMATRIX(3, 3);

  const auto Mf_sm = calculate_MFd_pole_1l(sm_0l);
  const auto Mf_bsm = calculate_MFd_pole_1l(model);
  const auto mf_sm_0l =
      calculate_MFd_DRbar_0l(model); // treelevel matching

  mf_sm_1l = Mf_bsm - Mf_sm + mf_sm_0l;

  return Abs(mf_sm_1l);
}

Eigen::Matrix<double, 3, 3>
calculate_MFe_DRbar_1l(
   const Standard_model& sm_0l,
   const @ModelName@_mass_eigenstates& model) {
  Eigen::Matrix<double, 3, 3> mf_sm_1l = ZEROMATRIX(3, 3);

  const auto Mf_sm = calculate_MFe_pole_1l(sm_0l);
  const auto Mf_bsm = calculate_MFe_pole_1l(model);
  const auto mf_sm_0l =
      calculate_MFe_DRbar_0l(model); // treelevel matching

  mf_sm_1l = Mf_bsm - Mf_sm + mf_sm_0l;

  return Abs(mf_sm_1l);
}




/// calculates quartic Higgs coupling of SM at 0l
double calculate_lambda_0l(
   const @ModelName@_mass_eigenstates& model,
   const standard_model::Standard_model sm,
   int idx)
{
   const double v = sm.get_v();
   const double lambda = Sqr(model.get_M@HiggsBoson(idx)@) / Sqr(v);

   return lambda;
}


/**
 * Calculates SM pole mass at 1l.
 */
double calculate_Mh2_pole_1l(const standard_model::Standard_model &sm_0l) {
  const double p = sm_0l.get_Mhh();
  const double self_energy = Re(sm_0l.self_energy_hh_1loop(p));
  const double tadpole = Re(sm_0l.tadpole_hh_1loop() / sm_0l.get_v());
  const double mh2_tree = Sqr(sm_0l.get_Mhh());
  const double Mh2_pole = mh2_tree - self_energy + tadpole;

  return Mh2_pole;
}


/**
 * Calculates tree-level Higgs mass matrix in the NUHMSSMNoFVHimalaya without
 * including tadpoles implicitly.  This is achieved by solving the
 * EWSB equations at tree-level in order to avoid the inclusion of
 * loop tadpoles.
 *
 * @param model NUHMSSMNoFVHimalaya parameters
 * @return tree-level Higgs mass matrix in the NUHMSSMNoFVHimalaya w/o tadpoles
 */
auto calculate_mh2_0l(@ModelName@_mass_eigenstates model) -> decltype(model.get_mass_matrix_@HiggsBoson@())
{
   model.solve_ewsb_tree_level_custom();
   return model.get_mass_matrix_@HiggsBoson@();
}

/**
 * Calculates BSM pole mass at 1l.
 */

double calculate_Mh2_pole_1l( const @ModelName@_mass_eigenstates& model,
                             int idx) {

  // calculate tree-level mass matrix
  const auto mh2_tree = calculate_mh2_0l(model);

  // calculate 1L self-energy using tree-level parameters
  const double p = model.get_Mhh(idx);
  const auto self_energy = Re(model.self_energy_hh_1loop(p));

  // calculate 1L tadpoles using tree-level parameters
  const auto tadpole = calculate_tadpole_over_vevs(model, 1);

  double Mh2_pole = 0.;

@calculateMHiggsPoleOneMomentumIteration@

/*
  const auto M_loop = (mh2_tree - self_energy -
                       Eigen::Matrix<double, 2, 2>(tadpole.asDiagonal()))
                          .eval();

  Eigen::Array<double, 2, 1> M_pole;
  fs_diagonalize_hermitian(M_loop, M_pole);

  Mh2_pole = M_pole(idx);
*/
  return Mh2_pole;
}

double calculate_mh_DRbar_1l(const standard_model::Standard_model sm_0l,
                             const @ModelName@_mass_eigenstates &model,
                             int idx) {
  const double mh2_sm = Sqr(sm_0l.get_Mhh());
  const double Mh2_sm = calculate_Mh2_pole_1l(sm_0l);
  const double Mh2_bsm = calculate_Mh2_pole_1l(model, idx);

  const double mh2_1l = Mh2_bsm - Mh2_sm + mh2_sm;

  return AbsSqrt(mh2_1l);
}

double calculate_lambda_1l(const @ModelName@_mass_eigenstates& model,
                           const standard_model::Standard_model sm_0l,
                           standard_model::Standard_model sm_1l, int idx) {
  const double v = sm_0l.get_v();
  const double delta_v = (sm_1l.get_v()) - v;
  const double v2 = Sqr(sm_0l.get_v());
  const double mh2_SM = Sqr(calculate_mh_DRbar_1l(sm_0l, model, idx));

  const double lambda1l =
      mh2_SM / v2 - 2 * Sqr(model.get_Mhh(idx)) / v2 * delta_v / v;

  return lambda1l;
}




} // anonymous namespace



/**
 * Calculates SM tree-level parameters (g1, g2, g3, Yu, Yd,
 * Ye, v) by performing a tree-level matching from the MSSM to the
 * SM
 *
 * @param model MSSM parameters
 * @param sm SM parameters
 *
 * @return SM with tree-level parameters
 * 
 *
standard_model::Standard_model
calculate_sm_0l(const @ModelName@_mass_eigenstates& model, int idx) {
  standard_model::Standard_model sm_0l;
  sm_0l.set_precision(model.get_precision());
  sm_0l.set_scale(model.get_scale());

  auto model_0l = model;
  model_0l.get_problems().clear();
  model_0l.calculate_DRbar_masses();

  match_high_to_low_scale_sm_0l( sm_0l, model_0l, idx);

  return sm_0l;
}
*/




/**
 * Calculates \f$\lambda(Q)\f$ at the tree level from the lightest
 * CP-even Higgs boson mass of the @ModelName@.
 *
 * @param sm Standard Model parameters
 * @param model_input @ModelName@ parameters
 * @param idx Higgs index (in mass ordered Higgs multiplet)
 */


void match_high_to_low_scale_sm_0l(
   Standard_model& sm, const @ModelName@_mass_eigenstates& model_input, int idx)
{
   auto model = model_input;

   sm.set_g1(model.get_@hyperchargeCoupling@()*@ModelName@_info::normalization_@hyperchargeCoupling@/standard_model_info::normalization_g1);
   sm.set_g2(model.get_@leftCoupling@()*@ModelName@_info::normalization_@leftCoupling@/standard_model_info::normalization_g2);
   sm.set_g3(model.get_@strongCoupling@()*@ModelName@_info::normalization_@strongCoupling@/standard_model_info::normalization_g3);

   const double g2 = sm.get_g2() * standard_model_info::normalization_g2;
   const double mW = model.get_M@VectorW(0)@;
   const double v  = 2.*mW/g2 ;

 //  model.calculate_DRbar_masses();

   const auto upQuarksDRbar    = calculate_MFu_DRbar_0l(model);
   const auto downQuarksDRbar  = calculate_MFd_DRbar_0l(model);
   const auto downLeptonsDRbar = calculate_MFe_DRbar_0l(model);

   sm.set_Yu(1.4142135623730951/v*upQuarksDRbar);
   sm.set_Yd(1.4142135623730951/v*downQuarksDRbar);
   sm.set_Ye(1.4142135623730951/v*downLeptonsDRbar);
   sm.set_v(v);
   sm.set_Lambdax(calculate_lambda_0l(model, sm, idx));

   sm.calculate_DRbar_masses();
}


void match_high_to_low_scale_sm_1l(Standard_model& sm, 
      const @ModelName@_mass_eigenstates& model_input, int idx)
{

   auto model = model_input;
   auto sm_0l = sm;

  match_high_to_low_scale_sm_0l(sm_0l, model, idx);

  const double gy = sm_0l.get_g1() * standard_model_info::normalization_g1;
  const double g2 = sm_0l.get_g2() * standard_model_info::normalization_g2;

  const double gy_2 =
      Sqr(sm_0l.get_g1() * standard_model_info::normalization_g1);
  const double g2_2 =
      Sqr(sm_0l.get_g2() * standard_model_info::normalization_g2);
  const double g3_2 =
      Sqr(sm_0l.get_g3() * standard_model_info::normalization_g3);
  const double v = sm_0l.get_v();

  const double alpha_em = gy_2 * g2_2 / (4. * Pi * (gy_2 + g2_2));
  const double alpha_s = g3_2 / (4. * Pi);
  const double delta_alpha_em = calculate_delta_alpha_em(alpha_em, model);
  const double delta_alpha_s = calculate_delta_alpha_s(alpha_s, model);

  const double mW2_1l = Sqr(calculate_MW_DRbar_1l(sm_0l, model));
  const double mZ2_1l = Sqr(calculate_MZ_DRbar_1l(sm_0l, model));

  const double mW2 = Sqr(model.get_M@VectorW(0)@);
  const double mZ2 = Sqr(model.get_M@VectorZ(0)@);
  const double delta_mZ2 = mZ2_1l - mZ2;
  const double delta_mW2 = mW2_1l - mW2;

  const double sThetaW2 = 1 - Sqr(sm_0l.get_MVWp() / sm_0l.get_MVZ());
  const double delta_sThetaW2 = delta_mZ2 * mW2 / (Sqr(mZ2)) - delta_mW2 / mZ2;

  const double g1_1l =
      AbsSqrt(4. * Pi * alpha_em * mZ2 / mW2) *
      (1. + 0.5 * (-delta_alpha_em + delta_sThetaW2 * mZ2 / mW2)) /
      standard_model_info::normalization_g1;
  const double g2_1l =
      AbsSqrt(4. * Pi * alpha_em / (sThetaW2)) *
      (1. + 0.5 * (-delta_alpha_em - delta_sThetaW2 / sThetaW2)) /
      standard_model_info::normalization_g2;
  const double g3_1l = AbsSqrt(4. * Pi * alpha_s) * (1. - 0.5 * delta_alpha_s) /
                       standard_model_info::normalization_g3;

// const double delta_gy = g1_1l * standard_model_info::normalization_g1 - gy;
  const double delta_g2 = g2_1l * standard_model_info::normalization_g2 - g2;
  const double vev_1l =
      2 * Sqrt(mW2) / g2 * (1 - delta_g2 / g2 + 0.5 * delta_mW2 / mW2);
  const double delta_vev = vev_1l - v;

  sm.set_g1(g1_1l);
  sm.set_g2(g2_1l);
  sm.set_g3(g3_1l);
  sm.set_v(vev_1l);


  Eigen::Matrix<double, 3, 3> YupQuarksMSbar = sm_0l.get_Yu();
  Eigen::Matrix<double, 3, 3> YdownQuarksMSbar = sm_0l.get_Yd();
  Eigen::Matrix<double, 3, 3> YdownLeptonsMSbar = sm_0l.get_Ye();

  Eigen::Matrix<double, 3, 3> upQuarksDRbar1l =
      calculate_MFu_DRbar_1l(sm_0l, model);
  Eigen::Matrix<double, 3, 3> downQuarksDRbar1l =
      calculate_MFd_DRbar_1l(sm_0l, model);
  Eigen::Matrix<double, 3, 3> downLeptonsDRbar1l =
      calculate_MFe_DRbar_1l(sm_0l, model);
/*
  YupQuarksMSbar(1,1) = 0.;
YupQuarksMSbar(0,0) = 0.;
YdownQuarksMSbar(0,0) = 0.;
YdownLeptonsMSbar(1,1) = 0.;
YdownQuarksMSbar(1,1) = 0.;
YdownLeptonsMSbar(0,0) = 0.;


upQuarksDRbar1l(1,1) = 0.;
upQuarksDRbar1l(0,0) = 0.;
downQuarksDRbar1l(0,0) = 0.;
downQuarksDRbar1l(1,1) = 0.;
downLeptonsDRbar1l(1,1) = 0.;
downLeptonsDRbar1l(0,0) = 0.;

*/

  sm.set_Yu(1.4142135623730951 / v * upQuarksDRbar1l -
               YupQuarksMSbar * delta_vev / v);
  sm.set_Yd(1.4142135623730951 / v * downQuarksDRbar1l -
               YdownQuarksMSbar * delta_vev / v);
  sm.set_Ye(1.4142135623730951 / v * downLeptonsDRbar1l -
               YdownLeptonsMSbar * delta_vev / v);


  sm.set_Lambdax(calculate_lambda_1l(model, sm_0l, sm, idx));
  sm.calculate_DRbar_masses();
  sm.get_problems().add(sm_0l.get_problems());

}

/*
void match_high_to_low_scale_sm_2l(Standard_model& sm, 
      const @ModelName@_mass_eigenstates& model_input, int idx)
{

   static const double gauge_less = 1e-10;              // approximates the gaugeless limit for gauge couplings

   auto model    = model_input;
   auto model_gl = model
   model_gl.get_problems().clear();
   model_gl.set_g1(gauge_less / @ModelName@_info::normalization_g1);
   model_gl.set_g2(gauge_less /  @ModelName@_info::normalization_g2);
   model_gl.calculate_DRbar_masses();
   model.calculate_DRbar_masses();
   
   auto sm_0l    = sm;
   auto sm_1l    = sm
   auto sm_0l_gl = sm;
   auto sm_1l_gl = sm


  match_high_to_low_scale_sm_0l(sm_0l, model, idx);
  match_high_to_low_scale_sm_1l(sm_1l, model, idx);
  match_high_to_low_scale_sm_0l_gl(sm_0l_gl, model_gl, idx);
  match_high_to_low_scale_sm_1l_gl(sm_1l_gl, model_gl, idx);


   const  double delta_yt       = sm_1l_gl.get_Yu(2,2) - sm_0l_gl.get_Yu(2,2) ;
   const double delta_yb       = sm_1l_gl.get_Yd(2,2) - sm_0l_gl.get_Yd(2,2) ;
   const double delta_ytau     = sm_1l_gl.get_Ye(2,2) - sm_0l_gl.get_Ye(2,2);
   const double delta_v_gl     = sm_1l_gl.get_v() - v;

   const double mh2_bsm_shift   = calculate_Mh2_shift_2l( model_gl, idx); 
   const double mh2_sm_shift    = calculate_Mh2_shift_2l(sm_0l_gl, model_2l_gl, idx); 
   const double mh2_1l_sm_shift  = calculate_Mh2_shift_1l_2l(sm_0l_gl); 
   const double mh2_1l_bsm_shift = calculate_Mh2_shift_1l_2l(model_gl, idx); 

   double delta_mh_1l_gl = 0.;
   double mh2_conversion = delta_mh_1loop_at_sm_deriv_yt(p, sm_0l_gl.get_scale(), sm_0l_gl.get_MFu(2),
		     sm_0l_gl.get_Yu(2,2)) *  delta_yt
	             +  delta_mh_1loop_ab_sm_deriv_yb(p, sm_0l_gl.get_scale(), sm_0l_gl.get_MFd(2),
		     sm_0l_gl.get_Yd(2,2)) *  delta_yb
	             + delta_mh_1loop_atau_sm_deriv_ytau(p, sm_0l_gl.get_scale(), sm_0l_gl.get_MFe(2),
		     sm_0l_gl.get_Ye(2,2)) *  delta_ytau
                     + (  delta_mh_1loop_at_sm_deriv_v(p, sm_0l_gl.get_scale(), sm_0l_gl.get_MFu(2),
		          sm_0l_gl.get_Yu(2,2))  
		        + delta_mh_1loop_ab_sm_deriv_v(p, sm_0l_gl.get_scale(), sm_0l_gl.get_MFd(2),
		          sm_0l_gl.get_Yd(2,2))
              	        + delta_mh_1loop_atau_sm_deriv_v(p, sm_0l_gl.get_scale(), sm_0l_gl.get_MFe(2),
		          sm_0l_gl.get_Ye(2,2))) *  delta_v_gl;

  
   const double lambda_2l  = lambda_1l + (mh2_bsm_shift - mh2_sm_shift - mh2_conversion )/ v2 
	                     -2.* delta_v_gl /( v * v2 ) * (mh2_1l_bsm_shift - mh2_1l_sm_shift);


   sm_2l.set_Lambdax(lambda_2l);
   sm_2l.calculate_DRbar_masses();

}
*/

/**
 * Calculates \f$\lambda(Q)\f$ at the current loop level from the
 * lightest CP-even Higgs boson mass of the @ModelName@ by requiring
 * that the Higgs pole masses are equal in both models.
 *
 * @param sm Standard Model
 * @param model_1l @ModelName@ parameters
 * @param idx Higgs index (in mass ordered Higgs multiplet)
 *
void match_high_to_low_scale_model_1l(
   Standard_model& sm,
   const @ModelName@_mass_eigenstates& model_1l,
   int idx)
{
   standard_model::Standard_model sm_1l;
   sm_1l.set_precision(model.get_precision());
   sm_1l.set_scale(model.get_scale());
   // tree-level @ModelName@ parameters
   auto sm_0l = sm;
   sm_0l.get_problems().clear();
   sm_0l.calculate_DRbar_masses();

   auto model_1l = model;
   model_1l.get_problems().clear();
   model_1l.calculate_DRbar_masses(); 
   

   const auto model_0l = calculate_@ModelName@_0l(model_1l, sm);
   const auto sm_0l = calculate_SM_0l(sm, model_0l, idx);

   const double mh2_sm = Sqr(sm_0l.get_Mhh());
   const double Mh2_sm = calculate_Mh2_pole(sm_0l);
   const double Mh2_bsm = calculate_Mh2_pole(model_0l, model_1l, idx);

   sm.set_Lambdax((Mh2_bsm - Mh2_sm + mh2_sm)/Sqr(sm.get_v()));

   sm.get_problems().add(sm_0l.get_problems());
}
*/



/**
 * Calculates \f$\lambda(Q)\f$ at the 1-loop level from the lightest
 * CP-even Higgs boson mass of the @ModelName@ by requiring that the
 * 1-loop Higgs pole masses are equal in both models.
 *
 * @param sm Standard Model
 * @param model @ModelName@ parameters
 * @param loop_order downwards matching loop order
 * @param idx Higgs index (in mass ordered Higgs multiplet)
 * /match_high_to_low_scale_sm_0l
 */
void match_high_to_low_scale_model(
   Standard_model& sm, const @ModelName@_mass_eigenstates& model, int loop_order, int idx)
{
   switch (loop_order){
      case 0: {
         match_high_to_low_scale_sm_0l(sm, model, idx);
         return;
      }

      case 1: {

         match_high_to_low_scale_sm_1l(sm, model, idx);
         return;
      }

      case 2: {

         match_high_to_low_scale_sm_1l(sm, model, idx);
         return;
      }

   }

   WARNING("Using only 1-loop-level matching, because 1-loop is not yet implemented.");
   //sm =  calculate_sm_0l( model, idx);
   // match_high_to_low_scale_model_1l(sm, model, idx);
}

/**
 * Calculates the gauge and Yukawa couplings and the SM-like VEV in
 * the @ModelName@ at the tree level from the known Standard Model
 * couplings and the SM vev.
 */
void match_low_to_high_scale_model_tree_level(
   @ModelName@_mass_eigenstates& model, const Standard_model& sm_input)
{
   auto sm = sm_input;
   sm.calculate_DRbar_masses();

   model.set_@hyperchargeCoupling@(sm.get_g1()*standard_model_info::normalization_g1/@ModelName@_info::normalization_@hyperchargeCoupling@);
   model.set_@leftCoupling@(sm.get_g2()*standard_model_info::normalization_g2/@ModelName@_info::normalization_@leftCoupling@);
   model.set_@strongCoupling@(sm.get_g3()*standard_model_info::normalization_g3/@ModelName@_info::normalization_@strongCoupling@);

   {
      auto MODEL = &model;
      const double VEV = sm.get_v();

@applyUserMatching@
   }

   Eigen::Matrix<double, 3, 3> upQuarksDRbar    = ZEROMATRIX(3,3);
   Eigen::Matrix<double, 3, 3> downQuarksDRbar  = ZEROMATRIX(3,3);
   Eigen::Matrix<double, 3, 3> downLeptonsDRbar = ZEROMATRIX(3,3);

   upQuarksDRbar.diagonal()    = sm.get_MFu();
   downQuarksDRbar.diagonal()  = sm.get_MFd();
   downLeptonsDRbar.diagonal() = sm.get_MFe();

@setYukawas@

   model.calculate_DRbar_masses();
}

/**
 * Imposes the user-defined matching conditions, defined in
 * MatchingScaleInput.
 */
void impose_user_matching(@ModelName@_mass_eigenstates& model, double VEV)
{
   {
      auto MODEL = &model;

@applyUserMatching@
   }
}

} // namespace @ModelName@_standard_model_matching
} // namespace flexiblesusy
