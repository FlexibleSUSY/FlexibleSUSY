// ====================================================================
// This file is part of FlexibleSUSY.
//
// FlexibleSUSY is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
//
// FlexibleSUSY is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with FlexibleSUSY.  If not, see
// <http://www.gnu.org/licenses/>.
// ====================================================================


/**
 * @file @ModelName@_decays.cpp
 * @brief implementation of particle decays in the @ModelName@
 *
 * Contains the definition of @ModelName@ decays class methods,
 * which calculate the decay rates for particles in the model.
 *
 * This file was generated at @DateAndTime@ with FlexibleSUSY
 * @FlexibleSUSYVersion@ (git commit: @FlexibleSUSYGitCommit@) and SARAH @SARAHVersion@ .
 */

#include <cmath>

#include <boost/range/algorithm.hpp>

#include "@ModelName@_decays.hpp"
#include "@ModelName@_info.hpp"
#include "one_loop_decay_diagrams.hpp"
#include "concatenate.hpp"
#include "dilog.hpp"
#include "trilog.hpp"
#include "Li4.hpp"
#include "config.h"
#include "thread_pool.hpp"
#include "wrappers.hpp"
#include "standard_model.hpp"

namespace flexiblesusy {

#define CLASSNAME @ModelName@_decays
#define PHYSICAL(parameter) model.get_physical().parameter

using namespace @ModelName@_cxx_diagrams;
using namespace @ModelName@_cxx_diagrams::fields;
namespace info = @ModelName@_info;
using namespace std::complex_literals;

const @ModelName@_decay_table& CLASSNAME::get_decay_table() const
{
   return decay_table;
}

void CLASSNAME::set_loop_corrections(const Decays_loop_corrections& loop_corrections_)
{
   loop_corrections = loop_corrections_;
}

const Decays_loop_corrections& CLASSNAME::get_loop_corrections() const
{
   return loop_corrections;
}

const Decays_problems& CLASSNAME::get_problems() const
{
   return problems;
}

void CLASSNAME::clear_problems()
{
   problems.clear();
}

void CLASSNAME::clear()
{
   clear_problems();
   decay_table.clear();
}

void CLASSNAME::calculate_decays()
{
#ifdef ENABLE_THREADS
@callAllDecaysFunctionsInThreads@
#else
@callAllDecaysFunctions@
#endif
}

double get_alphas(context_base const&  context)
{
   return Sqr(context.model.get_@gs_name@())/(4.*Pi);
}

double get_alpha(context_base const&  context)
{
   return Sqr(unit_charge(context))/(4.*Pi);
}

std::complex<double> f(double tau) {
   if (tau <= 1) {
      return Sqr(std::asin(std::sqrt(tau)));
   }
   else {
      return -0.25*(std::log((1.+std::sqrt(1.+1./tau))/(1.+std::sqrt(1.-1./tau))) - 1i*Pi);
   }
}
std::complex<double> fprime(double tau) {
   if (tau <= 1) {
      return std::asin(std::sqrt(tau))/std::sqrt(tau - Sqr(tau));
   }
   else {
      return 0.5*1i*(Pi + 1i*std::log(-1. + 2.*std::sqrt(-1. + tau)*std::sqrt(tau) + 2.*tau))/
             (std::sqrt(-1. + tau)*std::sqrt(tau));
   }
}

// eq. 2.5, 2.7 & 2.8 of https://arxiv.org/pdf/hep-ph/0509189.pdf
std::complex<double> delta_hAA2loopQCD(double mH, double mq, double mu) noexcept
{
   const double tau = Sqr(mH/(2.*mq));
   const std::complex<double> z = is_zero(tau) ? 1. : (std::sqrt(std::complex<double>(1. - 1./tau))-1.)/(std::sqrt(std::complex<double>(1.-1./tau))+1.);
   const std::complex<double> ln = std::log(z);
   const std::complex<double> li2p = dilog(z);
   const std::complex<double> li2m = dilog(-z);
   const std::complex<double> li3p = trilog(z);
   const std::complex<double> li3m = trilog(-z);
   const std::complex<double> li4p = Li4(z);
   const std::complex<double> li4m = Li4(-z);

   const std::complex<double> F0H = 3./(2.*Sqr(tau))*(tau+(tau-1.)*f(tau));

   const std::complex<double> F0HC1H =
      - z*(1. + z + Sqr(z) + Cube(z))/Power5(1.-z) * (108.*li4p + 144.*li4m - 64.*li3p*ln
            - 64.*li3m*ln + 14.*li2p*Sqr(ln) + 8.*li2m*Sqr(ln) + 1./12.*Power4(ln)
            + 4.*zeta2*Sqr(ln) + 16.*zeta3*ln + 18.*zeta4)
      + z*Sqr(1+z)/Power4(1.-z) * (-32.*li3m + 16.*li2m*ln - 4.*zeta2*ln)
      - 4.*z*(7.-2*z+7*Sqr(z))/Power4(1.-z)*li3p + 8.*z*(3.-2*z+3*Sqr(z))/Power4(1.-z)*li2p*ln
      + 2.*z*(5.-6.*z+5.*Sqr(z))/Power4(1.-z)*std::log(1.-z)*Sqr(ln) + z*(3.+25.*z-7.*Sqr(z)+3.*Cube(z))/(3.*Power5(1.-z))*Cube(ln)
      + 4.*z*(1.-14.*z+Sqr(z))/Power4(1.-z)*zeta3 + 12.*Sqr(z)/Power4(1.-z)*Sqr(ln) - 12.*z*(1.+z)/Power3(1.-z)*ln - 20.*z/Sqr(1.-z);
   const std::complex<double> F0HC2H = 3./Sqr(tau)*(tau+(tau-2.)*f(tau) - (tau-1.)*tau*fprime(tau));

   return (F0HC1H + F0HC2H*std::log(Sqr(mu/mq)))/F0H;
}


/* 1-loop BSM amplitudes
 *
 * Notes:
 *    - Since FS removes a factor of i from every vertex we reintroduce it
 *      calls to one loop amplitudes
 */

@calcAmplitudeSpecializationDefs@

// -------- specializations for decays needing higher order SM corrections --------

@create_SM_particle_usings@

namespace {

unsigned int number_of_active_flavours(double m)
{
   /*
   if (m < qedqcd.displayMbMb(){
      return 4.0;
   } else if (m < qedqcd.displayPoleMt()) {
      return 5.0;
   } else {
      return 6.0;
   }
   */
   return 5;
}

// eq. 2.7 of hep-ph/0503173
double calc_A(double b)
{
   const double log_b {std::log(b)};
   const double log_ratio {std::log((1 + b) / (1 - b))};

   return (1 + b * b) *
             (4. * dilog((1 - b) / (1 + b)) + 2. * dilog(-(1 - b) / (1 + b)) -
              3. * log_ratio * std::log(2 / (1 + b)) -
              2. * log_ratio * log_b) -
          3. * b * std::log(4. / (1 - b * b)) - 4. * b * log_b;
}

// eq. 2.6 of hep-ph/0503173
double calc_DeltaH(double b)
{
   return calc_A(b)/b + 1./(16*Power3(b)) * (
      3 + 34*b*b - 13*Power4(b)) * std::log((1+b)/(1-b)) + 3./(8.*b*b)*(7*b*b-1);
}

// eq. 2.6 of hep-ph/0503173
double calc_DeltaAH(double b)
{
   return calc_A(b)/b + 1./(16*b) * (19 + 2*b*b + 3*Power4(b))
      * std::log((1+b)/(1-b)) + 3./8.*(7-b*b);
}

// 2 and higher order
double calc_deltaqq(double alpha_s_red, double Nf)
{
   return
      // order alphas are taken into account with mass sependence somewhere alse
      0. * 17./3. * alpha_s_red
      + (35.94 - 1.36 * Nf) * Sqr(alpha_s_red)
      + (164.14 - 25.77 * Nf + 0.259 * Sqr(Nf)) * Power3(alpha_s_red)
      + (39.34 - 220.9 * Nf + 9.685 * Sqr(Nf) - 0.0205 * Power3(Nf)) * Power4(alpha_s_red);
}

/// Eq.(2.31) of hep-ph/0503172
double RT_general(double x) noexcept
{
   const std::complex<double> z(x, 0.0);

   return std::real(
      3.*(1. - 8.*z + 20.*z*z)/std::sqrt(4.*z - 1.)*std::acos((3.*z - 1.)/(2.*std::pow(z, 3./2.)))
      - (1. - z)/(2.*z)*(2. - 13.*z + 47.*z*z)
      - 3./2. * (1. - 6.*z + 4.*z*z)*std::log(z)
   );
}

/// Eq.(2.31) of hep-ph/0503172, including edge cases
double RT(double x) noexcept
{
   if (x < 0.25) {
      return RT_general(x);
   } else if (x == 0.25) {
      return std::numeric_limits<double>::quiet_NaN();
   } else if (x < 0.95) {
      return RT_general(x);
   } else if (x < 1) {
      const double d = x - 1;
      const double d2 = d*d;
      const double d4 = d2*d2;
      const double d5 = d4*d;
      return d5*(-3./10. + d*(13./20. + d*(-15./14. + d*(447./280. + d*(-95./42. + 523.*d/168)))));
   } else if (x == 1) {
      return 0;
   } else if (x < 1.01) {
      const double d = x - 1;
      return d*(39 + d*(75.0/2.0 + d*(-6 + 5.0/4.0*d)));
   }
   return RT_general(x);
}

} // anonymous namespace

@partialWidthSpecializationDefs@

template <>
double CLASSNAME::get_partial_width<H, A, A>(
      const context_base& context,
      const typename field_indices<H>::type& in_idx,
      const typename field_indices<A>::type& out1_idx,
      const typename field_indices<A>::type& out2_idx) const
{
   const auto amp = calculate_amplitude<H, A, A>(context, in_idx, out1_idx, out2_idx);
   const double mH = context.physical_mass<H>(in_idx);
   constexpr double ps {1./(8.*Pi)};
   constexpr double ps_symmetry {1./2.};
   const double color_gen_sqr = squared_color_generator<H, A, A>();
   const double flux = 0.5/mH;
   const auto res = flux * color_gen_sqr * ps * ps_symmetry * amp.square();

   return res;
}

template <>
double CLASSNAME::get_partial_width<H, A, Z>(
      const context_base& context,
      const typename field_indices<H>::type& in_idx,
      const typename field_indices<A>::type& out1_idx,
      const typename field_indices<Z>::type& out2_idx) const
{
   const double mH = context.physical_mass<H>(in_idx);
   const double mA = context.physical_mass<A>(out1_idx);
   const double mZ = context.physical_mass<Z>(out2_idx);

   const double ps {1./(8.*Pi) * sqrt(KallenLambda(1., Sqr(mA/mH), Sqr(mZ/mH)))};
   constexpr double ps_symmetry {1.};
   const double color_gen_sqr = squared_color_generator<H, A, Z>();
   const double flux = 0.5/mH;

   const auto amp = calculate_amplitude<H, A, Z>(context, in_idx, out1_idx, out2_idx);

   const auto res = flux * color_gen_sqr * ps * ps_symmetry * amp.square();

   return res;
}

template <>
double CLASSNAME::get_partial_width<H, G, G>(
      const context_base& context,
      const typename field_indices<H>::type& in_idx,
      const typename field_indices<G>::type& out1_idx,
      const typename field_indices<G>::type& out2_idx) const
{
   const auto amp = calculate_amplitude<H, G, G>(context, in_idx, out1_idx, out2_idx);
   const double mH = context.physical_mass<H>(in_idx);
   constexpr double ps {1./(8.*Pi)};
   constexpr double ps_symmetry {1./2.};
   const double color_fact = squared_color_generator<H, G, G>();
   const double flux = 0.5/mH;

   double result = flux * color_fact * ps * ps_symmetry * amp.square();

   // higher order corrections to CP-even Higgs
   // in models with CP-violating Higgs sector H multiplet contains
   // both H and A states, while the corrections below apply only to H.
   // Hence the if.
   if (!info::is_CP_violating_Higgs_sector) {

      // higher order QCD corrections


      const double mtpole {qedqcd.displayPoleMt()};
      // the analytic form o corrections is valid in mH/(2.*mtpole) -> 0
      if (mH/(2.*mtpole) < 0.4) {
         // number of active light flavours
         unsigned int Nf;
         if (mH > 5 && mH < mtpole) {
            Nf = 5;
         } else if (mH > mtpole) {
            Nf = 6;
         } else {
            throw;
         }

         // NLO, NNLO - eq. 11 of hep-ph/9705240
         const double deltaNLO {95./4. - 7./6.*Nf};

         const double log_mH2OverMT2 {std::log(Sqr(mH/mtpole))};

         const double deltaNNLO {
            149533./288. - 363./8.*zeta2 - 495./8.*zeta3 + 19./8.*log_mH2OverMT2
                  + Nf*(-4157./72 + 11./2.*zeta2 + 5./4.*zeta3 + 2./3.*log_mH2OverMT2)
                  + Nf*Nf*(127./108. - zeta2/6.)
         };
         // eq. 4.20 from Adam's thesis
         const double deltaNNNLO {467.683620788 + 122.440972222*log_mH2OverMT2 + 10.9409722222*Sqr(log_mH2OverMT2)};

         const double alpha_s_red = get_alphas(context)/Pi;

         switch (include_higher_order_corrections) {
            case SM_higher_order_corrections::enable:
               result *= 1. + deltaNLO*alpha_s_red + deltaNNLO*Sqr(alpha_s_red) + deltaNNNLO*Cube(alpha_s_red);
               break;
            case SM_higher_order_corrections::disable:
               break;
            default:
               break;
         }
      }
   }

   return result;
}

@decaysCalculationFunctions@
@partialWidthCalculationFunctions@

} // namespace flexiblesusy
