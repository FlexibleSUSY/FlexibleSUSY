(* :Copyright:

   ====================================================================
   This file is part of FlexibleSUSY.

   FlexibleSUSY is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published
   by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   FlexibleSUSY is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with FlexibleSUSY.  If not, see
   <http://www.gnu.org/licenses/>.
   ====================================================================

*)

Needs[# <> "`", FileNameJoin@{DirectoryName@$InputFileName, # <> ".m"}] &/@
   {"FlexibleSUSY", "Parameters", "TreeMasses", "Utils", "Vertices"};

(*@assumptions:
1) there are no quartic gluon vertices inside diagrams => one can calculate
colour factor for diagram separately from Lorentz factor
2) 4-point vertices are not supported *)
BeginPackage@"NPointFunctions`";

LoopLevel::usage = "
@brief Option for `NPointFunctions`NPointFunction`_.
       Encodes the loop level at which to calculate amplitudes.
       Def. 1 | 0";
UseCache::usage = "
@brief Option for `NPointFunctions`NPointFunction`_.
       Cache and reuse the expressions generated by ``FeynArts``/``FormCalc``.
       Def. True | False
@todo There is no difference between different ``KeepProcesses`` and
      ``OnShellFlag`` values.";
ZeroExternalMomenta::usage = "
@brief Option for `NPointFunctions`NPointFunction`_.
       Encodes whether to set the external momenta to zero or leave them
       undetermined.
       Def. True | False | OperatorsOnly | ExceptLoops";
OnShellFlag::usage = "
@brief Option for `NPointFunctions`NPointFunction`_.
       Use on-shell external fields or not.
       Def. True | False";
KeepProcesses::usage = "
@brief Option for `NPointFunctions`NPointFunction`_.
       Keeps specific processes in ``FeynArts``.";
Irreducible::usage = "
@brief Possible value for `NPointFunctions`KeepProcesses`_.
       Excludes irreducible topologies.";
Triangles::usage = "
@brief Possible value for `NPointFunctions`KeepProcesses`_.
       Keeps all triangle topologies.";
Regularize::usage = "
@brief Option for `NPointFunctions`NPointFunction`_.
       Encodes the regularization scheme to be used.";
GenericS::usage = "
@brief A symbol that acts as a placeholder for any scalar field.";
GenericF::usage = "
@brief A symbol that acts as a placeholder for any fermion field.";
GenericV::usage = "
@brief A symbol that acts as a placeholder for any vector field.";
GenericU::usage = "
@brief A symbol that acts as a placeholder for any ghost field.";
GenericSum::usage = "
@brief Represent a sum over a set of generic fields.";
GenericIndex::usage = "
@brief Represent an index of a generic field.";
LorentzIndex::usage = "
@brief Represent a Lorentz index of a generic field.";
DiracChain::usage = "
@brief Represents a dirac chain."
Mat::usage = "
@brief A wrapper around dirac chain(s)";

(*functions*)
{  VerticesForNPointFunction, CreateCXXHeaders,
   CreateCXXFunctions, NPointFunction};

SetAttributes[
{  LoopLevel,Regularize,UseCache,ZeroExternalMomenta,OnShellFlag,OperatorsOnly,
   ExceptLoops, KeepProcesses, Irreducible, Triangles,
   GenericS, GenericF, GenericV, GenericU,
   GenericSum, GenericIndex, LorentzIndex, Mat, DiracChain},
   {Protected}];

Begin@"`Private`";
secure::usage = "
@brief Makes definition for unexpected call for a function with the given name.
       Afterwards, protects the symbol from redefinitions.
@param sym A symbol (name of the function) to be secured.";
secure[sym:_Symbol] :=
   Protect@Evaluate@Utils`MakeUnknownInputDefinition@sym;
secure // secure;

Module[{all, dim, conj, bar, scalar, fermion, vector, ghost},
   all = TreeMasses`GetParticles[];
   dim = If[TreeMasses`GetDimension@#>1,#[{_Symbol}],#] &;
   conj = Through[Sequence[Susyno`LieGroups`conj,#&][#]] &;
   bar = Through[Sequence[SARAH`bar,#&][#]] &;
   scalar = Join[
      dim/@ Cases[all, _?TreeMasses`IsRealScalar],
      conj/@ dim/@ Cases[all, _?TreeMasses`IsComplexScalar]];
   fermion = Join[
      dim/@ Cases[all, _?TreeMasses`IsMajoranaFermion],
      bar/@ dim/@ Cases[all, _?TreeMasses`IsDiracFermion]];
   vector = Join[
      dim/@ Cases[all, _?TreeMasses`IsRealVector],
      conj/@ dim/@ Cases[all, _?TreeMasses`IsComplexVector]];
   ghost = bar/@ dim/@ Cases[all, _?TreeMasses`IsGhost];

   `type`scalarField = Alternatives@@ scalar;
   `type`fermionField = Alternatives@@ fermion;
   `type`vectorField = Alternatives@@ vector;
   `type`ghostField = Alternatives@@ ghost;
   `type`physicalField = Alternatives@@ Join[scalar, fermion, vector, ghost];
   `type`externalField = `type`physicalField /.
      Verbatim@_Symbol :> _String;
   `type`explicitFieldName = `type`physicalField /.
      (s:_Symbol)[{Verbatim@_Symbol}] :> s;
   SetAttributes[
      {  `type`externalField,
         `type`explicitFieldName,
         `type`scalarField,
         `type`fermionField,
         `type`vectorField,
         `type`physicalField,
         `type`ghostField},
      {Protected}];];

`type`wilsonBasis = {Rule[_String,_]..};
`type`colourProjector = Identity|SARAH`Delta;

`type`genericField =
   (GenericS | GenericF | GenericV | GenericU)[GenericIndex[_Integer]] |
   SARAH`bar[(GenericF | GenericU)[GenericIndex[_Integer]]] |
   Susyno`LieGroups`conj[(GenericS | GenericV)[GenericIndex[_Integer]]];
`type`process = {{__},{__}};
`type`subexpressions = {Rule[_Symbol,_]...};
`type`summation = {{`type`genericField,_}..};
`type`genericSum = GenericSum[{__},`type`summation];
`type`classFields = {{__}..};
`type`classCombinatoricalFactors = {__Integer};
`type`classColorFactors = {__};
`type`npf =
{  `type`process,
   {  {  {`type`genericSum..},
         {`type`classFields..},
         {`type`classCombinatoricalFactors..},
         {`type`classColorFactors..}},
      `type`subexpressions}};

`type`cxxToken = _String?(StringMatchQ[#,RegularExpression@"@[^@\n]+@"]&);
`type`cxxReplacementRules = {Rule[`type`cxxToken,_String]..};

`cxx`getLength[obj:`type`wilsonBasis] := ToString@Length@obj;
`cxx`getLength // secure;

getDirectories[] :=
{  {  #1, #3},
   {  FileNameJoin@{#2, SARAH`ModelName<>ToString@FlexibleSUSY`FSEigenstates},
      FileNameJoin@{#2, "ParticleNamesFeynArts.dat"},
      FileNameJoin@{#2, "ParticleNamespaces.m"}}} &@@
         ({  FileNameJoin@{#, "NPointFunctions"},
             FileNameJoin@{#, "FeynArts"},
             FileNameJoin@{#, "FormCalc"}} &@
               FileNameJoin@{  SARAH`$sarahCurrentOutputMainDir,
                               ToString@FlexibleSUSY`FSEigenstates});
getDirectories // secure;

getIndent[obj:_String] :=
   First@StringCases[obj,StartOfString~~"\n"...~~indent:" "...:>indent];
getIndent[obj:{__String}] :=
   First/@StringCases[obj,StartOfString~~"\n"...~~indent:" "...:>indent];
getIndent // secure;

conj::usage = "
@param obj Generic or explicit field.
@returns Conjugated field.";
conj[obj:`type`genericField] :=
Switch[Head@obj,
   SARAH`bar | Susyno`LieGroups`conj,
      obj[[1]],
   GenericS | GenericV,
      Susyno`LieGroups`conj@obj,
   GenericF | GenericU,
      SARAH`bar@obj];
conj[obj:`type`scalarField|`type`vectorField] :=
   Susyno`LieGroups`conj@obj;
conj[obj:`type`fermionField] :=
   SARAH`bar@obj;
conj // secure;

getIndex[obj:`type`genericField] :=
   (obj /. {SARAH`bar->Identity, Susyno`LieGroups`conj->Identity})[[1,1]];
getIndex // secure;

removeIndent[obj:_String] :=
   StringReplace[obj, StartOfLine~~getIndent[obj]->""];
removeIndent // secure;

replaceTokens[code:_String, rules:`type`cxxReplacementRules] :=
StringJoin[
   StringReplace[#, "\n"->StringJoin["\n", getIndent@#]] &/@
      StringReplace[StringSplit[removeIndent@code,"\n"],rules]~Riffle~"\n"];
replaceTokens // secure;

getProcess[obj:`type`npf] :=
   obj[[1]];
getProcess // secure;

getExternalMomenta[obj:`type`npf] :=
   DeleteDuplicates@Cases[{getGenericSums@obj, getSubexpressions@obj},
      HoldPattern@SARAH`Mom[_Integer,___], Infinity];
getExternalMomenta // secure;

getExternalIndices[obj:`type`npf] :=
   DeleteDuplicates@Flatten@Level[getProcess@obj, {4,5}];
getExternalIndices // secure;

getGenericSums::errSimpleOnly = "
Only the case without subexpressions is supported.";
getGenericSums::errBadIndex = "
Specified index(es) `1` is (are) outside the allowed region `2`.";
getGenericSums[obj:`type`npf] :=
   obj[[2,1,1]];
getGenericSums[obj:`type`npf, int:{__Integer}] :=
Module[{unique = DeleteDuplicates@int},
   {  getProcess@obj,
      {  {  getGenericSums[obj][[unique]],
            getClassFields[obj][[unique]],
            getClassCombinatoricalFactors[obj][[unique]],
            getClassColorFactors[obj][[unique]]},
         getSubexpressions@obj}}] /; And[
   Utils`AssertOrQuit[getSubexpressions@obj == {},
      getGenericSums::errSimpleOnly],
   Utils`AssertOrQuit[containsQ[#,int],
      getGenericSums::errBadIndex,int,#] &@
         getIndexRange[getClassCombinatoricalFactors@obj]];
getGenericSums // secure;

getIndexRange[obj:{___}] :=
   {1, Length@obj};
getIndexRange // secure;

containsQ[obj:{_Integer,_Integer}, int:_Integer] :=
   IntervalMemberQ[Interval@obj,int];
containsQ[obj:{_Integer,_Integer}, int:{__Integer}] :=
   And@@(containsQ[obj,#]&/@int);
containsQ // secure;

getClassFields[obj:`type`npf] :=
   obj[[2,1,2]];
getClassFields // secure;

getClassCombinatoricalFactors[obj:`type`npf] :=
   obj[[2,1,3]];
getClassCombinatoricalFactors // secure;

getClassColorFactors[obj:`type`npf] :=
   obj[[2,1,4]];
getClassColorFactors // secure;

getSubexpressions[obj:`type`npf] :=
   obj[[2,2]];
getSubexpressions // secure;

getName[obj:`type`physicalField] :=
Module[{nakedField},
   nakedField = obj /. {SARAH`bar->Identity, Susyno`LieGroups`conj->Identity};
   Switch[nakedField,
      _Symbol,
         nakedField,
      (_Symbol)[{_Symbol}],
         Head@nakedField]];
getName[obj:`type`genericField] :=
   Head[obj /. {SARAH`bar->Identity,Susyno`LieGroups`conj->Identity}];
getName // secure;

`cxx`getIndex[obj:`type`genericField] :=
   "i"<>StringTake[SymbolName[obj[[0]]],-1]<>ToString[obj[[1,1]]] &@ conj@obj;
`cxx`getIndex[obj:`type`physicalField] :=
Module[{nakedField=obj /. {SARAH`bar->Identity,Susyno`LieGroups`conj->Identity}},
   nakedField = obj /. {SARAH`bar->Identity, Susyno`LieGroups`conj->Identity};
   Switch[nakedField,
   _Symbol,
      "",
   (_Symbol)[{_Symbol}],
      StringDrop[ToString[nakedField[[1, 1]]],2]]];
`cxx`getIndex // secure;

getGenericFields[obj:`type`genericSum] :=
   First/@Last[obj];
getGenericFields[obj:`type`summation] :=
   First/@obj;
getGenericFields[objs:{`type`genericSum..}] :=
   (First/@Last@#)&/@objs;
getGenericFields // secure;

getExpression[obj:`type`genericSum] :=
   First@obj;
getExpression // secure;

getSummationData[obj:`type`genericSum] :=
   Last@obj;
getSummationData // secure;

getClassFieldRules[obj:`type`npf] :=
   MapThread[
      Function[fields,MapThread[Rule,{#1,fields}]]/@#2&,
      {getGenericFields@getGenericSums@obj, getClassFields@obj}];
getClassFieldRules // secure;

setSubexpressions[obj:`type`npf, newsubs:`type`subexpressions] :=
   ReplacePart[obj,{2,2}->newsubs];
setSubexpressions // secure;

applySubexpressions[obj:`type`npf] :=
Module[{result},
   If[{} === getSubexpressions@obj, Return@obj];
   WriteString["stdout"~OutputStream~1,"Applying subexpressions ... "];
   result = setSubexpressions[
      ReplacePart[obj,
         {2,1,1}->ReplaceRepeated[getGenericSums@obj,getSubexpressions@obj]],
      {}];
   WriteString["stdout"~OutputStream~1,"done\n"];
   result];
applySubexpressions // secure;

NPointFunction::usage = "
@brief Calculates the n-particle amplitude.
@param inFields A list of incoming fields.
@param outFields A list of outgoing fields.
@param LoopLevel The loop level of calculation.
@param Regularize The regularization scheme.
@param UseCache Whether read and write the result from and to the cache.
@param ZeroExternalMomenta Defines how to treat external momenta.
@param KeepProcesses A list or a single symbol of topologies to keep.
@returns Corresponding n-particle amplitude.";
Options[NPointFunction] =
{  LoopLevel -> 1,
   Regularize -> FlexibleSUSY`FSRenormalizationScheme,
   UseCache -> True,
   ZeroExternalMomenta -> True,
   OnShellFlag -> True,
   KeepProcesses -> {},
   Observable -> None};
NPointFunction[inFields_, outFields_, opts:OptionsPattern[]] :=
Module[{ nPointFunctionsDir, feynArtsModel, particleNamesFile,
      particleNamespaceFile, formCalcDir, subKernel, currentDirectory,
      nPointFunction},
   {  {nPointFunctionsDir, formCalcDir},
      {feynArtsModel, particleNamesFile, particleNamespaceFile}} =
         getDirectories[];
   If[!DirectoryQ@#, CreateDirectory@#]&@nPointFunctionsDir;
   If[OptionValue@UseCache,
      nPointFunction = CachedNPointFunction[
         inFields,outFields,nPointFunctionsDir,
         {Join[inFields, outFields], OptionValue@KeepProcesses}];
      If[nPointFunction =!= Null, Return@nPointFunction];];
   If[!FileExistsQ[feynArtsModel <> ".mod"],
      subKernel = LaunchSubkernelFor@"creation of FeynArts model file";
      makeModelFile@subKernel;
      writeNamespaceFile@particleNamespaceFile;
      CloseKernels@subKernel;];
   subKernel = LaunchSubkernelFor@"FormCalc code generation";
   SetSharedFunction[subWrite, Print];
   With[{path = $Path,
         data = {formCalcDir, feynArtsModel, particleNamesFile,
            particleNamespaceFile,
            convertFields[inFields, particleNamesFile],
            convertFields[outFields, particleNamesFile]},
         options = {OptionValue@Observable,
            OptionValue@LoopLevel,
            SymbolName/@If[List=!=Head@#, {#}, #]&@OptionValue@KeepProcesses,
            OptionValue@ZeroExternalMomenta,
            OptionValue@OnShellFlag,
            OptionValue@Regularize},
         meta = FlexibleSUSY`$flexiblesusyMetaDir},
      nPointFunction = RemoveEmptyGenSums@ParallelEvaluate[
         $Path = path;
         Get@FileNameJoin@{meta, "NPointFunctions", "internal.m"};
         NPointFunction[data, options],
         subKernel,
         DistributedContexts -> None];];
   CloseKernels@subKernel;
   UnsetShared[subWrite, Print];

   If[OptionValue@UseCache,
      CacheNPointFunction[
         nPointFunction, nPointFunctionsDir,
         {Join[inFields, outFields], OptionValue@KeepProcesses}];];
   nPointFunction] /; inputCheck[inFields,outFields,opts];
NPointFunction::errFields = "
The field '`1`' must belong to (bar or conj can be applied):
   `2`.";
NPointFunction::errOptions = "
Unknown option(s):
   `1`.
Currently supported options are:
   `2`.";
NPointFunction::errLoopLevel = "
Currently loop level 1 is supported.";
NPointFunction::errRegularize = "
Unknown regularization scheme `1`.
Supported schemes:
   FlexibleSUSY`.`DRbar,
   FlexibleSUSY`.`MSbar.";
NPointFunction::errUseCache=
"UseCache must be either True or False.";
NPointFunction::errZeroExternalMomenta=
"ZeroExternalMomenta must be True, False, ExceptLoops, OperatorsOnly.";
NPointFunction::errOnShellFlag=
"OnShellFlag must be either True or False.";
NPointFunction // secure;

subWrite::usage = "
@brief Prints a string.
@note ``SetSharedFunction`` does not cause names leaking.";
subWrite[str_String] := WriteString["stdout"~OutputStream~1,str];
subWrite // secure;

inputCheck[inFields:{__},outFields:{__},opts___] :=
Module[{aoq, ip, allowedParticles, options, unknown},
   aoq = Utils`AssertOrQuit;
   ip = TreeMasses`IsParticle;
   (* TODO add |_?TreeMasses`IsVector *)
   allowedParticles = Cases[
      TreeMasses`GetParticles[],
      _?TreeMasses`IsScalar|_?TreeMasses`IsFermion];
   aoq[ip@#, NPointFunction::errFields, #, allowedParticles] &/@ inFields;
   aoq[ip@#, NPointFunction::errFields, #, allowedParticles] &/@ outFields;
   options = Options[NPointFunction][[All,1]];
   unknown = FilterRules[{opts}, Except@options];
   aoq[unknown === {}, NPointFunction::errOptions, unknown, options];
   (*Now we know that all options are iside allowed list.*)
   Cases[{opts}, Rule[LoopLevel, x_] :>
      aoq[x===1, NPointFunction::errLoopLevel]];
   Cases[{opts}, Rule[Regularize, x_] :>
      aoq[MemberQ[{FlexibleSUSY`MSbar, FlexibleSUSY`DRbar}, x],
         NPointFunction::errRegularize, x]];
   Cases[{opts}, Rule[UseCache, x_] :>
      aoq[x===True || x===False, NPointFunction::errUseCache]];
   Cases[{opts}, Rule[ZeroExternalMomenta,x_] :>
      aoq[MemberQ[{True, False, OperatorsOnly, ExceptLoops}, x],
         NPointFunction::errZeroExternalMomenta]];
   Cases[{opts}, Rule[OnShellFlag, x_] :>
      aoq[x===True || x===False, NPointFunction::errOnShellFlag]];
   True];
inputCheck // secure;

VerticesForNPointFunction::usage = "
@brief Return a list of all vertices needed to calculate a given
       n-point correlation function.
@param obj The n-point correlation function.
@returns A list of all vertices needed for the calculation.";
VerticesForNPointFunction[obj:`type`npf] :=
Module[{v, getVertex},
   getVertex[vertGen_, rules_] := vertGen/.#&/@rules;
   v = DeleteDuplicates@
      Cases[#, SARAH`Cp[f__] :> {f}, Infinity, Heads->True] &/@
         getGenericSums@obj;
   DeleteDuplicates[
      Vertices`StripFieldIndices/@#&/@
         Flatten[MapThread[getVertex, {v, getClassFieldRules@obj}],2]]];
VerticesForNPointFunction // secure;

GetSARAHModelName::usage = "
@returns The ``SARAH`` model name as to be passed to ``SARAH`Start``.";
GetSARAHModelName[] :=
If[SARAH`submodeldir =!= False,
      SARAH`modelDir <> "-" <> SARAH`submodeldir,
      SARAH`modelDir];
GetSARAHModelName // secure;

LaunchSubkernelFor::usage = "
@brief Tries to launch a subkernel without errors.
       If it fails, tries to explain the reason using message.
@param message String, which contains description of activity for which this
       subkernel is launched for.
@returns A subkernels name.
@note ``Mathematica 7`` returns ``KernelObject[__]``, ``Mathematica 11.3``
      returns ``{KernelObject[__]}``.
@note For ``Mathematica 7`` some functions have the same names as in
      ``SARAH``";
LaunchSubkernelFor::errKernelLaunch = "
Unable to launch subkernel(s) during calculations for
   `1`.";
LaunchSubkernelFor[message_String] /; $VersionNumber===7.0 :=
Module[{kernelName},
   Off[Parallel`Preferences`add::shdw,
      Parallel`Preferences`set::shdw,
      Parallel`Preferences`list::shdw,
      Parallel`Preferences`tr::shdw,
      Parallel`Protected`processes::shdw,
      SubKernels`Description::shdw];
   kernelName = Utils`EvaluateOrQuit[
      LaunchKernels[1],
      LaunchSubkernelFor::errKernelLaunch, message];
   On[Parallel`Preferences`add::shdw,
      Parallel`Preferences`set::shdw,
      Parallel`Preferences`list::shdw,
      Parallel`Preferences`tr::shdw,
      Parallel`Protected`processes::shdw,
      SubKernels`Description::shdw];
   kernelName];
LaunchSubkernelFor[message_String] :=
Module[{kernelName},
   kernelName = Utils`EvaluateOrQuit[
      LaunchKernels[1],
      LaunchSubkernelFor::errKernelLaunch, message];
   If[Head@kernelName === List, kernelName[[1]], kernelName]];
LaunchSubkernelFor // secure;

CacheNameForMeta::usage = "
@param nPointMeta the given meta information.
@returns The name of the cache file for given meta information.";
CacheNameForMeta[nPointMeta:{__}] :=
   Utils`StringJoinWithSeparator[Flatten@nPointMeta, "", SymbolName]<>".m";
CacheNameForMeta // secure;

CacheNPointFunction::usage = "
@brief Writes a given n-point function to the cache.
@param nPointFunction The given n-point function.
@param cacheDir The directory to save cache.
@param nPointMeta The meta information about the given n-point function.";
CacheNPointFunction[nPointFunction_,cacheDir_,nPointMeta:{__}] :=
Module[{nPointFunctionsFile, fileHandle, nPointFunctions, position},
   nPointFunctionsFile = FileNameJoin@{cacheDir,CacheNameForMeta@nPointMeta};
   If[FileExistsQ@nPointFunctionsFile,
      nPointFunctions = Get@nPointFunctionsFile,
      nPointFunctions = {}];
   position = Position[nPointFunctions[[All,1]],nPointFunction[[1]]];
   If[Length@position === 1,
      nPointFunctions[[position[[1]]]] = nPointFunction,
      AppendTo[nPointFunctions, nPointFunction]];
   fileHandle = OpenWrite@nPointFunctionsFile;
   Write[fileHandle,nPointFunctions];
   Close@fileHandle;];
CacheNPointFunction // secure;

CachedNPointFunction::usage = "
@brief Retrieve an n-point correlation function from the cache.
@param inFields the incoming fields of the n-point correlation function.
@param outFields the outgoing fields of the n-point correlation function.
@param cacheDir the directory to save cache.
@param nPointMeta the meta information of the n-point correlation function.
@returns The n-point function from cache or ``Null`` if the function is missing.";
CachedNPointFunction[inFields_,outFields_,cacheDir_,nPointMeta:{__}] :=
Module[{nPointFunctionsFile, nPointFunctions, position},
   nPointFunctionsFile = FileNameJoin@{cacheDir,CacheNameForMeta@nPointMeta};
   If[!FileExistsQ@nPointFunctionsFile,Return@Null];
   nPointFunctions = Get@nPointFunctionsFile;
   position = Position[Vertices`StripFieldIndices[ nPointFunctions[[All,1]] ],
      {inFields, outFields}];
   If[Length@position == 1,nPointFunctions[[ position[[1,1]] ]],Null]];
CachedNPointFunction // secure;

makeModelFile::usage = "
@brief Generate the ``FeynArts`` model file on a given subkernel.";
makeModelFile[kernel:_Parallel`Kernels`kernel|_KernelObject] :=
With[{currentPath = $Path,
      currentDir = Directory[],
      fsMetaDir = FlexibleSUSY`$flexiblesusyMetaDir,
      sarahInputDirs = SARAH`SARAH@SARAH`InputDirectories,
      sarahOutputDir = SARAH`SARAH@SARAH`OutputDirectory,
      SARAHModelName = GetSARAHModelName[],
      eigenstates = FlexibleSUSY`FSEigenstates},
   Print["Generating FeynArts model file ..."];
   SetSharedFunction[Print];
   ParallelEvaluate[
      $Path = currentPath;
      SetDirectory@currentDir;
      Get@FileNameJoin@{fsMetaDir, "NPointFunctions", "createFAModelFile.m"};
      NPointFunctions`CreateFAModelFile[sarahInputDirs,sarahOutputDir,
         SARAHModelName, eigenstates];,
      kernel, DistributedContexts -> None];
   UnsetShared[Print];
   Print["Generating FeynArts model file ... done"];];
makeModelFile // secure;

writeNamespaceFile::usage = "
@brief Write a file containing all field names and the contexts in which they
       live in ``Mathematica``.
@note This is necessary because ``SARAH`` puts fields into different
      contexts.";
writeNamespaceFile[fileName_String] :=
Module[{fileHandle = OpenWrite@fileName},
   Write[fileHandle, {ToString@#, Context@#} & /@ TreeMasses`GetParticles[]];
   Close@fileHandle;];
writeNamespaceFile // secure;

convertFields::usage = "
@brief Changes given ``SARAH`` fields to ``FeynArts`` ones.
@param fields List of ``SARAH`` fields.
@param particles A ``String`` name of a file, which is created by ``SARAH``
       and contains ``FeynArts`` particle names.
@returns A set of ``FeynArts`` names (each as ``String``) for given ``SARAH``
         fields.";
convertFields[fields_, particles_String] :=
   Module[{unique, faNames},
      unique = DeleteDuplicates[
         CXXDiagrams`RemoveLorentzConjugation[#]&/@ fields];
      faNames = Flatten[
         StringCases[Utils`ReadLinesInFile@particles,
            ToString@# ~~ ": " ~~ x__ ~~ "]" ~~ ___ :>
               "FeynArts`" <> x <> "]"]&/@ unique];
      fields /. MapThread[Rule, {unique, faNames}] /.
         {  SARAH`bar@field_String :> "-" <> field,
            Susyno`LieGroups`conj@field_String :> "-" <> field}];
convertFields // secure;

RemoveEmptyGenSums::usage = "
@brief Sometimes after ``FeynArts`` + ``FormCalc`` calculation some generic sums
       are empty.
       This means that one can simply remove them (as well as corresponding
       colour/combinatoric factors and field substitution rules).
       This work is done by this function.
@param npfObject n-point function object to clean.
@returns Cleaned from empty GenericSums npfObject.";
RemoveEmptyGenSums[npfObject:`type`npf]:=npfObject;
RemoveEmptyGenSums[
   {  fields:{{__},{__}},
      {  {  sums:{GenericSum[_,{___}]..},
            rules:{{{__}..}..},
            comb:{{__Integer}..},
            col:{{__}..}},
         subs:{Rule[_,_]...}}}]:=
Module[{poss=Position[sums,GenericSum[{0},{}]]},
   Print["Removing zero GenericSum at positions ",
      Utils`StringJoinWithSeparator[Flatten@poss,", "],"."];
   {fields,{Delete[#,poss]&/@{sums,rules,comb,col},subs}}];
RemoveEmptyGenSums // secure;

CreateCXXHeaders::usage = "
@brief Create the ``C++`` code for the necessary headers.
@returns The ``C++`` code for the necessary headers.";
CreateCXXHeaders[] :=
replaceTokens["
   #include \"loop_libraries/loop_library.hpp\"
   #include \"cxx_qft/@ModelName@_npointfunctions_wilsoncoeffs.hpp\"
   #include \"concatenate.hpp\"
   #include <limits>
   #include <boost/fusion/include/at_key.hpp>
   #include <boost/core/is_same.hpp>",
   {"@ModelName@"->FlexibleSUSY`FSModelName}];
CreateCXXHeaders // secure;

CreateCXXFunctions::usage = "
@brief Given a list of n-point correllation functions, a list
       of ``C++`` function names and a list of colour factor projections
       create the ``C++`` code for the numerical evaluation of the
       n-point correllation functions.
@param npf n-point correlation function object.
@param name function name
@param colourProjector Colour projection function that represents color
       structure of ampitudes.
@param wilsonBasis Basis for matching.
@returns A list of the form ``{prototypes, definitions}`` containing
         the corresponding ``C++`` code.";
CreateCXXFunctions[
   npf:`type`npf,
   name:_String,
   colourProjector:`type`colourProjector,
   wilsonBasis:`type`wilsonBasis:{"value"->"dummy string"}] :=
Module[{mainFunction, prototype, definition},
   mainFunction = "std::array<std::complex<double>,"<>
      `cxx`getLength@wilsonBasis<>"> "<>name<>"("<>#<>")"&;
   setHelperClassName@npf;
   setBasis@wilsonBasis;
   prototype = mainFunction@`cxx`arguments[npf,Default]<>";";
   definition =
      `cxx`npfClass[applySubexpressions@npf,colourProjector] <> "\n\n" <>
      mainFunction@`cxx`arguments@npf <>
      "{\n   "<>$helperClassName<>
      " helper{ model, indices, momenta };\n   return helper.calculate();\n}";
   {prototype, definition}] /; And@@
      (Utils`AssertOrQuit[Length@wilsonBasis === Length@#,
         CreateCXXFunctions::errNoMatch]&/@getExpression/@getGenericSums@npf);
CreateCXXFunctions::errNoMatch = "
Length of basis and the given n-point function one does not match."
CreateCXXFunctions // secure;

`cxx`arguments::usage = "
@brief Returns the ``C++`` arguments that the ``C++`` version of the given n-point
       correlation function shall take.
       ``Default`` value of zero for all external momenta is chosen if the
       second parameter is ``Default``.
@param npf The given n-point correlation function
@param control String that sets up the type of argument string
@returns The ``C++`` arguments that the ``C++`` version of the given n-point
         correlation function shall take.";
`cxx`arguments[npf:`type`npf,control:Null|Default:Null] :=
   "const "<>#1<>" &model,"<>
   " const std::array<int,"<>#2<>"> &indices,"<>
   " const std::array<Eigen::Vector4d,"<>#3<>"> &momenta"<>
   If[control === Default," = { "<>#4<>" }",""]&[
      FlexibleSUSY`FSModelName<>"_mass_eigenstates",
      ToString@Length@getExternalIndices@npf,
      ToString@#,
      Utils`StringJoinWithReplacement@Array["Eigen::Vector4d::Zero()",#]] &@
         Length@getExternalMomenta@npf;
`cxx`arguments // secure;

$basis = {"value"->"dummy string"};
$basis ~ SetAttributes ~ {Protected};

setBasis[obj:`type`wilsonBasis] :=
(  Unprotect@$basis;
   $basis = obj;
   Protect@$basis;);
setBasis // secure;

$helperClassName = "";
$helperClassName ~ SetAttributes ~ {Protected};

setHelperClassName::usage = "
@brief Sets the ``C++`` name for the helper class of a n-point function.
@param obj n-point function object.";
setHelperClassName[obj:`type`npf] :=
Module[{fieldNames = Vertices`StripFieldIndices/@Join@@getProcess[obj]},
   Unprotect@$helperClassName;
   $helperClassName = "nPoint" <>
      StringJoin@Map[ToString,fieldNames/.a_[b_]:>Sequence@@{a,b}] <> "_" <>
      ToString@Ceiling[10^6*AbsoluteTime[]];
   Protect@$helperClassName;];
setHelperClassName // secure;

`cxx`npfClass::usage = "
@param npf The given n-point correlation function.
@param projCol The colour factor projection to be applied for the
       given n-point correlation function.
@returns The ``C++`` code for the helper class of n-point function.";
`cxx`npfClass[npf:`type`npf, projCol:`type`colourProjector] :=
Module[{genSums, extIndices, numberOfMomenta, genFields, genSumNames},
   genSums = getGenericSums@npf;
   extIndices = getExternalIndices@npf;
   numberOfMomenta = Length[getExternalMomenta@npf];
   genFields = DeleteDuplicates[Flatten@getClassFieldRules@npf /. Rule[x_,_] :> x];
   code = "
   class @ClassName@ : public @Context@
   {
      using generic_sum_base = @Context@;

      template<class GenericFieldMap>
      struct subexpression_base :
      generic_sum_base, index_map_interface<GenericFieldMap>
      {
         subexpression_base( const subexpression_base & ) = default;

         subexpression_base( const generic_sum_base &gsb,
            const typename field_index_map<GenericFieldMap>::type &fim ) :
         generic_sum_base( gsb ), index_map_interface<GenericFieldMap>( fim )
         {}
      }; // End of subexpression_base<GenericFieldMap>

      @KeyStructsInitialization@

      @GenericSums@

      public:
      @ClassName@( @Arguments@ ) :
      @Context@ { model, indices, momenta }
      {}

      @CalculateFunction@
   }; // End of @ClassName@";
   genSumNames = Array["genericSum"<>ToString@#&,Length@genSums];
   `cxx`setRules[extIndices,genFields];
   replaceTokens[code,
      {  "@ClassName@"->$helperClassName,
         "@Context@"->"correlation_function_context<"<>
            ToString@Length@extIndices<>","<>ToString@numberOfMomenta<>">",
         "@KeyStructsInitialization@"->`cxx`initializeKeyStructs@genFields,
         "@GenericSums@"->`cxx`genericSum[npf,projCol,genSumNames],
         "@Arguments@"->`cxx`arguments@npf,
         "@CalculateFunction@"->`cxx`calculateFunction@genSumNames}]];
`cxx`npfClass // secure;

`cxx`initializeKeyStructs::usage = "
@brief Generates required ``C++`` code for key structs initialization.
@param fields List of generic fields.
@returns ``C++`` code for subexpression if generic fields present there.";
`cxx`initializeKeyStructs[fields:{`type`genericField..}]:=
   Utils`StringJoinWithSeparator[
      "struct "<>#<>" {};"&/@`cxx`genericFieldKey/@fields,
      "\n"];
`cxx`initializeKeyStructs // secure;

Module[{rules = {{}}},

`cxx`setRules::usage = "
@brief Generate a list of rules for translating Mathematica expressions to
       ``C++`` ones.
@param extIndices The external indices of an n-point correlation function.
@param genericFields The generic fields appearing in an n-point correlation
       function.
@returns A list of rules for translating Mathematica expressions to ``C++`` ones.
@note All couplings have to be multiplied by ``I``.";
`cxx`setRules[extIndices:{___Symbol},genericFields:{`type`genericField..}] :=
Module[{externalIndexRules, wrap, index, genericRules, massRules, couplingRules},
   externalIndexRules = MapThread[Rule,
      {  extIndices,
         Array["i"<>ToString[#]&,Length@extIndices]}];
   genericRules=Flatten[Thread@Rule[
      {conj[#],#},
      {  `cxx`fieldName[conj@#][`cxx`getIndex@#],
         `cxx`fieldName[#][`cxx`getIndex@#]}] &/@ genericFields];
   wrap[fields__] := Utils`StringJoinWithSeparator[`cxx`fieldAlias/@{fields},", "];
   index[fields__] := Utils`StringJoinWithSeparator[`cxx`fieldIndices/@{fields},", "];

   couplingRules =
   {  SARAH`Cp[fields__][1] :>
         ("NPF_S(" <> wrap@fields <>") NPF_I(" <> index@fields <> ")"),
      SARAH`Cp[fields__][SARAH`PL] :>
         ("NPF_L(" <> wrap@fields <>") NPF_I(" <> index@fields <> ")"),
      SARAH`Cp[fields__][SARAH`PR] :>
         ("NPF_R(" <> wrap@fields <>") NPF_I(" <> index@fields <> ")"),
      (* On ``C++`` level this vertex is such, that _D should have 0 and 1.
       * The first position corresponds to the momenta with + sign.
       * The second position corresponds to the momenta with - sign.
       * Example: Cp[S1, S2, V][Mom@S1 - Mom@S2] leads to
       *          NPF_MD(S1, S2, V) NPF_D(0, 1) <indices>
       * Example: Cp[S1, S2, V][Mom@S2 - Mom@S1] leads to
       *          NPF_MD(S1, S2, V) NPF_D(1, 0) <indices>*)
      SARAH`Cp[fields__][SARAH`Mom[f1_] - SARAH`Mom[f2_]] :>
      StringReplace["NPF_MD(`1`) NPF_D(`2`, `3`) NPF_I(`4`)",
         {  "`1`"->ToString@wrap@fields,
            "`2`"->ToString[First@@Position[{fields},f1,{1}]-1],
            "`3`"->ToString[First@@Position[{fields},f2,{1}]-1],
            "`4`"->ToString@index@fields}],
      SARAH`Cp[fields__][SARAH`g[_, _]] :>
         ("NPF_G(" <> wrap@fields <>") NPF_I(" <> index@fields <> ")"),
      SARAH`Cp[fields__][(SARAH`Mom[f2_, _]-SARAH`Mom[f1_, _])*SARAH`g[_,_],
         (SARAH`Mom[f1_,_]-SARAH`Mom[f3_,_])*SARAH`g[_,_],
         (SARAH`Mom[f3_,_]-SARAH`Mom[f2_,_])*SARAH`g[_,_]] :>
         ("NPF_T(" <> wrap@fields <>") NPF_I(" <> index@fields <> ")")};

   massRules = {SARAH`Mass[f_] :>
      StringJoin["context.mass<",`cxx`fieldAlias@f,">(",
         `cxx`fieldIndices@f,")"]};

   rules = {externalIndexRules, massRules, couplingRules, genericRules};];
`cxx`setRules // secure;

`cxx`applyRules[obj_] :=
StringReplace[
   Parameters`ExpressionToString[Fold[ReplaceAll, obj, rules]],
   "\"" -> ""];
`cxx`applyRules // secure;];

Module[{strip, sandwich, n},

strip[f_] := f /. {SARAH`bar -> Identity, Susyno`LieGroups`conj -> Identity};

sandwich[f_] = Switch[Head@f,
   SARAH`bar, "typename bar<" <> # <> ">::type",
   Susyno`LieGroups`conj, "typename conj<" <> # <> ">::type",
   _, #]&;

`cxx`fieldName::usage = "
@brief Returns a ``C++`` representation for a field expression or a field name.
@param f A generic or external field, or an explicit field name.
@returns A ``C++`` representation for a field.";
`cxx`fieldName[
   f:`type`explicitFieldName|`type`externalField|`type`physicalField] :=
(  n = strip@f;
   sandwich[f]["fields::" <> ToString@Switch[n, _Symbol, n, _, Head@n]]);

`cxx`fieldName[f:`type`genericField] :=
(  n = strip@f;
   sandwich[f]["g"<>StringTake[ToString@Head@n, -1] <> ToString@Part[n, 1, 1]]);

`cxx`fieldName // secure;];

`cxx`fieldIndices::usage = "
@brief Return the ``C++`` expression for the given field.
@param field The given field.
@returns The ``C++`` expression for the given field.
@note Saves its previous calls to improve the speed.";
`cxx`fieldIndices[SARAH`bar[field_]] := `cxx`fieldIndices[SARAH`bar[field]] =
   `cxx`fieldIndices@field;
`cxx`fieldIndices[Susyno`LieGroups`conj[field_]] :=
   `cxx`fieldIndices[Susyno`LieGroups`conj[field]] =
      `cxx`fieldIndices@field;
`cxx`fieldIndices[head_[GenericIndex[index_Integer]]] :=
   `cxx`fieldIndices[head[GenericIndex[index]]] =
      "i"<>StringTake[SymbolName@head,-1]<>ToString@index;
`cxx`fieldIndices[field_] := `cxx`fieldIndices[field] =
   If[Length@field === 0, "i0", field[[1, 1]]];
`cxx`fieldIndices // Utils`MakeUnknownInputDefinition;
`cxx`fieldIndices ~ SetAttributes ~ {Locked};

`cxx`genericFieldKey::usage = "
@brief Determines ``C++`` key type for a generic field.
@param genericField Given generic field.
@returns ``C++`` key type of a generic field(s).";
`cxx`genericFieldKey[fields:{__}] :=
   Utils`StringJoinWithSeparator[fields, ", ", `cxx`genericFieldKey];
`cxx`genericFieldKey[head_[GenericIndex[index:_Integer]]] :=
   SymbolName@head<>ToString@index<>"Key";
`cxx`genericFieldKey // secure;

getColourFactor::usage = "
@brief Extracts the colour factor for a given colour structure.";
getColourFactor::errMultipleColourStructures = "
There are different colour projectors inside colour factors:
   `1`.";
getColourFactor::errNotNumber = "
After projection element
   `1`
still is not a number."
getColourFactor::warnTryingIdentity = "
Warning: There are no colour projectors of the given type.
Trying to apply Identity."
getColourFactor[colourfactors:{`type`classColorFactors..},
   projection:`type`colourProjector] :=
Module[{projectedFactors,uniqueColourStructs},
   projectedFactors=
   If[projection === Identity,
      colourfactors,
      uniqueColourStructs = DeleteDuplicates@Cases[colourfactors,
         projection[__],
         Infinity];
      Utils`AssertOrQuit[Length@uniqueColourStructs<=1,
         getColourFactor::errMultipleColourStructures,
         uniqueColourStructs];
      If[Length@uniqueColourStructs===0,
         Print[getColourFactor::warnTryingIdentity];
         colourfactors,
         colourfactors/.Rule[uniqueColourStructs[[1]],1]]];
   Utils`AssertOrQuit[NumericQ@#,getColourFactor::errNotNumber,#]&/@
      Flatten[projectedFactors,2];
   projectedFactors];
getColourFactor // secure;

`cxx`genericSum::usage = "
@brief Create the ``C++`` code form of a generic sums.
@param obj n-point function object.
@param colourProjector An expression, representing the projector.
@param genSumNames Set of names for generic sums.";
`cxx`genericSum::errColours = "
Colour factor is not a number after projection: `1`";
`cxx`genericSum[obj:`type`npf, colourProjector:`type`colourProjector,
   genSumNames:{__String}] :=
Utils`StringJoinWithSeparator[
   MapThread[
      `cxx`genericSum[##,getSubexpressions@obj,obj]&,
      {  getGenericSums@obj,
         getClassFields@obj,
         getClassCombinatoricalFactors@obj,
         getColourFactor[getClassColorFactors@obj,colourProjector],
         genSumNames}],
   "\n\n"];
`cxx`genericSum[
   sum:`type`genericSum,
   genericInsertions:`type`classFields,
   combinatorialFactors:`type`classCombinatoricalFactors,
   colourFactors:{__?NumericQ},
   genSumName_String,
   subexpressions:`type`subexpressions,
   npf:`type`npf] :=
replaceTokens["
   template<class GenericFieldMap>
   struct @GenericSum_NAME@_impl : generic_sum_base {
      @GenericSum_NAME@_impl( const generic_sum_base &base ) :
      generic_sum_base( base ) {
      } // End of constructor @GenericSum_NAME@_impl

      std::array<std::complex<double>,@WilsonBasisLength@> operator()( void ) {
         using boost::mpl::at;
         using boost::fusion::at_key;
         @GenericFieldShortNames@

         @ExternalIndices@
         typename field_index_map<GenericFieldMap>::type index_map;
         const context_with_vertices &context = *this;
         @InitializeOutputVars@

         @SummationOverGenericFields@

         return @ReturnOutputVars@;
      } // End of operator()( void )
   }; // End of struct @GenericSum_NAME@_impl<GenericFieldMap>

   std::array<std::complex<double>,@WilsonBasisLength@> @GenericSum_NAME@( void ) {
      using GenericKeys = boost::mpl::vector< @GenericKeys@ >;
      using GenericInsertions = boost::mpl::vector<
         @ClassInsertions@
         >;
      using combinatorial_factors = boost::mpl::vector<
         @CombinatoricalFactors@
         >;
      using colour_factors = boost::mpl::vector<
         @ColorFactors@
         >;
      return accumulate_generic<
         GenericKeys,
         GenericInsertions,
         combinatorial_factors,
         colour_factors,
         boost::mpl::int_<@WilsonBasisLength@>,
         @GenericSum_NAME@_impl
         >( *this );
   } // End of function @GenericSum_NAME@()",
   {  "@GenericSum_NAME@"->genSumName,
      "@GenericFieldShortNames@"->`cxx`shortNames@getGenericFields@sum,
      "@ExternalIndices@"->`cxx`initializeExternalIndices@npf,
      "@InitializeOutputVars@"->Utils`StringJoinWithSeparator[
         "std::complex<double> "<>#<>" = 0.0;"&/@First/@$basis,"\n"],
      "@SummationOverGenericFields@"->`cxx`changeGenericExpressions[
         getSummationData@sum,getExpression@sum],
      "@ReturnOutputVars@"->ToString[First/@$basis],
      "@GenericKeys@"->`cxx`genericFieldKey@getGenericFields@sum,
      "@ClassInsertions@"->`cxx`insertFields@genericInsertions,
      "@CombinatoricalFactors@"->`cxx`insertFactors@combinatorialFactors,
      "@ColorFactors@"->`cxx`insertColours@colourFactors,
      "@WilsonBasisLength@"->`cxx`getLength@$basis}];
`cxx`genericSum // secure;

`cxx`initializeExternalIndices[npf:`type`npf] :=
Module[{extIndices = getExternalIndices@npf},
   indices = Array[
      "std::array<int, 1> i" <> ToString@# <>
         " {this->external_indices("<>ToString[#-1]<>")};\n"&,
      Length@extIndices];
   If[Length@extIndices < Length[Flatten@getProcess@npf],
      PrependTo[indices, "std::array<int, 0> i0 {};\n"];];
   StringJoin@indices];
`cxx`initializeExternalIndices // secure;

`cxx`changeGenericExpressions::usage = "
@brief Generates ``C++`` code for output value updating inside generic sum.
@param summation Summation structure of generic index.
@param expr List of expressions to be converted into ``C++`` code.
@returns ``C++`` code for output value initializations inside generic sum.";
`cxx`changeGenericExpressions::errUnimplementedLoops =
"Unsupported loop functions
   `1`
were detected.";
`cxx`changeGenericExpressions[summation:`type`summation, expr:{__}] :=
Module[{
      code = "
      // Shorter aliases for large types
      @fieldAliases@
      // These definitions are repeated multiple times.
      @defineMasses@
      @defineCouplings@
      @defineLoopFunctions@
      // Start of summation over generic fields.
      @BeginSum@

         @setMasses@
         @setCouplings@
         @skipZeroAmplitude@
         @setLoopFunctions@

         @ChangeOutputValues@

      @EndSum@",
      modifiedExpr = expr,
      masses,massDefine,codeMass,massRules,
      couplings,couplingDefine,codeCoupling,couplingRules,
      loopRules,loopArrayDefine,loopArraySet,
      cxxExpr,updatingVars},
   masses = Tally@Cases[modifiedExpr, _SARAH`Mass, Infinity, Heads->True];
   {massDefine, codeMass, massRules} = `cxx`nameMasses@masses;
   modifiedExpr = modifiedExpr /. massRules;

   couplings = Tally@Cases[modifiedExpr,SARAH`Cp[__][___],Infinity,Heads->True];
   {couplingDefine, codeCoupling, couplingRules} = `cxx`nameCouplings@couplings;
   modifiedExpr = modifiedExpr /. couplingRules;

   {loopRules,loopArrayDefine,loopArraySet,modifiedExpr} =
      createLoopFunctions@modifiedExpr;

   cxxExpr = `cxx`applyRules/@modifiedExpr;
   updatingVars = MapThread[#1<>" += "<>#2<>";"&, {First/@$basis, cxxExpr}];

   replaceTokens[code,{
      "@fieldAliases@"->`cxx`setFieldAliases@couplings,
      "@defineMasses@"->massDefine,
      "@defineCouplings@"->couplingDefine,
      "@defineLoopFunctions@"->loopArrayDefine,
      "@BeginSum@"->`cxx`beginSum@summation,
      "@setMasses@"->codeMass,
      "@setCouplings@"->codeCoupling,
      "@skipZeroAmplitude@"->`cxx`skipZeroAmplitude[
         modifiedExpr,loopRules,massRules],
      "@setLoopFunctions@"->loopArraySet,
      "@ChangeOutputValues@"->Utils`StringJoinWithSeparator[updatingVars,"\n"],
      "@EndSum@"->`cxx`endSum@getGenericFields@summation
   }]];
`cxx`changeGenericExpressions // secure;

Module[{func},

func = If[#1 =!= #2, "using " <> #1 <> " = " <> #2 <> ";\n", ""]&;

`cxx`setFieldAliases::usage = "
@brief ``C++`` names for fields with bar and conj are cumbersome. In order to
       improve readaability and simplify checks some aliases are generated.
@param couplings A list of tuples with couplings.
@returns A string with ``C++`` code of alias definitions.";
`cxx`setFieldAliases[couplings:{{SARAH`Cp[__][___], _Integer}..}] :=
Module[{l = Sort@DeleteDuplicates[(Sequence@@Head@First@#&)/@couplings]},
   StringJoin@MapThread[func, {`cxx`fieldAlias/@l, `cxx`fieldName/@l}]];
`cxx`setFieldAliases // secure;];

Module[{c, name, strip},

c[f_] := Switch[Head@f, SARAH`bar|Susyno`LieGroups`conj, "_"<>#, _, #]&;
name[f_] := ToString@Switch[f, _Symbol, f, _, Head@f];
strip[f_] := f /. {SARAH`bar -> Identity, Susyno`LieGroups`conj -> Identity};

`cxx`fieldAlias::usage = "
@brief Generates a short ``C++`` name for a field, whether conjugated or not.
@param f A external or generic field.
@returns A ``C++`` name for a field.";
`cxx`fieldAlias[f:`type`externalField|`type`physicalField] := c[f][name@strip@f];
`cxx`fieldAlias[f:`type`genericField] := c[f][`cxx`fieldName@strip@f];
`cxx`fieldAlias // secure;];

createLoopFunctions[modifiedExpr:{__}] :=
Module[{onePoint,
      onePointTemplate =
         {  LoopTools`A0@@#2 -> "a"<>#1<>"[0]",
            LoopTools`A0i[LoopTools`aa0,Sequence@@#2] -> "a"<>#1<>"[0]"}&,
      twoPoint,
      twoPointTemplate =
         {  LoopTools`B0i[LoopTools`bb0,Sequence@@#2] -> "b"<>#1<>"[0]",
            LoopTools`B0i[LoopTools`bb1,Sequence@@#2] -> "b"<>#1<>"[1]",
            LoopTools`B0i[LoopTools`bb00,Sequence@@#2] -> "b"<>#1<>"[2]"}&,
      threePoint,
      threePointTemplate =
         {  LoopTools`C0i[LoopTools`cc0,Sequence@@#2] -> "c"<>#1<>"[0]",
            LoopTools`C0i[LoopTools`cc1,Sequence@@#2] -> "c"<>#1<>"[1]",
            LoopTools`C0i[LoopTools`cc2,Sequence@@#2] -> "c"<>#1<>"[2]",
            LoopTools`C0i[LoopTools`cc00,Sequence@@#2] -> "c"<>#1<>"[3]",
            LoopTools`C0i[LoopTools`cc11,Sequence@@#2] -> "c"<>#1<>"[4]",
            LoopTools`C0i[LoopTools`cc12,Sequence@@#2] -> "c"<>#1<>"[5]",
            LoopTools`C0i[LoopTools`cc22,Sequence@@#2] -> "c"<>#1<>"[6]"}&,
      fourPoint,
      fourPointTemplate =
         {  LoopTools`D0i[LoopTools`dd0,Sequence@@#2] -> "d"<>#1<>"[0]",
            LoopTools`D0i[LoopTools`dd1,Sequence@@#2] -> "d"<>#1<>"[1]",
            LoopTools`D0i[LoopTools`dd2,Sequence@@#2] -> "d"<>#1<>"[2]",
            LoopTools`D0i[LoopTools`dd3,Sequence@@#2] -> "d"<>#1<>"[3]",
            LoopTools`D0i[LoopTools`dd00,Sequence@@#2] -> "d"<>#1<>"[4]",
            LoopTools`D0i[LoopTools`dd11,Sequence@@#2] -> "d"<>#1<>"[5]",
            LoopTools`D0i[LoopTools`dd12,Sequence@@#2] -> "d"<>#1<>"[6]",
            LoopTools`D0i[LoopTools`dd13,Sequence@@#2] -> "d"<>#1<>"[7]",
            LoopTools`D0i[LoopTools`dd22,Sequence@@#2] -> "d"<>#1<>"[8]",
            LoopTools`D0i[LoopTools`dd23,Sequence@@#2] -> "d"<>#1<>"[9]",
            LoopTools`D0i[LoopTools`dd33,Sequence@@#2] -> "d"<>#1<>"[10]"}&,
      append,
      loopRules = {},
      loopArrayDefine = {},
      loopArraySet = {}},
   append[loopFunctions_List,function_,functionName_String,arrayName_String] :=
   If[loopFunctions=!={},
      AppendTo[loopArrayDefine,Array[
         "looplibrary::"<>functionName<>"coeff_t "<>arrayName<>ToString@#<>"{}"&,
         Length@loopFunctions]];
      AppendTo[loopArraySet,Array[
         Parameters`ExpressionToString[
            StringJoin["Loop_library::get().",functionName][
               arrayName<>ToString@#,
               Sequence@@loopFunctions[[#,1]],
               "Sqr(context.scale())"]]<>"; // "<>
            ToString@loopFunctions[[#,2]]<>" copies."&,
         Length@loopFunctions]];
      AppendTo[loopRules,
         Join@@function@@@Array[{ToString@#,loopFunctions[[#,1]]}&,
         Length@loopFunctions]];];
   onePoint = Tally@Join[
      Cases[modifiedExpr,LoopTools`A0i[_,args:__]:>{args},Infinity],
      Cases[modifiedExpr,LoopTools`A0[args:__]:>{args},Infinity]];
   twoPoint = Tally@Join[
      Cases[modifiedExpr,LoopTools`B0i[_,args:__]:>{args},Infinity],
      Cases[modifiedExpr,(LoopTools`B0|LoopTools`B0)[args:__]:>{args},
         Infinity]];
   threePoint = Tally@Join[
      Cases[modifiedExpr,LoopTools`C0i[_,args:__]:>{args},Infinity],
      Cases[modifiedExpr,(LoopTools`C0)[args:__]:>{args},Infinity]];
   fourPoint = Tally@Join[
      Cases[modifiedExpr,LoopTools`D0i[_,args:__]:>{args},Infinity],
      Cases[modifiedExpr,(LoopTools`D0)[args:__]:>{args},Infinity]];
   append[onePoint,onePointTemplate,"A","a"];
   append[twoPoint,twoPointTemplate,"B","b"];
   append[threePoint,threePointTemplate,"C","c"];
   append[fourPoint,fourPointTemplate,"D","d"];
   {  Flatten@loopRules,
      Utils`StringJoinWithSeparator[Join@@loopArrayDefine,";\n"]<>";\n",
      Utils`StringJoinWithReplacement[Join@@loopArraySet,"\n","\""->""],
      modifiedExpr/.Flatten@loopRules}];
createLoopFunctions // secure;

`cxx`skipZeroAmplitude::usage = "
@brief If some combination of couplings in the amplitude is zero, then the full
       amplitude is zero as well, so that we can skip it.
@note How this is implemented? Any amplitude has the following form: several
      couplings times some masses times loop integral. We can get all different
      combinations of this coupling coefficients and if all of them are zero,
      then amplitude is zero as well.";
`cxx`skipZeroAmplitude[modifiedExpr:{__},loopRules:{Rule[_,_]..},
   massRules:{Rule[_,_]..}] :=
Module[{numbersToOne = {_Integer->1,_Rational->1,_Complex->1,Pi->1},
      massesToOne = Rule[#,1] & /@ massRules[[All,2]],
      loopsToOne = Rule[#,1] & /@ loopRules[[All,2]],
      result, func = "z[" <> # <> "]"&},
   result = ExpandAll[modifiedExpr] /.numbersToOne /.Plus->List/.
      massesToOne/.loopsToOne;
   result = DeleteDuplicates[Flatten@DeleteCases[result,1]];
   If[ 2 === LeafCount@result,
      result = func@@result,
      result = Plus@@(result/.HoldPattern[Times[x__]]:>Times@@(func@#&/@{x}))];
   result = "if( "<>
      StringReplace[Parameters`ExpressionToString@result,"\""->""]<>
      " == 0 ) continue;";
   StringReplace[result,
      RegularExpression["g(\\d+)"]:> ToString[ToExpression@"$1"-1]]];
`cxx`skipZeroAmplitude // secure;

`cxx`getVariableName[SARAH`Mass[obj:`type`genericField]] :=
Switch[getName@obj,
   GenericS, "mS",
   GenericF, "mF",
   GenericV, "mV",
   GenericU, "mU"]<>ToString@getIndex@obj;
`cxx`getVariableName[SARAH`Mass[obj:`type`physicalField]] :=
   "m"<>ToString@getName@obj<>`cxx`getIndex@obj;
`cxx`getVariableName // secure;

Module[{
      info = {`cxx`getVariableName@#1, `cxx`applyRules@#1, #1, #2}&@@#&,
      d = "double " <> Utils`StringJoinWithSeparator[#, ", "] <> ";"&,
      i = #1 <> " = " <> #2 <> "; // " <> ToString@#4 <>" copies.\n"&@@#&,
      r = Rule@@@#[[All, {3, 1}]]&},

`cxx`nameMasses::usage = "
@brief Generates names for masses to be used inside generic sums and then
       creates:

       1. a ``C++`` code for definition and initialisation for masses,
       2. a ``Mathematica`` to ``C++`` rules for generated names of masses.
@param masses A list of tallies with Mathematica expressions for mass and the
       number of repetition of it.
@returns A list of:

         1. a ``C++`` string with definitions,
         2. a ``C++`` string with initialisations,
         3. a Mathematica list of rules for mass convertion
            to ``C++`` code.";
`cxx`nameMasses[masses:{{_, _Integer}..}] :=
   {d[First/@#], StringJoin[i/@#], r@#} &@ Table[info@m, {m, Sort@masses}];
`cxx`nameMasses // secure;

`cxx`nameCouplings::usage = "
@brief Generates names for couplings to be used inside generic sums and then
       creates:

       1. ``C++`` code for definition and initialisation for couplings,
       2. ``Mathematica`` to ``C++`` rules for generated names of couplings.
@param masses A list of tallies with Mathematica expressions for coupling
       and the number of repetition of it.
@returns A list of:

         1. a ``C++`` string with definitions,
         2. a ``C++`` string with initialisations,
         3. a ``Mathematica`` list of rules for coupling convertion
            to ``C++`` code.
@note All couplings have to be multiplied by ``I``, as it is done in these
      rule replacements.";
`cxx`nameCouplings[couplings:{{_,_Integer}..}] :=
Module[{
      sort = Sort@couplings, info, isZero,
      d = "std::complex<double> " <> Utils`StringJoinWithSeparator[#, ", "] <>
         ";"&,
      timesI = Rule[#1, I*#2]&@@#&,
      setZero},
   isZero = "std::array<int, "<> ToString@Length@sort <> "> z{};";
   setZero = "z[" <> ToString[#-1] <> "] = (std::abs(g" <> ToString@# <>
      ") < std::numeric_limits<double>::epsilon()) ? 0: 1;\n"&;
   info = {"g"<>ToString@#, `cxx`applyRules@sort[[#,1]], sort[[#,1]],
      sort[[#,2]]}&;
   {  d[First/@#]<>"\n"<>isZero,
      StringJoin[i/@#]<>"\n"<>StringJoin[setZero/@Range@Length@sort],
      timesI/@r@#} &@ Array[info, Length@sort]];
`cxx`nameCouplings // secure;];

`cxx`shortNames::usage = "
@brief Generates ``C++`` code for type abbreviations stored in
       ``GenericFieldMap`` (Associative Sequence) at ``Key`` positions.
@param genFields List of generic fields.
@returns String ``C++`` code for type abbreviations stored in GenericFieldMap
         (Associative Sequence) at Key positions.";
`cxx`shortNames[genFields:{`type`genericField..}] :=
   Utils`StringJoinWithSeparator[Apply[
      "using "<>#1<>" = typename at<GenericFieldMap,"<>ToString@#2<>">::type;"&,
      {`cxx`fieldName@#,`cxx`genericFieldKey@#}&/@genFields,
      {1}],"\n"];
`cxx`shortNames // secure;

`cxx`beginSum::usage = "
@brief Generates ``C++`` code for sum beginning used inside GenericSum.
@param summation List of generic index restriction rules pares, which,
       if are true should lead to a skip of summation.
@returns String ``C++`` code for sum beginning used inside generic sums.";
`cxx`beginSum[summation:`type`summation]:=
Module[{beginsOfFor},
   beginsOfFor = "for( const auto &"<>`cxx`getIndex[#[[1]]]<>" : "<>
      "index_range<"<> `cxx`fieldName[#[[1]]]<>">() ) {\n"<>
      "at_key<"<>`cxx`genericFieldKey@#[[1]]<>">( index_map ) = "<>
      `cxx`getIndex[#[[1]]]<>";"<>parseRestrictionRule[#] &/@summation;
   Utils`StringJoinWithSeparator[beginsOfFor,"\n"]];
`cxx`beginSum // secure;

parseRestrictionRule[{genericField:`type`genericField,rule_}] :=
Module[{f1,f2,getIndexOfExternalField,OrTwoDifferent},
   getIndexOfExternalField[_[_[{ind_}]]] := `cxx`applyRules@ind;
   getIndexOfExternalField[_[{ind_}]] := `cxx`applyRules@ind;
   getIndexOfExternalField[_] := "i0";
   OrTwoDifferent[] :=
   Module[{type1 = `cxx`fieldName@First@rule,
         type2 = `cxx`fieldName@Last@rule,
         ind = getIndexOfExternalField@First@rule,
         typeGen = `cxx`fieldName@genericField,
         indGen = `cxx`getIndex@genericField},
      "\nif( (boost::core::is_same<"<>typeGen<>","<>type1<>
         ">::value || boost::core::is_same<"<>typeGen<>","<>type2<>
         ">::value) && "<>indGen<>" == "<>ind<>" ) continue;"];
   Switch[rule,
      Or[f1_,f2_],
         OrTwoDifferent[],
      False,
         "",
      _,
         "@todo This rule is not implemented yet!";Quit[1]]];
parseRestrictionRule // secure;

`cxx`endSum::usage = "
@brief Generates ``C++`` code for end of sum over generic fields inside
       GenericSum.
@param genFields List of generic fields.
@returns String ``C++`` code for end of sum over generic fields inside
         GenericSum.";
`cxx`endSum[genFields:{`type`genericField..}] :=
   StringJoin[
      Array["}"&,Length@genFields],
      " // End of summation over generic fields"];
`cxx`endSum // secure;

`cxx`calculateFunction::usage = "
@brief Generates ``C++`` code for functions which return result of generic sum
       calculation.
@param genSumNames list of strings with names of generic sums.
@returns Generates ``C++`` code for functions which return result of
         generic sum calculation.";
`cxx`calculateFunction[genSumNames:{__String}] :=
Module[{
      varName = "genericsum" (* Feel free to change me to another ``C++`` name *),
      varNames,initVars,sumOfSums},
   varNames = Array[varName<>ToString@#&,Length@genSumNames];
   initVars = Utils`StringJoinWithSeparator[
      MapThread["const auto "<>#1<>" = "<>#2<>"();"&,{varNames,genSumNames}],
      "\n"];
   sumOfSums = Utils`StringJoinWithSeparator[#<>"[i]"&/@varNames,"+"];
   replaceTokens["
      std::array<std::complex<double>,@BasisLength@> calculate( void ) {
         std::array<std::complex<double>,@BasisLength@> genericSummation;
         constexpr int coeffsLength = genericSummation.size();
         @InitializeVariablesWhichStoreGenericSumsOutput@

         for ( std::size_t i=0; i<coeffsLength; i++ ) {
            genericSummation[i] += @SumOfVariables@;
         }
         return genericSummation;
      } // End of calculate()",
      {  "@BasisLength@"->`cxx`getLength@$basis,
         "@InitializeVariablesWhichStoreGenericSumsOutput@"->initVars,
         "@SumOfVariables@"->sumOfSums}]];
`cxx`calculateFunction // secure;

`cxx`insertFields::usage = "
@brief Generates ``C++`` code for class insertions inside GenericSum.
@param genInsertions list of list with SARAH particle names.
@returns String ``C++`` code for class insertions inside GenericSum.";
`cxx`insertFields[genInsertions:`type`classFields] :=
   Utils`StringJoinWithSeparator["boost::mpl::vector<"<>
      Utils`StringJoinWithSeparator[`cxx`fieldName@#&/@#,", "]<>
      ">"&/@genInsertions,",\n"];
`cxx`insertFields // secure;

`cxx`insertFactors::usage = "
@brief Generates ``C++`` code for combinatorical factor insertions inside GenericSum.
@param combinatorialFactors List of integers.
@returns String ``C++`` code for combinatorical factor insertions inside GenericSum.";
`cxx`insertFactors[combinatorialFactors:`type`classCombinatoricalFactors] :=
   Utils`StringJoinWithSeparator["boost::mpl::int_<"<>ToString@#<>
      ">"&/@combinatorialFactors,",\n"];
`cxx`insertFactors // secure;

`cxx`insertColours::usage = "
@brief Generates ``C++`` code for colour factor insertions inside GenericSum.
@param colourFactors list of numbers.
@returns String ``C++`` code for colour factor insertions inside GenericSum.";
`cxx`insertColours[colourFactors:{__?NumberQ}] :=
Module[{
      ReRatioColourFactors = {Numerator@#,Denominator@#} &/@ Re@colourFactors,
      ImRatioColourFactors = {Numerator@#,Denominator@#} &/@ Im@colourFactors},
   Utils`StringJoinWithSeparator[
      StringReplace[
         MapThread[
            "detail::complex_helper<"<>
            "detail::ratio_helper<"<>ToString@#1<>">,"<>
            "detail::ratio_helper<"<>ToString@#2 <> ">>"&,
            {ReRatioColourFactors, ImRatioColourFactors}],
         {"{" -> "", "}" -> ""}],
   ",\n"]];
`cxx`insertColours // secure;

End[];
EndPackage[];
$ContextPath = DeleteCases[$ContextPath, "NPointFunctions`"];
