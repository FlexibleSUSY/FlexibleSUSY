(* :Copyright:

   ====================================================================
   This file is part of FlexibleSUSY.

   FlexibleSUSY is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published
   by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   FlexibleSUSY is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with FlexibleSUSY.  If not, see
   <http://www.gnu.org/licenses/>.
   ====================================================================

*)

(*@assumptions: 
1) there are no quartic gluon vertices inside diagrams => one can calculate
colour factor for diagram separately from Lorentz factor
2) 4-point vertices are not supported *)
BeginPackage["NPointFunctions`",
   {
      "FlexibleSUSY`",
      "SARAH`",
      "CXXDiagrams`", (* RemoveLorentzConjugation, *)
      "Vertices`", (* StripFieldIndices *)
      "Parameters`", (* ExpressionToString *)
      "Utils`" (* AssertOrQuit, AssertWithMessage, EvaluateOrQuit *)
   }
];

LoopLevel::usage=
"Option for NPointFunctions`NPointFunction[].
Encodes the loop level at which to calculate amplitudes.

def. 1 | 0";
Regularize::usage=
"Option for NPointFunctions`NPointFunction[].
Encodes the regularization scheme to be used.

DimensionalReduction | DimensionalRegularization";
UseCache::usage=
"Option for NPointFunctions`NPointFunction[].
Cache and reuse the expressions generated by FeynArts/FormCalc.
@note @todo there is no difference between different ExcludeProcesses and
OnShellFlag values

def. True | False";
ZeroExternalMomenta::usage=
"Option for NPointFunctions`NPointFunction[].
Encodes whether to set the external momenta to zero or leave them undetermined.

def. True | False | ExceptPaVe";
ExceptPave::usage=
"Possible value for ZeroExternalMomenta.";
OnShellFlag::usage=
"Option for NPointFunctions`NPointFunction[].
Use on-shell external fields or not.

def. True | False";

ExcludeProcesses::usage=
"Option for NPointFunctions`NPointFunction[].
Exclude specific processes in FeynArts. \"Or\" logic is applied.

def. {} | Any sublist of {ExceptIrreducible,ExceptBoxes,ExceptTriangles}";
ExceptIrreducible::usage=
"Possible value for ExcludeProcesses.
Exclude irreducible topologies.";
ExceptBoxes::usage=
"Possible value for ExcludeProcesses. 
Exclude all topologies except box diagrams.";
ExceptTriangles::usage=
"Possible value for ExcludeProcesses. 
Exclude all topologies except triangle ones.";

ExceptFourFermionScalarPenguins::usage=
"Possible value for ExcludeProcesses.
Exclude all processes except 4-fermion penguins with scalar propagating from
one fermionic chain to another one.
Keep
1) triangle-like topologies;
2) \"self-energy\" diagrams on external fermionic lines
amplitudes.";
ExceptFourFermionMassiveVectorPenguins::usage=
"Possible value for ExcludeProcesses.
Exclude all processes except 4-fermion penguins with massive vector propagating 
from one fermionic chain to another one.
Keep
1) triangle-like topologies;
2) \"self-energy\" diagrams on external fermionic lines
amplitudes.";

DimensionalReduction::usage=
"Possible value for the Regularize option

(Technically, a wrapper for FlexibleSUSY`.`DRbar)";
DimensionalRegularization::usage=
"Possible value for the Regularize option

(Technically, a wrapper for FlexibleSUSY`.`MSbar)";

GenericS::usage=
"A symbol that acts as a placeholder for any scalar field.";
GenericF::usage=
"A symbol that acts as a placeholder for any fermion field.";
GenericV::usage=
"A symbol that acts as a placeholder for any vector field.";
GenericU::usage=
"A symbol that acts as a placeholder for any ghost field.";

GenericSum::usage=
"Represent a sum over a set of generic fields.";
GenericIndex::usage=
"Represent an index of a generic field.";
LorentzIndex::usage=
"Represent a Lorentz index of a generic field.";

LoopFunctions::usage=
"Option for NPointFunctions`CreateCXXHeaders[] and 
NPointFunctions`CreateCXXFunctions[]
Controls whether to use FlexibleSUSY or LoopTools for loop functions.

def. \"LoopTools\" | \"FlexibleSUSY\"";
UseWilsonCoeffs::usage=
"Option for NPointFunctions`CreateCXXHeaders[].
Controls whether to use Wilson module or not

def. False | True";

WilsonBasis::usage=
"Option for NPointFunctions`CreateCXXFunctions[].
Specify {<string name> -> <basis expression>..} pairs for matching.

def. {}";

(*functions*)
{NPointFunction,VerticesForNPointFunction,CreateCXXHeaders,CreateCXXFunctions,
CreateCXXFToFConversionInNucleus};

SetAttributes[
   {
   LoopLevel,Regularize,UseCache,ZeroExternalMomenta,OnShellFlag,
   ExcludeProcesses,
   DimensionalReduction,DimensionalRegularization,
   ExceptIrreducible,ExceptBoxes,ExceptTriangles,
   GenericS,GenericF,GenericV,GenericU,GenericT,                                (* @unote also exist in internal.m*)
   GenericSum,GenericIndex,LorentzIndex,                                        (* @unote also exist in internal.m*)
   LoopFunctions,UseWilsonCoeffs,WilsonBasis
   }, 
   {Protected, Locked}];

NPointFunctions`internal`contextPath = $ContextPath;
$ContextPath = {"NPointFunctions`","System`"};
Begin["`internal`"];
(* ============================== Type definitions ========================== *)
`type`genericField =
   (GenericS | GenericF | GenericV | GenericU)[GenericIndex[_Integer]] |
   SARAH`bar[(GenericF | GenericU)[GenericIndex[_Integer]]] |
   Susyno`LieGroups`conj[(GenericS | GenericV)[GenericIndex[_Integer]]];
`type`process = {{__},{__}};
`type`subexpressions = {Rule[_Symbol,_]...};
`type`summation = {{`type`genericField,_}..};
`type`genericSum = GenericSum[_,`type`summation] | GenericSum[{__},`type`summation]; (* @todo Remove the second one *)
`type`classFields = {{__}..};
`type`classCombinatoricalFactors = {__Integer};
`type`classColorFactors = {__};
`type`npf =
   {
   `type`process,
   {
      {
         {`type`genericSum..},
         {`type`classFields..},
         {`type`classCombinatoricalFactors..},
         {`type`classColorFactors..}
      },
      `type`subexpressions
   }
};

`type`cxxToken = _String?(StringMatchQ[#,RegularExpression@"@[^@\n]+@"]&);
`type`cxxReplacementRules = {Rule[`type`cxxToken,_String]..};

cxx ~ SetAttributes ~ {Locked,Protected};
output ~ SetAttributes ~ {Locked,Protected};

makeDefaultDefinitions[sym_Symbol] :=
Module[{usageString,info,parsedInfo,infoString,toString=StringJoin@@Riffle[ToString/@{##},", "]&},
   (* Clean existing definitions if they exist for required pattern. *)
   Off[Unset::norep];
   sym[args___] =.;
   On[Unset::norep];
   (* Maybe some useful definitions already exist*)
   If[MatchQ[sym::usage,_String],usageString="Usage:\n"<>sym::usage<>"\n\n",usageString=""];
   info = MakeBoxes@Definition@sym;
   If[MatchQ[info,InterpretationBox["Null",__]],(* True - No, there is no definitions. *)
      infoString="",
      parsedInfo = Flatten@# &/@ (Cases[info[[1,1]],GridBox[{x:{_}..},__]:>Cases[{x},{_RowBox},1],2]~Flatten~2 //. {RowBox[x_]:>x,StyleBox[x_,_]:>x});
      parsedInfo = MapThread[parsedInfo[[##]]&,{Range@Length@#,First/@#}] &@ (Range@(First@#-1) &@ Position[#,"="|":="|"^="|"^:="] &/@ parsedInfo);
      parsedInfo = DeleteCases[DeleteDuplicates@parsedInfo,{"Options",__}|{"Attributes",__}];
      parsedInfo = Array[Join[{ToString@#,") "},parsedInfo[[#]]]&,Length@parsedInfo];
      infoString = StringJoin@Riffle[StringJoin @@ # & /@ parsedInfo, "\n"];
      infoString = "The behavior for case"<>If[Length@parsedInfo===1,"\n","s\n"]<>infoString<>"\nis defined only.\n\n";
   ];
   sym::errUnknownInput = "`1``2`Call\n`3`[`4`"<>StringReplace[ToString@sym,"`"->"`.`"]<>"[`5`]`6`]\nis not supported.";
   (* Define new pattern. *)
   sym /: name_[args1___,sym[args2___],args3___] := Utils`AssertOrQuit[
      False,
      sym::errUnknownInput,
      usageString,
      infoString,
      ToString@name,
      If[#==="","",#<>","]&@toString@args1,
      toString@args2,
      If[#==="","",","<>#]&@toString@args3];
];
makeDefaultDefinitions // Utils`MakeUnknownInputDefinition;
makeDefaultDefinitions ~ SetAttributes ~ {Locked,Protected,ReadProtected};

getDirectory::errNotAString =
"getDirectory[`1`] doesn't have a String type.";
getDirectory /: Dot[output,getDirectory[]] :=
If[MatchQ[#,_String],#,Utils`AssertOrQuit[False,getDirectory::errNotAString,""]]&@
FileNameJoin@{SARAH`$sarahCurrentOutputMainDir,ToString@FlexibleSUSY`FSEigenstates};
getDirectory /: Dot[output,getDirectory@"Meta"] :=
If[MatchQ[#,_String],#,Utils`AssertOrQuit[False,getDirectory::errNotAString,"Meta"]]&@
FlexibleSUSY`$flexiblesusyMetaDir;
getDirectory /: Dot[output,getDirectory@"FormCalc"] :=
If[MatchQ[#,_String],#,Utils`AssertOrQuit[False,getDirectory::errNotAString,"FormCalc"]]&@
FileNameJoin@{output.getDirectory[],"FormCalc"};
getDirectory /: Dot[output,getDirectory@"FeynArts"] :=
If[MatchQ[#,_String],#,Utils`AssertOrQuit[False,getDirectory::errNotAString,"FeynArts"]]&@
FileNameJoin@{output.getDirectory[],"FeynArts"};
getDirectory /: Dot[output,getDirectory@"NPointFunctions"] :=
If[MatchQ[#,_String],#,Utils`AssertOrQuit[False,getDirectory::errNotAString,"NPointFunctions"]]&@
FileNameJoin@{output.getDirectory[],"NPointFunctions"};
getDirectory /: Dot[output,getDirectory@"FeynArts_model"] :=
If[MatchQ[#,_String],#,Utils`AssertOrQuit[False,getDirectory::errNotAString,"FeynArts_model"]]&@
FileNameJoin@{output.getDirectory@"FeynArts", SARAH`ModelName<>ToString@FlexibleSUSY`FSEigenstates};
getDirectory // makeDefaultDefinitions;
getDirectory ~ SetAttributes ~ {Locked,Protected,ReadProtected};

getFileName /: Dot[output,getFileName@"Particles"] :=
FileNameJoin@{output.getDirectory@"FeynArts", "ParticleNamesFeynArts.dat"};
getFileName /: Dot[output,getFileName@"Namespaces"] :=
FileNameJoin@{output.getDirectory@"FeynArts", "ParticleNamespaces.m"};
getFileName /: Dot[output,getFileName@"Substitutions"] :=
FileNameJoin@{output.getDirectory@"FeynArts", StringJoin["Substitutions-",SARAH`ModelName,ToString@FlexibleSUSY`FSEigenstates,".m"]};
getFileName // makeDefaultDefinitions;
getFileName ~ SetAttributes ~ {Locked,Protected,ReadProtected};

getIndent /: Dot[obj:_String,getIndent[]] := First@StringCases[obj,StartOfString~~"\n"...~~indent:" "...:>indent];
getIndent /: Dot[obj:{__String},getIndent[]] := First/@StringCases[obj,StartOfString~~"\n"...~~indent:" "...:>indent];
getIndent // makeDefaultDefinitions;
getIndent ~ SetAttributes ~ {Locked,Protected,ReadProtected};

getConjugated /: Dot[obj:`type`genericField,getConjugated[]] :=
Switch[Head@obj,
   SARAH`bar | Susyno`LieGroups`conj, obj[[1]],
   GenericS | GenericV, Susyno`LieGroups`conj@obj,
   GenericF | GenericU, SARAH`bar@obj
];
getConjugated // makeDefaultDefinitions;
getConjugated ~ SetAttributes ~ {Locked,Protected,ReadProtected};

removeIndent /: Dot[obj:_String,removeIndent[]] := StringReplace[obj,StartOfLine~~obj.getIndent[]->""];
removeIndent // makeDefaultDefinitions;
removeIndent ~ SetAttributes ~ {Locked,Protected,ReadProtected};

replaceTokens /: Dot[code:_String,replaceTokens[rules:`type`cxxReplacementRules]] :=
StringJoin[
   StringReplace[#,"\n"->StringJoin["\n",#.getIndent[]]] &/@ StringReplace[StringSplit[code.removeIndent[],"\n"],rules]~Riffle~"\n"];
replaceTokens // makeDefaultDefinitions;
replaceTokens ~ SetAttributes ~ {Locked,Protected,ReadProtected};

getProcess /: Dot[obj:`type`npf,getProcess[]] := obj[[1]];
getProcess // makeDefaultDefinitions;
getProcess ~ SetAttributes ~ {Locked,Protected,ReadProtected};

getExternalMomenta /: Dot[obj:`type`npf,getExternalMomenta[]] :=
DeleteDuplicates@Cases[{obj.getGenericSums[],obj.getSubexpressions[]},HoldPattern@SARAH`Mom[_Integer,___],Infinity];
getExternalMomenta // makeDefaultDefinitions;
getExternalMomenta ~ SetAttributes ~ {Locked,Protected,ReadProtected};

getExternalIndices /: Dot[obj:`type`npf,getExternalIndices[]] :=
DeleteDuplicates@Flatten@Level[obj.getProcess[],{4,5}];
getExternalIndices // makeDefaultDefinitions;
getExternalIndices ~ SetAttributes ~ {Locked,Protected,ReadProtected};

getGenericSums /: Dot[obj:`type`npf,getGenericSums[]] := obj[[2,1,1]];
getGenericSums // makeDefaultDefinitions;
getGenericSums ~ SetAttributes ~ {Locked,Protected,ReadProtected};

getClassFields /: Dot[obj:`type`npf,getClassFields[]] := obj[[2,1,2]];
getClassFields // makeDefaultDefinitions;
getClassFields ~ SetAttributes ~ {Locked,Protected,ReadProtected};

getClassCombinatoricalFactors /: Dot[obj:`type`npf,getClassCombinatoricalFactors[]] := obj[[2,1,3]];
getClassCombinatoricalFactors // makeDefaultDefinitions;
getClassCombinatoricalFactors ~ SetAttributes ~ {Locked,Protected,ReadProtected};

getClassColorFactors /: Dot[obj:`type`npf,getClassColorFactors[]] := obj[[2,1,4]];
getClassColorFactors // makeDefaultDefinitions;
getClassColorFactors ~ SetAttributes ~ {Locked,Protected,ReadProtected};

getSubexpressions /: Dot[obj:`type`npf,getSubexpressions[]] := obj[[2,2]];
getSubexpressions // makeDefaultDefinitions;
getSubexpressions ~ SetAttributes ~ {Locked,Protected,ReadProtected};

getName /: Dot[obj:`type`subexpressions,getName[]] := First/@obj;
getName /: Dot[obj:`type`cxxReplacementRules,getName[]] := First/@obj;
getName /: Dot[obj:`type`genericField,getName[cxx]] :=
Switch[Head@obj,
   SARAH`bar,"typename bar<"<>ToString[obj[[1,0]]]<>ToString[obj[[1,1,1]]]<>">::type",
   Susyno`LieGroups`conj,"typename conj<"<>ToString[obj[[1,0]]]<>ToString[obj[[1,1,1]]]<>">::type",
   _,ToString[obj[[0]]]<>ToString[obj[[1,1]]]
];
getName // makeDefaultDefinitions;
getName ~ SetAttributes ~ {Locked,Protected,ReadProtected};

getIndex /: Dot[obj:`type`genericField,getIndex[cxx] ] :=
"indices"<>StringTake[SymbolName[obj[[0]]],-1]<>ToString[obj[[1,1]]] &@ CXXDiagrams`RemoveLorentzConjugation[obj];
getIndex // makeDefaultDefinitions;
getIndex ~ SetAttributes ~ {Locked,Protected,ReadProtected};

getGenericFields /: Dot[obj:`type`genericSum,getGenericFields[]] := First/@Last[obj];
getGenericFields /: Dot[obj:`type`summation,getGenericFields[]] := First/@obj;
getGenericFields /: Dot[objs:{`type`genericSum..},getGenericFields[]] := (First/@Last@#)&/@objs;
getGenericFields // makeDefaultDefinitions;
getGenericFields ~ SetAttributes ~ {Locked,Protected,ReadProtected};

getExpression /: Dot[obj:`type`genericSum,getExpression[]] := First@obj;
getExpression // makeDefaultDefinitions;
getExpression ~ SetAttributes ~ {Locked,Protected,ReadProtected};

getSummationData /: Dot[obj:`type`genericSum,getSummationData[]] := Last@obj;
getSummationData // makeDefaultDefinitions;
getSummationData ~ SetAttributes ~ {Locked,Protected,ReadProtected};

getClassFieldRules /: Dot[obj:`type`npf,getClassFieldRules[]] :=
MapThread[Function[fields,MapThread[Rule,{#1,fields}]]/@#2&,{obj.getGenericSums[].getGenericFields[],obj.getClassFields[]}];
getClassFieldRules // makeDefaultDefinitions;
getClassFieldRules ~ SetAttributes ~ {Locked,Protected,ReadProtected};

setSubexpressions /: Dot[obj:`type`npf,setSubexpressions[newsubs:`type`subexpressions]] := ReplacePart[obj,{2,2}->newsubs];
setSubexpressions // makeDefaultDefinitions;
setSubexpressions ~ SetAttributes ~ {Locked,Protected,ReadProtected};

applySubexpressions /: Dot[obj:`type`npf,applySubexpressions[]] :=
ReplacePart[obj,{2,1,1}->ReplaceRepeated[obj.getGenericSums[],obj.getSubexpressions[]]].setSubexpressions[{}];
applySubexpressions // makeDefaultDefinitions;
applySubexpressions ~ SetAttributes ~ {Locked,Protected,ReadProtected};

CreateCXXFToFConversionInNucleus::usage=
"@todo";
CreateCXXFToFConversionInNucleus::errFermion=
"Input should be
<fermion> -> <fermion> or { { <fermion> -> <fermion> }.. }
and not
`1`";
CreateCXXFToFConversionInNucleus[{{}}] := {{},"",""};
CreateCXXFToFConversionInNucleus[arg:{{_->_}..}] :=
Module[
   {
      data = CreateCXXFToFConversionInNucleus@@#&/@arg,
      vertices,header,code
   },
   vertices = DeleteDuplicates[Join@@(data[[All,1]])];
   header = data[[1,2]];
   code = StringRiffle[data[[All,3]],"\n\n"];
   {vertices,header,code}
];
CreateCXXFToFConversionInNucleus[inF_->outF_] :=
Module[
   {
      nameForUpQuarkClass = "zpinguins_u"<>ToString@inF<>ToString@outF<>"_1loop",
      nameForUpDownClass  = "zpinguins_d"<>ToString@inF<>ToString@outF<>"_1loop",
      paveLibrary = "LoopTools" ,
      header,
      uQ=SARAH`UpQuark,uNPF,
      dQ=SARAH`DownQuark, dNPF,
      dimension6Template,dimension7Template,
      ch=FormCalc`DiracChain,
      l=FormCalc`Lor,
      mom = SARAH`Mom,
      mass = SARAH`Mass,
      sp,
      codeU,codeD,
      dressedFermions,assumptionReplacements
   },
   header=CreateCXXHeaders[LoopFunctions->paveLibrary,UseWilsonCoeffs->True];
   sp[particle_,num_] := FormCalc`Spinor[#,mom@num,mass@#] &@ particle@{Symbol["SARAH`gt"<>ToString@num]};

   Print["Analytical calculation for ",inF,"->",outF," started ..."];
   uNPF = NPointFunction[{inF,uQ},{outF,uQ},
      OnShellFlag -> True,
      UseCache -> False,
      ZeroExternalMomenta -> False,
      ExcludeProcesses -> ExceptFourFermionMassiveVectorPenguins];
   dNPF = NPointFunction[{inF,dQ},{outF,dQ},
      OnShellFlag -> True,
      UseCache -> False,
      ZeroExternalMomenta -> False,
      ExcludeProcesses -> ExceptFourFermionMassiveVectorPenguins];
   (* ASSUMPTION: high virtuality of massive particle in t-channel for penguins q^2=0. *)
   dressedFermions = {uNPF[[1,1,1]],dNPF[[1,2,1]]};
   assumptionReplacements =
     {
        SARAH`sum[i_,1,4,SARAH`g[i_,i_]*mom[First@dressedFermions,i_]*mom[Last@dressedFermions,i_]]:>
        (mass[ First@dressedFermions ]^2+mass[ Last@dressedFermions ]^2) / 2
     };
   {uNPF,dNPF} = {uNPF,dNPF} /. assumptionReplacements;
   
   Print["Analytical calculation for ",inF,"->",outF," done."];

   dimension6Template[i_,o_,q_] :=
      {
         (*@note 6 means PR, 7 means PL.*)
         ("S_LL_via_"<>ToString@q) -> ch[o~sp~3,7,i~sp~1] ch[q~sp~4,7,q~sp~2],
         ("S_LR_via_"<>ToString@q) -> ch[o~sp~3,7,i~sp~1] ch[q~sp~4,6,q~sp~2],
         ("S_RL_via_"<>ToString@q) -> ch[o~sp~3,6,i~sp~1] ch[q~sp~4,7,q~sp~2],
         ("S_RR_via_"<>ToString@q) -> ch[o~sp~3,6,i~sp~1] ch[q~sp~4,6,q~sp~2],
         (*@note Q: why names of coeffients are not correct? A: they are 
          *correct, one just need to commute projectors with Dirac matrices, 
          *what changes 6 to 7 or 7 to 6.*)
         ("V_LL_via_"<>ToString@q) -> ch[o~sp~3,6,l@1,i~sp~1] ch[q~sp~4,6,l@1,q~sp~2],
         ("V_LR_via_"<>ToString@q) -> ch[o~sp~3,6,l@1,i~sp~1] ch[q~sp~4,7,l@1,q~sp~2],
         ("V_RL_via_"<>ToString@q) -> ch[o~sp~3,7,l@1,i~sp~1] ch[q~sp~4,6,l@1,q~sp~2],
         ("V_RR_via_"<>ToString@q) -> ch[o~sp~3,7,l@1,i~sp~1] ch[q~sp~4,7,l@1,q~sp~2],
         (*@note Q: why minus? A: because FormCalc`s -6,Lor[1],Lor[2] is ours 
          *-I*sigma[1,2] (according to FC definition of antisymmetrization), when 
          *taking this twice we get I*I=-1. @todo one really need to check "I conventions"
          *for FC because it cites [Ni05] for Fierz identities, where our
          *conventions are used, but in FC manual on the page 20 weird convention for sigma_munu is shown.*)
         ("minus_T_LL_via_"<>ToString@q) -> ch[o~sp~3,-7,l@1,l@2,i~sp~1] ch[q~sp~4,-7,l@1,l@2,q~sp~2],
         ("minus_T_RR_via_"<>ToString@q) -> ch[o~sp~3,-6,l@1,l@2,i~sp~1] ch[q~sp~4,-6,l@1,l@2,q~sp~2]
      };
   dimension7Template[i_,o_,q_] :=
      {
         "not_used_dummy_1" -> ch[o~sp~3,7,i~sp~1] ch[q~sp~4,7,mom@1,q~sp~2],
         "not_used_dummy_2" -> ch[o~sp~3,7,i~sp~1] ch[q~sp~4,6,mom@1,q~sp~2],
         "not_used_dummy_3" -> ch[o~sp~3,6,i~sp~1] ch[q~sp~4,7,mom@1,q~sp~2],
         "not_used_dummy_4" -> ch[o~sp~3,6,i~sp~1] ch[q~sp~4,6,mom@1,q~sp~2]
      };
   uNPF = uNPF~WilsonCoeffs`neglectBasisElements~dimension7Template[inF,outF,uQ];
   dNPF = dNPF~WilsonCoeffs`neglectBasisElements~dimension7Template[inF,outF,dQ];
   uNPF = uNPF~WilsonCoeffs`InterfaceToMatching~dimension6Template[inF,outF,uQ];
   dNPF = dNPF~WilsonCoeffs`InterfaceToMatching~dimension6Template[inF,outF,dQ];
   uNPF = uNPF.applySubexpressions[];
   dNPF = dNPF.applySubexpressions[];
   temp = uNPF;

   Print["C++ code calculation for ",inF,"->",outF," started ..."];
   codeU = CreateCXXFunctions[uNPF,
      nameForUpQuarkClass,
      SARAH`Delta,
      LoopFunctions -> paveLibrary,
      WilsonBasis -> dimension6Template[inF,outF,uQ] ][[2]];
   codeD = CreateCXXFunctions[dNPF,
      nameForUpDownClass,
      SARAH`Delta,
      LoopFunctions -> paveLibrary,
      WilsonBasis -> dimension6Template[inF,outF,dQ] ][[2]];
   Print["C++ code calculation for ",inF,"->",outF," done."];
   {
      DeleteDuplicates@Join[VerticesForNPointFunction@uNPF,VerticesForNPointFunction@dNPF],
      header,
      codeU<>"\n\n"<>codeD
   }
] /; Utils`AssertOrQuit[
   TrueQ@@And/@TreeMasses`IsFermion@{inF,outF},
   CreateCXXFToFConversionInNucleus::errFermion,
   inF->outF];
CreateCXXFToFConversionInNucleus // Utils`MakeUnknownInputDefinition;
CreateCXXFToFConversionInNucleus ~ SetAttributes ~ {Locked, Protected};

Options[NPointFunction]={
   LoopLevel -> 1,
   Regularize -> Switch[FlexibleSUSY`FSRenormalizationScheme,
      FlexibleSUSY`DRbar, DimensionalReduction,
      FlexibleSUSY`MSbar, DimensionalRegularization],
   UseCache -> True,
   ZeroExternalMomenta -> True,
   OnShellFlag -> True,
   ExcludeProcesses -> {}
};
NPointFunction::usage=
"@brief Calculate the n-point correlation function for a List of incoming and 
a List of outgoing fields.
@param inFields a List of incoming fields
@param outFields a List of outgoing fields
@param LoopLevel the loop level at which to perform the calculation
@param Regularize the regularization scheme to apply
@param UseCache whether to attempt to read and write the result from and to 
the cache.
@param ZeroExternalMomenta whether to set the external momenta to zero or leave 
them undetermined.
@param ExcludeProcesses a list or single symbol of topologies to exclude when 
calculation the n-point correlation function
@returns the corresponding n-point correlation function
@note only a loop level of 1 is currently supported
@note the recognized regularization schemes are:
 - DimensionalReduction
 - DimensionalRegularization
@note when not setting the external momenta to zero one should use LoopTools 
for the evaluation of the loop functions.";
NPointFunction::errinFields=
"The element '`1`' of inFields is an incorrect one.

inFields should contain only names from the list of `2` particles
`3`.
(SARAH`.`bar for fermions and Susyno`.`LieGroups`.`conj for scalars is
acceptable as well)
@unote now only restricted set is supported";
NPointFunction::erroutFields=
"The element '`1`' of outFields is an incorrect one.

outFields should contain only names from the list of `2` particles
`3`.
@unote now only restricted set is supported";
NPointFunction::errLoopLevel=
"Incorrect number of loops.

Only loop level 1 is supported";
NPointFunction::errRegularize=
"Unknown regularization scheme `1`.

Currently DimensionalReduction, DimensionalRegularization are supported.";
NPointFunction::errUseCache=
"UseCache must be either True or False.";
NPointFunction::errZeroExternalMomenta=
"ZeroExternalMomenta must be True, False or ExceptPave.";
NPointFunction::errOnShellFlag=
"OnShellFlag must be either True or False.";
NPointFunction::errExcludeProcesses=
"ExcludeProcesses must be sublist of 
{
   ExceptIrreducible,
   ExceptBoxes,
   ExceptTriangles,
   ExceptFourFermionScalarPenguins,
   ExceptFourFermionMassiveVectorPenguins
}.";
NPointFunction::errInputFields=                                                 (* @utodo modify it for usage of bosons also *)
"Only external scalars/fermions are supported (@todo FOR NOW).";
NPointFunction::errUnknownOptions=
"Unknown option(s):
`1`.

Currently supported options are:
`2`.";
NPointFunction[inFields_,outFields_,opts:OptionsPattern[]] :=
Module[
   {
      loopLevel = OptionValue[LoopLevel],
      regularizationScheme = OptionValue[Regularize],
      zeroExternalMomenta = OptionValue[ZeroExternalMomenta],
      excludeProcesses = OptionValue[ExcludeProcesses],                     (*@todo is not checked yet!*)
      onShellFlag = OptionValue[OnShellFlag],
      nPointFunctionsDir = output.getDirectory["NPointFunctions"],
      feynArtsDir = output.getDirectory["FeynArts"],
      feynArtsModel = output.getDirectory["FeynArts_model"],
      particleNamesFile = output.getFileName["Particles"],
      particleNamespaceFile = output.getFileName["Namespaces"],
      substitutionsFile = output.getFileName["Substitutions"],
      formCalcDir = output.getDirectory["FormCalc"],
      fsMetaDir = output.getDirectory["Meta"],
      subKernel,
      currentPath, currentDirectory,
      inFANames,outFANames,
      nPointFunction
   },
   If[!DirectoryQ@nPointFunctionsDir,CreateDirectory@nPointFunctionsDir];
   If[OptionValue@UseCache,
      nPointFunction = CachedNPointFunction[
         inFields,outFields,nPointFunctionsDir,
         OptionValue[NPointFunction,Options[NPointFunction][[All, 1]]]];
      If[nPointFunction =!= Null, Return@nPointFunction]
   ];

   If[!FileExistsQ[feynArtsModel <> ".mod"],
      subKernel = LaunchSubkernelFor@"creation of FeynArts model file";
      GenerateFAModelFileOnKernel@subKernel;                                    (*generates .dat .mod .m files insiide FeynArts directory*)
      WriteParticleNamespaceFile@particleNamespaceFile;
      CloseKernels@subKernel;
   ];
   
   SetSharedFunction@deletePrintFromSubkernel;
   subKernel = LaunchSubkernelFor@"FormCalc code generation";
   
   inFANames = FANamesForFields[inFields, particleNamesFile];
   outFANames = FANamesForFields[outFields, particleNamesFile];

   currentPath = $Path;
   currentDirectory = Directory[];

   DistributeDefinitions[currentPath, currentDirectory,
      fsMetaDir, feynArtsDir, formCalcDir, feynArtsModel,
      particleNamesFile, substitutionsFile, particleNamespaceFile,
      inFANames, outFANames, loopLevel, regularizationScheme,
      zeroExternalMomenta, excludeProcesses, onShellFlag];
      
   nPointFunction = RemoveEmptyGenSums@ParallelEvaluate[
      $Path = currentPath;
      SetDirectory@currentDirectory;
      
      Get@FileNameJoin@{fsMetaDir, "NPointFunctions", "internal.m"};

      NPointFunctions`SetInitialValues[feynArtsDir, formCalcDir, feynArtsModel,
         particleNamesFile, substitutionsFile, particleNamespaceFile];

      NPointFunctions`NPointFunctionFAFC[
         ToExpression@inFANames, ToExpression@outFANames,
         LoopLevel -> loopLevel,
         Regularize -> regularizationScheme,
         ZeroExternalMomenta -> zeroExternalMomenta,
         ExcludeProcesses -> excludeProcesses,
         OnShellFlag -> onShellFlag],
      subKernel
   ];
   CloseKernels@subKernel;
   UnsetShared@deletePrintFromSubkernel;

   If[OptionValue@UseCache,CacheNPointFunction[
      nPointFunction,nPointFunctionsDir,
   OptionValue[NPointFunction,Options[NPointFunction][[All,1]]]]];

   nPointFunction
] /; internalNPointFunctionInputCheck[inFields,outFields,opts];
Utils`MakeUnknownInputDefinition@NPointFunction;
internalNPointFunctionInputCheck[inFields:{__},outFields:{__},opts___] :=
Module[
   {
      aoq = Utils`AssertOrQuit,
      ip = TreeMasses`IsParticle,
      allowedParticles = Cases[TreeMasses`GetParticles[],_?TreeMasses`IsScalar|_?TreeMasses`IsFermion],(*@todo add |_?TreeMasses`IsVector*)
      definedOptions = Part[Options@NPointFunction,All,1],
      unknownOptions = FilterRules[{opts},Except@Part[Options@NPointFunction,All,1]],
      allProcesses={ExceptIrreducible,ExceptBoxes,ExceptTriangles,ExceptFourFermionScalarPenguins,ExceptFourFermionMassiveVectorPenguins}
   },
   aoq[ip@#,NPointFunction::errinFields,#,GetSARAHModelName[],allowedParticles]&/@inFields;
   aoq[ip@#,NPointFunction::erroutFields,#,GetSARAHModelName[],allowedParticles]&/@outFields;
   aoq[TreeMasses`IsScalar@#||TreeMasses`IsFermion@#,NPointFunction::errInputFields]&/@Join[inFields,outFields];(*@todo add vector bosons.*)
   aoq[unknownOptions === {},NPointFunction::errUnknownOptions,unknownOptions,definedOptions];
   (*Now we know that all options are iside allowed list.*)
   Cases[{opts},Rule[LoopLevel,x_]:>
      aoq[x===1,NPointFunction::errLoopLevel]];
   Cases[{opts},Rule[Regularize,x_]:>
      aoq[MemberQ[{DimensionalReduction,DimensionalRegularization},x],NPointFunction::errRegularize,x]];
   Cases[{opts},Rule[UseCache,x_]:>
      aoq[x===True || x===False,NPointFunction::errUseCache]];
   Cases[{opts},Rule[ZeroExternalMomenta,x_]:>
      aoq[MemberQ[{True,False,ExceptPave},x],NPointFunction::errZeroExternalMomenta]];
   Cases[{opts},Rule[OnShellFlag,x_]:>
      aoq[x===True || x===False,NPointFunction::errOnShellFlag]];
   Cases[{opts},Rule[ExcludeProcesses,x_]:>
      aoq[And@@Map[MemberQ[allProcesses~Append~Null,#]&,If[Head@x===List,x,{x}]],NPointFunction::errExcludeProcesses]];
   True
];

VerticesForNPointFunction::usage=
"@brief Return a list of all vertices needed to calculate a given 
n-point correlation function.
@param nPointFunction the given n-point correlation function
@returns a list of all vertices needed to calculate a given 
n-point correlation function.temp";
VerticesForNPointFunction[obj:`type`npf] :=
Module[
   {
      genSums = obj.getGenericSums[],
      substitutions = obj.getSubexpressions[],
      classRules = obj.getClassFieldRules[],
      positionsSubsWithVert =
         DeleteDuplicates[#[[1]] &/@ Position[obj.getSubexpressions[], SARAH`Cp[__]]],
      rulesWithVertices,vertsGen,GetVertex
   },
   rulesWithVertices = substitutions[[positionsSubsWithVert]];
   GetVertex[vertGen_,rules_] := vertGen/.#&/@rules;
   vertsGen = DeleteDuplicates@Cases[#, SARAH`Cp[fields__] :> {fields},
      Infinity,Heads -> True] &/@ (genSums/.rulesWithVertices);
   DeleteDuplicates[Vertices`StripFieldIndices/@#&/@Flatten[MapThread[GetVertex,{vertsGen,classRules}],2]]
];
Utils`MakeUnknownInputDefinition@VerticesForNPointFunction;

GetSARAHModelName::usage=
"@brief Return the SARAH model name as to be passed to SARAH`.`Start[].
@returns the SARAH model name as to be passed to SARAH`.`Start[].";
GetSARAHModelName[] := 
If[SARAH`submodeldir =!= False,
      SARAH`modelDir <> "-" <> SARAH`submodeldir,
      SARAH`modelDir
];
Utils`MakeUnknownInputDefinition@GetSARAHModelName;

LaunchSubkernelFor::usage=
"@brief Tries to launch a subkernel without errors.
If it fails, tries to explain the reason using message for specifying its
activity.
@param message String, which contains description of activity for which this
subkernel is launched for.
@returns subkernel name.
@note Mathematica 7 returns KernelObject[__], 11.3 returns {KernelObject[__]}
@note for Mathematica 7 some functions have the same names as in SARAH`.`";
LaunchSubkernelFor::errKernelLaunch=
"Unable to launch subkernel(s) during calculations for
`1`
because of error:";
LaunchSubkernelFor[message_String] /; $VersionNumber===7.0 :=
Module[{kernelName},
   Off[Parallel`Preferences`add::shdw,
      Parallel`Preferences`set::shdw,
      Parallel`Preferences`list::shdw,
      Parallel`Preferences`tr::shdw,
      Parallel`Protected`processes::shdw,
      SubKernels`Description::shdw];
   kernelName = Utils`EvaluateOrQuit[
      LaunchKernels[1],
      LaunchSubkernelFor::errKernelLaunch, message];
   On[Parallel`Preferences`add::shdw,
      Parallel`Preferences`set::shdw,
      Parallel`Preferences`list::shdw,
      Parallel`Preferences`tr::shdw,
      Parallel`Protected`processes::shdw,
      SubKernels`Description::shdw];
   kernelName
];
LaunchSubkernelFor[message_String] :=
Module[{kernelName},
   kernelName = Utils`EvaluateOrQuit[
      LaunchKernels[1],
      LaunchSubkernelFor::errKernelLaunch, message];
   If[Head@kernelName === List, kernelName[[1]], kernelName]
];
Utils`MakeUnknownInputDefinition@LaunchSubkernelFor;

CacheNameForMeta::usage=
"@brief Return the name of the cache file for given meta information
@param nPointMeta the given meta information
@returns the name of the cache file for given meta information.
";
CacheNameForMeta[nPointMeta:{__}] :=
   StringJoin["cache_",Riffle[ToString/@Flatten@nPointMeta, "_"],".m"];
Utils`MakeUnknownInputDefinition@CacheNameForMeta;

CacheNPointFunction::usage=
"@brief Write a given n-point correlation function to the cache
@param nPointFunction the given n-point correlation function
@param cacheDir the directory to save cache
@param nPointMeta the meta information about the given n-point correlation 
function";
CacheNPointFunction[nPointFunction_,cacheDir_,nPointMeta:{__}] :=
Module[
   {
      nPointFunctionsFile = FileNameJoin@{cacheDir,CacheNameForMeta@nPointMeta},
      fileHandle,
      nPointFunctions,
      position
   },
   If[FileExistsQ@nPointFunctionsFile,
      nPointFunctions = Get@nPointFunctionsFile,
      nPointFunctions = {}
   ];
   
   position = Position[nPointFunctions[[All,1]],nPointFunction[[1]]];
   If[Length@position === 1,
      nPointFunctions[[position[[1]]]] = nPointFunction,
      AppendTo[nPointFunctions, nPointFunction]
   ];

   fileHandle = OpenWrite@nPointFunctionsFile;
   Write[fileHandle,nPointFunctions];
   Close@fileHandle;
];
Utils`MakeUnknownInputDefinition@CacheNPointFunction;

CachedNPointFunction::usage=
"@brief Retrieve an n-point correlation function from the cache
@param inFields the incoming fields of the n-point correlation function
@param outFields the outgoing fields of the n-point correlation function
@param cacheDir the directory to save cache
@param nPointMeta the meta information of the n-point correlation function
@returns the corresponding n-point correalation function from the
cache or `Null` if such a function could not be found.
";
CachedNPointFunction[inFields_,outFields_,cacheDir_,nPointMeta:{__}] :=
Module[
   {
      nPointFunctionsFile = FileNameJoin@{cacheDir,CacheNameForMeta@nPointMeta}, 
      nPointFunctions, 
      position
   },
   If[!FileExistsQ@nPointFunctionsFile,Return@Null];
   nPointFunctions = Get@nPointFunctionsFile;
   position = Position[Vertices`StripFieldIndices[ nPointFunctions[[All,1]] ],
      {inFields, outFields}];
   If[Length@position == 1,nPointFunctions[[ position[[1,1]] ]],Null]
];
Utils`MakeUnknownInputDefinition@CachedNPointFunction;

GenerateFAModelFileOnKernel::usage=
"@brief Generate the FeynArts model file on a given subkernel.";
GenerateFAModelFileOnKernel[kernel_Parallel`Kernels`kernel] :=
Module[
   {
      currentPath = $Path, 
      currentDir = Directory[],
      fsMetaDir = output.getDirectory["Meta"],
      sarahInputDirs = SARAH`SARAH@SARAH`InputDirectories,
      sarahOutputDir = SARAH`SARAH@SARAH`OutputDirectory,
      SARAHModelName = GetSARAHModelName[], 
      eigenstates = FlexibleSUSY`FSEigenstates
   },
   DistributeDefinitions[currentPath, currentDir, fsMetaDir, sarahInputDirs, 
      sarahOutputDir, SARAHModelName, eigenstates];
      
   ParallelEvaluate[
      $Path = currentPath;
      SetDirectory@currentDir;
      Get@FileNameJoin@{fsMetaDir, "NPointFunctions", "createFAModelFile.m"};
      NPointFunctions`CreateFAModelFile[sarahInputDirs,sarahOutputDir,
         SARAHModelName, eigenstates];,
      kernel];
];
Utils`MakeUnknownInputDefinition@GenerateFAModelFileOnKernel;

WriteParticleNamespaceFile::usage=
"@brief Write a file containing all field names and the contexts in which they 
live in Mathematica.
@note This is necessary because SARAH puts fields into different contexts.";
WriteParticleNamespaceFile[fileName_String] :=
Module[{fileHandle = OpenWrite@fileName},
   Write[fileHandle, {ToString@#, Context@#} & /@ TreeMasses`GetParticles[]];
   Close@fileHandle;
];
Utils`MakeUnknownInputDefinition@WriteParticleNamespaceFile;

FANamesForFields::usage=
"@brief Translate SARAH-style fields to FeynArts-style fields
@param fields List of SARAH-style fields
@param particleNamesFile the path to the SARAH-created FeynArts
particle names file.
@returns A list of the FeynArts names (as strings) for the given
SARAH-style fields.";
FANamesForFields::errSARAH=
"NpointFunctions`.`Private`.`FANamesForFields[]: SARAH`.`:
It seems that SARAH`.` has changed conventions for
<ParticleNames>.dat file.";
FANamesForFields[fields_,particleNamesFile_String] :=
Module[
   {
      uniqueFields = DeleteDuplicates[
         CXXDiagrams`RemoveLorentzConjugation@# &/@ fields],
      faFieldNames
   },
   faFieldNames = 
   Flatten[
      StringCases[Utils`ReadLinesInFile@particleNamesFile, 
         ToString@# ~~ ": " ~~ x__ ~~ "]" ~~ ___ :> "FeynArts`" <> x <> "]"
      ] & /@ uniqueFields
   ];
   Utils`AssertWithMessage[Length@faFieldNames > 0, 
      FANamesForFields::errSARAH];
      
   fields /. MapThread[Rule, {uniqueFields, faFieldNames}] /. 
      {
         SARAH`bar@field_String :> "-" <> field, 
         Susyno`LieGroups`conj@field_String :> "-" <> field
      }
];
Utils`MakeUnknownInputDefinition@FANamesForFields;

RemoveEmptyGenSums::usage=
"@brief Sometimes after FA+FC calculation some generic sums are empty. This
means that one can simply remove them (as well as corresponding
colour/combinatoric factors and field substitution rules). This work is done by
this function.
@param npfObject NPF object to clean.
@returns cleaned from empty GenericSums npfObject.";
RemoveEmptyGenSums[npfObject:`type`npf]:=npfObject;
RemoveEmptyGenSums[
   {fields:{{__},{__}},
      {
         {
            sums:{GenericSum[_,{___}]..},
            rules:{{{__}..}..},
            comb:{{__Integer}..},
            col:{{__}..}
         },
         subs:{Rule[_,_]...}
      }
   }]:=
Module[{poss=Position[sums,GenericSum[0,{}]]},
   Print["Removing zero GenericSum at positions ",
      StringRiffle[ToString/@Flatten@poss,", "],"."];
   {fields,{Delete[#,poss]&/@{sums,rules,comb,col},subs}}
];
Utils`MakeUnknownInputDefinition@RemoveEmptyGenSums;

Options[CreateCXXHeaders]={
   LoopFunctions -> "FlexibleSUSY",
   UseWilsonCoeffs -> False
};
CreateCXXHeaders::usage=
"@brief Create the c++ code for the necessary headers for evaluation of n-point
correlation functions.
@param LoopFunctions the loop function library to be used
@returns the c++ code for the necessary headers for evaluation
of n-point correlation functions.";
CreateCXXHeaders::errUnknownOptions=
   NPointFunction::errUnknownOptions;
CreateCXXHeaders::errLoopFunctions=
"Unsupported loop functions library `1`.

Currently \"LoopTools\", \"FlexibleSUSY\" are supported.";
CreateCXXHeaders::errUseWilsonCoeffs=
"UseWilsonCoeffs must be either True or False.";
CreateCXXHeaders[opts:OptionsPattern[]] :=
Module[
   {
      mainHPP = "\"cxx_qft/" <> FlexibleSUSY`FSModelName <>
         If[OptionValue@UseWilsonCoeffs,
            "_npointfunctions_wilsoncoeffs.hpp\"",
            "_npointfunctions.hpp\""],
      loopHPP = Switch[OptionValue@LoopFunctions,
         "LoopTools","\"clooptools.h\"",
         "FlexibleSUSY","\"numerics.h\"",
         "GenericLibrary","\"loop_libraries/collier.hpp\""]
   },
   "#include " <> mainHPP <> "\n" <>
   "#include \"concatenate.hpp\"\n" <>
   "#include <boost/fusion/include/at_key.hpp>" <> "\n" <>
   "#include <boost/core/is_same.hpp>" <> "\n" <>
   "#include " <> loopHPP
] /; And[
   Utils`AssertOrQuit[
      FilterRules[{opts},Except@Part[Options@CreateCXXHeaders,All,1]] === {},
      CreateCXXHeaders::errUnknownOptions,
      FilterRules[{opts},Except@Part[Options@CreateCXXHeaders,All,1]],
      Part[Options@CreateCXXHeaders,All,1]
   ],
   Utils`AssertOrQuit[
      MemberQ[{"LoopTools", "FlexibleSUSY","GenericLibrary"}, OptionValue@LoopFunctions],
      CreateCXXHeaders::errLoopFunctions,
      OptionValue@LoopFunctions
   ],
   Utils`AssertOrQuit[
      OptionValue@UseWilsonCoeffs === True ||
      OptionValue@UseWilsonCoeffs === False,
      CreateCXXHeaders::errUseWilsonCoeffs
   ]
];
Utils`MakeUnknownInputDefinition@CreateCXXHeaders;

Options[CreateCXXFunctions]={
   LoopFunctions -> "FlexibleSUSY",
   WilsonBasis -> {}
};
CreateCXXFunctions::usage=
"@brief Given a list of n-point correllation functions, a list
of c++ function names and a list of colour factor projections
create the c++ code for the numerical evaluation of the
n-point correllation functions.
@param NPF n-point correlation function object.
@param name function name
@todo colourProjector colour factor projection that shall be applied to the
general expressions for the colour factors in the corresponding n-point
correllation function. The result of applying such a projection must be a scalar.
@param LoopFunctions the loop function library to be used.
@note Currently, only FlexibleSUSY and LoopTools are supported as
loop function libraries.
@returns a list of the form `{prototypes, definitions}` containing
the corresponding c++ code.";
CreateCXXFunctions::errcolourProjector=
"Only Identity and SARAH`.`Delta are supported.";
CreateCXXFunctions::errUnknownOptions=
   NPointFunction::errUnknownOptions;
CreateCXXFunctions::errLoopFunctions=
   CreateCXXHeaders::errLoopFunctions;
CreateCXXFunctions::errNPFNoBasis=
"Basis expressions are absent, but NPF object was converted to be used with some.";
CreateCXXFunctions::errBasisNoNPF=
"Basis expressions are given, but NPF object was not converted to be used with them
(use WilsonCoeffs`.`InterfaceToMatching on NPF object).";
CreateCXXFunctions::errNoMatch=
"Length of basis and the given NPF one does not match."
CreateCXXFunctions[
   NPF:`type`npf,
   name:_String,
   colourProjector_,
   opts:OptionsPattern[]
] :=
Module[
   {
      mainFunction = If[OptionValue@WilsonBasis === {},
         "std::complex<double> "<>#2<>"("<>#3<>")",
         "std::array<std::complex<double>,"<>ToString@#1<>"> "<>#2<>"("<>#3<>")"
      ]&,
      basisLength = Length@OptionValue@WilsonBasis,
      prototype,definition
   },
   setLoopLibraryRules@OptionValue@LoopFunctions;
   prototype = mainFunction[basisLength,name,CXXArgStringNPF[NPF,"def"]]<>";";

   definition =
      CXXClassForNPF[NPF,colourProjector,OptionValue@LoopFunctions,OptionValue@WilsonBasis] <> "\n\n" <>
      mainFunction[basisLength,name,CXXArgStringNPF@NPF] <>
      "{\n" <> CXXBodyNPF@NPF <> "\n}";

   {prototype, definition}
] /; Module[
   {
      optionNames = Part[Options@CreateCXXFunctions,All,1],
      sums = First/@(NPF.getGenericSums[])
   },
   Utils`AssertOrQuit[MatchQ[#,Identity|SARAH`Delta],CreateCXXFunctions::errcolourProjector,#]&@colourProjector;
   Utils`AssertOrQuit[
      FilterRules[{opts},Except@optionNames] === {},
      CreateCXXFunctions::errUnknownOptions,
      FilterRules[{opts},Except@optionNames],
      optionNames];
   If[OptionValue@WilsonBasis === {},
      Utils`AssertOrQuit[And@@(Head@#=!=List&/@sums),CreateCXXFunctions::errNPFNoBasis],
      Utils`AssertOrQuit[And@@(Head@#===List&/@sums),CreateCXXFunctions::errBasisNoNPF];
      Utils`AssertOrQuit[Part[Length/@sums,1]===Length@OptionValue@WilsonBasis,CreateCXXFunctions::errNoMatch];
      ];
   Utils`AssertOrQuit[
      MemberQ[{"LoopTools","FlexibleSUSY","GenericLibrary"}, OptionValue@LoopFunctions],
      CreateCXXFunctions::errLoopFunctions,
      OptionValue@LoopFunctions]
];
Utils`MakeUnknownInputDefinition@CreateCXXFunctions;

loopLibrary = {};
SetAttributes[loopLibrary,Protected];
setLoopLibraryRules[library_String] :=
Module[{},
   ClearAttributes[loopLibrary,Protected];
   loopLibrary = Switch[library,
      "LoopTools", Rule[Symbol@#,StringDrop[ToString@#,10]]&/@Names@"LoopTools`*",
      "FlexibleSUSY", getLoopFlexibleSUSYRules[],
      "GenericLibrary", getGenericLibraryRules[]
   ];
   SetAttributes[loopLibrary,Protected];
];
Utils`MakeUnknownInputDefinition@setLoopLibraryRules;
SetAttributes[setLoopLibraryRules,{Locked,Protected}];
getLoopLibraryRules[] := loopLibrary;
Utils`MakeUnknownInputDefinition@getLoopLibraryRules;
SetAttributes[getLoopLibraryRules,{Locked,Protected}];

getLoopFlexibleSUSYRules::usage=
"@brief Returns rules for LoopTools to FlexibleSUSY conventions.
@returns Rules for LoopTools to FlexibleSUSY conventions.
@todo add specific rules for std::sqrt(0)
@todo add specific rules for std::sqrt(Sqr())";
getLoopFlexibleSUSYRules[] :=
Module[
   {
      warning = If[!$Notebooks,"\033[1;33mWarning\033[1;0m",Style["Warning",Yellow]],
      SqrtIfNeeded
   },
   SqrtIfNeeded[0]=0;
   SqrtIfNeeded[Power[arg_,2]]:=arg;
   SqrtIfNeeded[arg_]:="std::sqrt"@arg;
   Print[warning,": Only remaps of A0, B0, C0, C00, D0 and D00 are implemented."];
   Print[warning,": FlexibleSUSY C0, D0 and D00 require zero external momenta."];
   {
      LoopTools`A0i[LoopTools`aa0, args__] :>
         "softsusy::a0"[Sequence@@SqrtIfNeeded/@{args},"context.scale()"],
      LoopTools`A0[arg_] :>
         "softsusy::a0"[SqrtIfNeeded@arg,"context.scale()"],
      LoopTools`B0i[LoopTools`bb0, args__] :>
         "softsusy::b0"[Sequence@@SqrtIfNeeded/@{args},"context.scale()"],
      LoopTools`B0i[LoopTools`bb1, args__] :>
         "(-1)*softsusy::b1"[Sequence@@SqrtIfNeeded/@{args},"context.scale()"],
      LoopTools`C0i[LoopTools`cc0, 0, 0, 0, args__] :>
         "softsusy::c0"[Sequence@@SqrtIfNeeded/@{args}],
      LoopTools`C0i[LoopTools`cc00, 0, 0, 0, args__] :>
         "softsusy::c00"[Sequence@@SqrtIfNeeded/@{args}, "context.scale()"],
      LoopTools`D0i[LoopTools`dd0, 0, 0, 0, 0, 0, 0, args__] :>
         "softsusy::d0"[Sequence@@SqrtIfNeeded/@{args}],
      LoopTools`D0i[LoopTools`dd00, 0, 0, 0, 0, 0, 0, args__] :>
         "softsusy::d27"[Sequence@@SqrtIfNeeded/@{args}]
   }
];
Utils`MakeUnknownInputDefinition@getLoopFlexibleSUSYRules;
   
getGenericLibraryRules[] :=
Module[
   {
      warning = If[!$Notebooks,"\033[1;33mWarning\033[1;0m","Warning"]
   },
   WriteString[OutputStream["stdout", 1],
      warning<>": Only remaps of B0, C0, C00 are implemented.\n"];
   {
      LoopTools`B0i[LoopTools`bb0,args__] :> "lib->B0"[args,"context.scale()"],
      LoopTools`C0i[LoopTools`cc0,args__] :> "lib->C0"[args,"context.scale()"],
      LoopTools`C0i[LoopTools`cc00,args__] :> "lib->C00"[args,"context.scale()"]
   }
];
Utils`MakeUnknownInputDefinition@getGenericLibraryRules;

CXXArgStringNPF::usage=
"@brief Returns the c++ arguments that the c++ version of the given n-point 
correlation function shall take.
Default value of zero for all external momenta is chosen if the second parameter
is \"def\".
@param nPointFunction the given n-point correlation function
@param control String that sets up the type of argument string
@return the c++ arguments that the c++ version of the given n-point 
correlation function shall take.";
CXXArgStringNPF[nPointFunction:`type`npf,control_String:""] :=
Module[
   {
      str = If[control === "def",
         "const `1` &model, const std::array<int,`2`> &indices, const std::array<Eigen::Vector4d,`3`> &momenta = { `4` }",
         "const `1` &model, const std::array<int,`2`> &indices, const std::array<Eigen::Vector4d,`3`> &momenta"],
      numInd = Length[nPointFunction.getExternalIndices[]],
      numMom = Length[nPointFunction.getExternalMomenta[]],
      eigenType = FlexibleSUSY`FSModelName<>"_mass_eigenstates",
      momDef
   },
   momDef = StringJoin@Riffle[Table["Eigen::Vector4d::Zero()",{numMom}],", "];
   StringTemplate[str][eigenType,numInd,numMom,momDef]
];
Utils`MakeUnknownInputDefinition@CXXArgStringNPF;

CXXBodyNPF::usage=
"@brief Rturns the c++ code for the main master-function.
@param <n> NPointFunction object
@returns The c++ code for the main master-function.";
CXXBodyNPF[nPointFunction:`type`npf] :=
StringTemplate["   `1` helper{ model, indices, momenta };\n   return helper.calculate();"][
   CXXClassNameNPF@nPointFunction];
Utils`MakeUnknownInputDefinition@CXXBodyNPF;

CXXClassNameNPF::usage=
"@brief Return the c++ name for the helper class of the c++
version of a given n-point correlation function.
@param NPointFunction object
@returns the c++ name for the helper class of the c++
version of a given n-point correlation function.";
CXXClassNameNPF[obj:`type`npf,_String:""] :=
Module[{fieldNames = Vertices`StripFieldIndices/@Join@@(obj.getProcess[])},
   "nPoint" <> StringJoin@Map[ToString,fieldNames/.a_[b_]:>Sequence@@{a,b}]
];
Utils`MakeUnknownInputDefinition@CXXClassNameNPF;

CXXClassForNPF::usage=
"@brief Return the c++ code for the helper class of the c++ version of a given
n-point correlation function.
@param nPointFunction the given n-point correlation function
@param projectColourFactor the colour factor projection to be applied for the
given n-point correlation function
@returns the c++ code for the helper class of the c++ version of a given
n-point correlation function.";
CXXClassForNPF[
   nPointFunction:`type`npf,
   projCol_,
   loopLibrary_String,
   wilsonBasis:{Rule[_String,_]...}] :=
Module[
   {
      genSums = nPointFunction.getGenericSums[],
      subexpressions = nPointFunction.getSubexpressions[],
      extIndices = nPointFunction.getExternalIndices[],
      numberOfMomenta = Length[nPointFunction.getExternalMomenta[]],
      cxxCorrelationContext,
      genFields = DeleteDuplicates[Flatten[nPointFunction.getClassFieldRules[]] /. Rule[x_,_] :> x],
      genSumNames,
      preCXXRules,
      code = "
      class @ClassName@ : public @Context@ {
         using generic_sum_base = @Context@;

         template<class GenericFieldMap>
         struct subexpression_base :
         generic_sum_base, index_map_interface<GenericFieldMap> {
            subexpression_base( const subexpression_base & ) = default;

            subexpression_base( const generic_sum_base &gsb, 
               const typename field_index_map<GenericFieldMap>::type &fim ) :
            generic_sum_base( gsb ), index_map_interface<GenericFieldMap>( fim ) {
            }
         }; // End of subexpression_base<GenericFieldMap>

         @KeyStructsInitialization@

         @Subexpressions@

         @GenericSums@

         public:
         @ClassName@( @Arguments@ ) :
         @Context@ { model, indices, momenta } {
         }
      
         @CalculateFunction@
      }; // End of @ClassName@"
   },
   genSumNames = Array["genericSum"<>ToString@#&,Length@genSums];
   preCXXRules = ToCXXPreparationRules[extIndices,genFields,subexpressions];
   cxxCorrelationContext = "correlation_function_context<"<>ToString@Length@extIndices<>","<>ToString@numberOfMomenta<>">";

   code.replaceTokens[{
   "@ClassName@"->CXXClassNameNPF@nPointFunction,
   "@Context@"->cxxCorrelationContext,
   "@KeyStructsInitialization@"->CXXInitializeKeyStructs@genFields,
   "@Subexpressions@"->CXXCodeForSubexpressions[subexpressions, preCXXRules],
   "@GenericSums@"->CXXGenericSum[nPointFunction,preCXXRules,projCol,genSumNames,loopLibrary,wilsonBasis],
   "@Arguments@"->CXXArgStringNPF@nPointFunction,
   "@CalculateFunction@"->CXXCodeFunCalculate[genSumNames,wilsonBasis]}]
];
Utils`MakeUnknownInputDefinition@CXXClassNameNPF;

CXXInitializeKeyStructs::usage =
"@brief Generates required c++ code for key structs initialization.
@param fields:{...} list of presenting generic fields.
@returns c++ code for subexpression if generic fields present there.";
CXXInitializeKeyStructs[fields:{`type`genericField..}]:=
StringRiffle["struct "<>#<>" {};"&/@CXXGenFieldKey/@fields,"\n"];
Utils`MakeUnknownInputDefinition@CXXInitializeKeyStructs;
SetAttributes[CXXInitializeKeyStructs,{Protected,Locked}];

ToCXXPreparationRules::usage=
"@brief Generate a list of rules for translating Mathematica expressions of
n-point correlation functions to c++ counterparts.
@param externalIndices the external indices of an n-point correlation function
@param genericFields the generic fields appearing in an n-point correlation
function
@param subexpressions the list of subexpressions needed to evaluate an n-point
correlation function
@returns a list of rules for translating Mathematica expressions of n-point
correlation functions to c++ counterparts.";
ToCXXPreparationRules[extIndices_List,genericFields_List,subexpressions:`type`subexpressions] :=
Module[
   {
      externalIndexRules = MapThread[Rule,{extIndices,
         Map[StringTemplate@"this->external_indices(`1`)",
            Array[#-1&,Length@extIndices]]}],
      AuxVertexType,
      genericRules,subexprRules,massRules,couplingRules
   },
   genericRules=Flatten[Thread@Rule[
      {#.getConjugated[],#},
      {
         (#.getConjugated[].getName[cxx])[#.getIndex[cxx]],
         (#.getName[cxx])[#.getIndex[cxx]]
      }] &/@ genericFields];

   AuxVertexType[fields__]:= StringRiffle[
      If[MatchQ[#,`type`genericField],
         #.getName[cxx],
         CXXFieldName@#]&/@{fields},", "];
   couplingRules = {
      SARAH`Cp[fields__][1] :>
      I*StringTemplate["context.vertex<`1`>(lorentz_scalar{}, concatenate(`2`))"][
         AuxVertexType@fields,
         StringRiffle[CXXFieldIndices/@{fields},", "]
         ],
      SARAH`Cp[fields__][SARAH`PL] :>
      I*StringTemplate["context.vertex<`1`>(lorentz_left{}, concatenate(`2`))"][
         AuxVertexType@fields,
         StringRiffle[CXXFieldIndices/@{fields},", "]
         ],
      SARAH`Cp[fields__][SARAH`PR] :>
      I*StringTemplate["context.vertex<`1`>(lorentz_right{}, concatenate(`2`))"][
         AuxVertexType@fields,
         StringRiffle[CXXFieldIndices/@{fields},", "]
         ],
      SARAH`Cp[fields___][SARAH`Mom[f1_] - SARAH`Mom[f2_]] :>
      I*StringTemplate["context.vertex<`1`>(lorentz_momentum_diff{`2`,`3`}, concatenate(`4`))"][
         AuxVertexType@fields,
         First@@Position[{fields},f1,{1}]-1,                                    (*@note hope that nobody call particle List*)
         First@@Position[{fields},f2,{1}]-1,                                    (*@note hope that nobody call particle List*)
         StringRiffle[CXXFieldIndices/@{fields},", "]
         ],
      SARAH`Cp[fields__][SARAH`g[_,_]] :>
      I*StringTemplate["context.vertex<`1`>(lorentz_inverse_metric{}, concatenate(`2`))"][
         AuxVertexType@fields,
         StringRiffle[CXXFieldIndices/@{fields},", "]
         ],
      SARAH`Cp[fields__][(SARAH`Mom[f2_, _]-SARAH`Mom[f1_, _])*SARAH`g[_,_],
         (SARAH`Mom[f1_,_]-SARAH`Mom[f3_,_])*SARAH`g[_,_],
         (SARAH`Mom[f3_,_]-SARAH`Mom[f2_,_])*SARAH`g[_,_]] :>
      I*StringTemplate["context.vertex<`1`>(triple_vector{}, concatenate(`2`))"][
         AuxVertexType@fields,
         StringRiffle[CXXFieldIndices/@{fields},", "]
         ]
   };
   massRules = {
      SARAH`Mass[genField_String[genIndex_String]] :>
         StringTemplate["context.mass<`1`>(`2`)"][genField,genIndex],
      SARAH`Mass[extField_Symbol[{extIndex_String}]] :>                         (*@todo field without `conj or `bar*)
         StringTemplate["context.mass<fields::`1`>(std::array<int,1> {`2`})"][  (*@todo here only one external index is allowed*)
         extField,extIndex],                                                    (*@todo *)
      SARAH`Mass[extField_Symbol] :>                                            (*@todo field without `conj or `bar*)
         StringTemplate["context.mass<fields::`1`>(std::array<int,0> {})"][     (*@todo here only zero external indices are allowed*)
         extField]                                                              (*@todo *)
   };
   subexprRules = Rule[First@#, ToString@First@# <> "_()"] &/@ subexpressions;

   {externalIndexRules,couplingRules,genericRules, massRules, subexprRules}
];
Utils`MakeUnknownInputDefinition@ToCXXPreparationRules;

CXXFieldName::usage = 
"@brief Given an explicit field (possibly conjugated), returns its c++ representation.
@param The given generic field
@returns String Name of the c++ representation for a field (possibly conjugate).";
CXXFieldName[SARAH`bar[head_]] :=
   StringJoin["typename bar<",CXXFieldName@head,">::type"];
CXXFieldName[Susyno`LieGroups`conj[head_]] :=
   StringJoin["typename conj<",CXXFieldName@head,">::type"]
CXXFieldName[fieldName_Symbol[_?VectorQ] | fieldName_Symbol] :=
   StringJoin["fields::",SymbolName@fieldName];
Utils`MakeUnknownInputDefinition@CXXFieldName;

CXXFieldIndices::usage=
"@brief Return the c++ expression for the container of the indices of a given
(possibly generic) field.
@param field the given field
@returns the c++ expression for the container of the indices of a given
(possibly generic) field.
@note functions saves its unique previous calls to improve the speed of
calculations.";
CXXFieldIndices[SARAH`bar[field_]] := CXXFieldIndices[SARAH`bar[field]] =
   CXXFieldIndices@field;
CXXFieldIndices[Susyno`LieGroups`conj[field_]] := CXXFieldIndices[Susyno`LieGroups`conj[field]] =
   CXXFieldIndices@field;
CXXFieldIndices[head_[GenericIndex[index_Integer]]] := CXXFieldIndices[head[GenericIndex[index]]] =
   "indices"<>StringTake[SymbolName@head,-1]<>ToString@index;
CXXFieldIndices[field_] := CXXFieldIndices[field] =
If[Length@field === 0,
   "std::array<int,0>()",
   "std::array<int,"<>ToString[Length@@field]<>">{"<>StringJoin@Riffle[ToString/@First@field,", "]<>"}"
];
Utils`MakeUnknownInputDefinition@CXXFieldIndices;

CXXCodeForSubexpressions::usage=
"@brief Create the c++ code encoding a given set of subexpressions.
@param subexpressions the list of subexpressions
@param preCXXRules a list of rules to apply to the subexpressions before
calling ``Parameters`ExpressionToString[]`` for the c++ translation.
@returns the c++ code encoding a given set of subexpressions.";
CXXCodeForSubexpressions[
   {},
   {{(_Rule|_RuleDelayed)...}...}] := "// There is no subexpressions";
CXXCodeForSubexpressions[
   subexpressions:`type`subexpressions,
   preCXXRules:{{(_Rule|_RuleDelayed)...}...}] :=
Module[
   {
      names = First/@subexpressions,
      exprs = Last/@subexpressions,
      relevantSubs,relevantGens,cxxExprs,data,outStrings,
      code = "
      template<class GenericFieldMap>
      struct @SubexpressionName@ : subexpression_base<GenericFieldMap> {
         template<class ...Args>
         @SubexpressionName@(Args&& ...args) :
         subexpression_base<GenericFieldMap>(std::forward<Args>(args)...) {
         } // End of constructor @SubexpressionName@<...>

         std::complex<double> operator()( void ) const {
            @CodeIfOtherSubexpressionsPresent@
            @CodeIfGenericFieldsPresent@
            @CodeIfMassesOrVerticesPresent@
            
            @ReturnResult@
         } // End of operator()( void )
      }; // End of struct @SubexpressionName@<GenericFieldMap>
      "
   },
   relevantSubs = DeleteDuplicates/@
      Map[Cases[#,subs:Alternatives@@names:>subs,Infinity,Heads->True]&,exprs];
   relevantGens = DeleteDuplicates/@
      Map[Cases[#,_[GenericIndex[_]],Infinity,Heads->True]&,exprs];
   cxxExprs = StringReplace[#,"\""->""]&@
      Map[Parameters`ExpressionToString[Fold[ReplaceAll,#,preCXXRules]]&,exprs];
   data = {ToString/@names,relevantSubs,relevantGens,exprs,cxxExprs};
   outStrings=MapThread[code.replaceTokens[
      {
         "@SubexpressionName@"->#1,
         "@CodeIfOtherSubexpressionsPresent@"->CXXSubsInSub@#2,
         "@CodeIfGenericFieldsPresent@"->CXXGenericFieldsInSub@#3,
         "@CodeIfMassesOrVerticesPresent@"->CXXContextInitialize@#4,
         "@ReturnResult@"->stringGeneratedCut["return "<>#5<>";",100,","]
      }
   ]&,data];
   StringRiffle[outStrings,"\n\n"]
];
Utils`MakeUnknownInputDefinition@CXXCodeForSubexpressions;

CXXGenFieldKey::usage=
"@brief Given a generic field, determine its key type used in the c++ code to
uniquely label it.
@param genericField given generic field.
@param {genericField..} given generic fields.
@param ind (def. \"\") string which is responsible for an indent of code.
@returns c++ key type of a generic field(s).";
CXXGenFieldKey[fields:{__}, _String:""] :=
   StringRiffle[CXXGenFieldKey/@fields,", "];
CXXGenFieldKey[head_[GenericIndex[index_Integer]]] :=
   ToString@head<>ToString@index<>"Key";
Utils`MakeUnknownInputDefinition@CXXGenFieldKey;
SetAttributes[CXXGenFieldKey,{Protected,Locked}]

CXXSubsInSub::usage=
"@brief Generates required c++ code for subexpression if other subexpressions
present there.
@param subs:{...} list of symbols.
@returns String c++ code for subexpression if other subexpressions present there.";
CXXSubsInSub[subs:{__Symbol}] :=
StringRiffle[
   ToString@#<>"<GenericFieldMap> "<>ToString@#<>"_ { *this };"&/@subs,
   "\n"];
CXXSubsInSub[{}] :=
"// This subexpression does not depend on other ones";
Utils`MakeUnknownInputDefinition@CXXSubsInSub;

CXXGenericFieldsInSub::usage =
"@brief Generates required c++ code for subexpression if generic fields present
there.
@param fields:{...} list of presenting generic fields.
@returns c++ code for subexpression if generic fields present there.";
CXXGenericFieldsInSub[fields:{`type`genericField..}] :=
Module[
   {
      names = (#.getName[cxx])&/@fields,
      indices = (#.getIndex[cxx])&/@fields,
      keys = CXXGenFieldKey/@fields,
      fLns,iLns,
      mainCommands = {
         "using boost::mpl::at;",
         "using boost::fusion::at_key;",
         "`1`",
         "`2`"},
      fCommand = "using `1` = typename at<GenericFieldMap, `2`>::type;",
      iCommand = "const auto &`1` = at_key<`2`>(this->index_map());"
   },
   fLns=StringRiffle[MapThread[StringTemplate@fCommand,{names,keys}],"\n"];
   iLns=StringRiffle[MapThread[StringTemplate@iCommand,{indices,keys}],"\n"];
   StringTemplate[StringRiffle[mainCommands,"\n"]][fLns,iLns]
];
CXXGenericFieldsInSub[{},_String:""] :=
"// This subexpression does not depend on generic fields";
Utils`MakeUnknownInputDefinition@CXXGenericFieldsInSub;

CXXContextInitialize::usage ="@brief Generates required c++ code if couplings or masses present.
@param expr Any expression to check for mass of coupling presence.
@param ind (def. \"\") indent string for a c++ code.
@returns String c++ code for subexpression if couplings or masses present there.";
CXXContextInitialize[expr_,_String:""] :=
If[Not[FreeQ[expr,SARAH`Cp]&&FreeQ[expr,SARAH`Mass]],
   "const context_with_vertices &context = *this;",
   "// Code in this scope does not depend on couplings or masses"
];
Utils`MakeUnknownInputDefinition@CXXContextInitialize;

ExtractColourFactor::usage=
"@brief Extracts the colour factor for a given colour structure.";
ExtractColourFactor::errMultipleColourStructures=
"There are different colour projectors inside colour factors:
`1`.";
ExtractColourFactor::errNotNumber=
"After projection element
`1`
still is not a number."
ExtractColourFactor::warnTryingIdentity=
"Warning: There are no colour projectors of the given type. Trying to apply Identity."
ExtractColourFactor[colourfactors:{{__}..}, projection_] :=
Module[
   {
      projectedFactors,uniqueColourStructs
   },
   projectedFactors=
   If[projection === Identity,
      colourfactors,
      uniqueColourStructs=DeleteDuplicates@Cases[colourfactors,pr:projection[__]:>pr,Infinity];
      Utils`AssertOrQuit[Length@uniqueColourStructs<=1,ExtractColourFactor::errMultipleColourStructures,uniqueColourStructs];
      If[Length@uniqueColourStructs===0,
         Print[ExtractColourFactor::warnTryingIdentity];
         colourfactors,
         colourfactors/.Rule[uniqueColourStructs[[1]],1]
         ]
      ];
   Utils`AssertOrQuit[NumericQ@#,ExtractColourFactor::errNotNumber,#]&/@Flatten[projectedFactors,2];
   
   projectedFactors
];
Utils`MakeUnknownInputDefinition@ExtractColourFactor;

CXXGenericSum::usage=
"@brief Create the c++ code encoding a given sum over generic fields.
@param sum the sum over generic fields
@param genericInsertions the list of field insertions to be summed over
@param combinatorialFactors a list of combinatorial factors (~symmetry factors) 
to multiply the amplitudes of specific insertions with.
@todo
@param colourFactors a list of colour factors to multiply the amplitudes of
specific insertions with.
@param functionName the name of the resulting c++ function
@param subexpressions the list of subexpressions
@param preCXXRules a list of rules to apply to the subexpressions
before calling ``Parameters`ExpressionToString[]`` for the c++
translation.
@returns the c++ code encoding the given sum over generic fields.
@note the most time consuming procedure.";
CXXGenericSum::errColours=
"Colour factor is not a number after projection: `1`";
CXXGenericSum[
   obj:`type`npf,
   preCXXRules_List,
   colourProjector_,
   genSumNames:{__String},
   loopLibrary_String,
   basis:{Rule[_String,_]...}
] :=
Module[{},
   StringRiffle[MapThread[
      CXXGenericSum[##,obj.getSubexpressions[],preCXXRules,loopLibrary,basis]&,
         {
            obj.getGenericSums[],
            obj.getClassFields[],
            obj.getClassCombinatoricalFactors[],
            ExtractColourFactor[obj.getClassColorFactors[],colourProjector],
            genSumNames
         }],
      "\n\n"]
];
CXXGenericSum[
   sum:`type`genericSum,
   genericInsertions:`type`classFields,
   combinatorialFactors:`type`classCombinatoricalFactors,
   colourFactors:`type`classColorFactors,
   genSumName_String,
   subexpressions:`type`subexpressions,
   preCXXRules_List,
   loopLibrary_String,
   wilsonBasis_
] :=
Module[
   {
      type = If[wilsonBasis === {},
         "std::complex<double>",
         "std::array<std::complex<double>,"<>ToString@Length@wilsonBasis<>">"
         ],
      context = If[Not[FreeQ[sum.getExpression[],SARAH`Cp]&&FreeQ[sum.getExpression[],SARAH`Mass]],
         "const context_with_vertices &context = *this;",
         "// This GenericSum does not depend on couplings or masses"],
      hide = If[loopLibrary === "GenericLibrary","","//"],
      code = "
      template<class GenericFieldMap>
      struct @GenericSum_NAME@_impl : generic_sum_base {
         @Hide@private:
         @Hide@std::unique_ptr<Loop_library_interface> lib = std::make_unique<Collier>(); // The code is generated for Generic library.
         @Hide@public:
         @GenericSum_NAME@_impl( const generic_sum_base &base ) : 
         generic_sum_base( base ) {
         } // End of constructor @GenericSum_NAME@_impl

         @ReturnType@ operator()( void ) {
            using boost::mpl::at;
            using boost::fusion::at_key;
            @GenericFieldShortNames@

            typename field_index_map<GenericFieldMap>::type index_map;
            @InitializeSubstitutions@
            @InitializeContext@
            @InitializeOutputVars@


            @SummationOverGenericFields@

            @ReturnOutputVars@
         } // End of operator()( void )
      }; // End of struct @GenericSum_NAME@_impl<GenericFieldMap>

      @ReturnType@ @GenericSum_NAME@( void ) {
         using GenericKeys = boost::mpl::vector< @GenericKeys@ >;
         using GenericInsertions = boost::mpl::vector<
            @ClassInsertions@
            >;
         using combinatorial_factors = boost::mpl::vector<
            @CombinatoricalFactors@
            >;
         using colour_factors = boost::mpl::vector<
            @ColorFactors@
            >;
         return accumulate_generic<
            GenericKeys,
            GenericInsertions,
            combinatorial_factors,
            colour_factors,
            @FermionBasisMETALength@,
            @GenericSum_NAME@_impl
            >( *this );
      } // End of function @GenericSum_NAME@()"
   },
   code.replaceTokens[
      {
         "@Hide@"->hide,
         "@GenericSum_NAME@"->genSumName,
         "@ReturnType@"->type,
         "@GenericFieldShortNames@"->CXXCodeNameKey[sum.getGenericFields[]],
         "@InitializeSubstitutions@"->CXXSubsInGenericSum[sum,subexpressions],
         "@InitializeContext@"->context,
         "@InitializeOutputVars@"->CXXInitializeOutput@wilsonBasis,
         "@SummationOverGenericFields@"->CXXChangeOutput[sum.getSummationData[],Rule[sum.getExpression[],preCXXRules],wilsonBasis],
         "@ReturnOutputVars@"->CXXReturnOutput@wilsonBasis,
         "@GenericKeys@"->CXXGenFieldKey[sum.getGenericFields[]],
         "@ClassInsertions@"->CXXClassInsertions@genericInsertions,
         "@CombinatoricalFactors@"->CXXFactorInsertions@combinatorialFactors,
         "@ColorFactors@"->CXXColourInsertions@colourFactors,
         "@FermionBasisMETALength@"->CXXFermionMetaLength@wilsonBasis
      }
   ]
] /; And[
   MatchQ[colourFactors,
      {__?(Utils`AssertOrQuit[NumberQ@#,
         CXXGenericSum::errColours,
         #]&
      )}]
];
Utils`MakeUnknownInputDefinition@CXXGenericSum;

CXXInitializeOutput::usage =
"@brief Generates c++ code for output value initializations inside GenericSum.
@param wilsonBasis:{Rule[_,_]...} list of basis for calculation.
@returns String c++ code for output value initializations inside GenericSum.";
CXXInitializeOutput[{},_String:""] :=
"std::complex<double> value = 0.0;";
CXXInitializeOutput[wilsonBasis:{Rule[_String,_]..}] :=
StringRiffle["std::complex<double> "<>#<>" = 0.0;"&/@Part[wilsonBasis,All,1],"\n"];
Utils`MakeUnknownInputDefinition@CXXInitializeOutput;
SetAttributes[CXXInitializeOutput,{Protected,Locked}];

CXXChangeOutput::usage =
"@brief Generates c++ code for output value updating inside GenericSum.
@param <{{generic field, restriction}..}> summation list of generic index
restriction rules pares, which, if are true should lead to a skip of summation.
@param expr either single expression or list of expressions to be converted into c++.
@preCXXRules list of rules to be applied at expr.
@param wilsonBasis:{Rule[_,_]...} list of basis for calculation.
@returns String c++ code for output value initializations inside GenericSum.";
CXXChangeOutput[summation:`type`summation,expr_->preCXXRules_,{}] :=
Module[
   {
      newExpr = expr /. getLoopLibraryRules[],cxxExpr,out
   },
   cxxExpr = Parameters`ExpressionToString[Fold[ReplaceAll,newExpr,preCXXRules]];
   cxxExpr = StringReplace[cxxExpr, "\"" -> ""];
   out="value += "<>stringGeneratedCut[cxxExpr<>";",100,",","   "<>"   "];
   CXXBeginSum[summation,preCXXRules]<>"\n"<>"   "<>out<>"\n"<>CXXEndSum[summation.getGenericFields[]]
];
CXXChangeOutput[summation:`type`summation,expr_->preCXXRules_,wilsonBasis:{Rule[_String,_]..}] :=
Module[
   {
      code ="
      // The following definitions are repeated in the GenericSum multiple times.
      @Masses@
      @Couplings@
      @PaVe@

      // Start of summation over generic fields.
      @BeginSum@
         @DefineMasses@
         @DefineCpoulings@
         @DefinePaVe@
         @ChangeOutputValues@
      @EndSum@",
      modifiedExpr = expr,
      masses,preMassCode,codeMass,rulesMass,
      couplings,preCouplingCode,codeCoupling,rulesCoupling,
      paves,prePaVeCode,codePaVe,rulesPaVe,
      cxxExpr,updatingVars
   },
   masses = Tally@Cases[modifiedExpr,x_SARAH`Mass:>x,Infinity,Heads->True];
   {preMassCode,codeMass,rulesMass} = createUniqueDefinitions[masses->preCXXRules,{"double","m"}];
   modifiedExpr = modifiedExpr /. rulesMass;

   couplings = Tally@Cases[modifiedExpr,x:SARAH`Cp[__][___]:>x,Infinity,Heads->True];
   {preCouplingCode,codeCoupling,rulesCoupling} = createUniqueDefinitions[couplings->preCXXRules,{"std::complex<double>","c"}];
   modifiedExpr = modifiedExpr /. rulesCoupling;

   paves = Tally@Cases[modifiedExpr,x:Alternatives[_LoopTools`A0i,_LoopTools`B0i,_LoopTools`C0i,
      _LoopTools`D0i,_LoopTools`E0i,_LoopTools`F0i,_LoopTools`A0,_LoopTools`A00,
      _LoopTools`B0,_LoopTools`B1,_LoopTools`B00,_LoopTools`B11,_LoopTools`B001,
      _LoopTools`B111,_LoopTools`DB0,_LoopTools`DB1,_LoopTools`DB00,_LoopTools`DB11,
      _LoopTools`C0,_LoopTools`D0,_LoopTools`E0,_LoopTools`F0]:>x,Infinity,Heads->True];
   paves = paves /.getLoopLibraryRules[];
   {prePaVeCode,codePaVe,rulesPaVe} = createUniqueDefinitions[paves->preCXXRules,{"std::complex<double>","i"}];
   modifiedExpr = modifiedExpr /. getLoopLibraryRules[] /. rulesPaVe;

   cxxExpr = Parameters`ExpressionToString[Fold[ReplaceAll,#,preCXXRules]]&/@modifiedExpr;
   cxxExpr = StringReplace[#, "\"" -> ""]&/@cxxExpr;
   updatingVars = MapThread[#1<>" += "<>#2<>";"&, {wilsonBasis[[All,1]], cxxExpr}];

   code.replaceTokens[{
      "@Masses@"->preMassCode,
      "@Couplings@"->preCouplingCode,
      "@PaVe@"->prePaVeCode,
      "@BeginSum@"->CXXBeginSum[summation,preCXXRules],
      "@DefineMasses@"->codeMass,
      "@DefineCpoulings@"->codeCoupling,
      "@DefinePaVe@"->codePaVe,
      "@ChangeOutputValues@"->StringRiffle[updatingVars,"\n"],
      "@EndSum@"->CXXEndSum[summation.getGenericFields[]]
   }]
];
Utils`MakeUnknownInputDefinition@CXXChangeOutput;
SetAttributes[CXXChangeOutput,{Protected,Locked}];

createUniqueDefinitions[{}->_,{_String,name_String}] :=
   {
      "// No "<>name<>"# present in this expression.",
      "// Expression "<>name<>"# is not changed because it is absent here.",
      {}
   };
createUniqueDefinitions[expr:{{_,_Integer}..}->preCXXRules_,{type_String,name_String}] :=
Module[{names,namedExpr,code,rules},
   namedExpr = Array[
      {
         name<>ToString@#,
         Parameters`ExpressionToString[Fold[ReplaceAll,expr[[#,1]],preCXXRules]],
         expr[[#,1]],
         expr[[#,2]]
      }&,
      Length@expr
   ];
   names = type<>" "<>StringRiffle[namedExpr[[All,1]],", "]<>";";
   code = StringRiffle[#1<>" = "<>#2<>"; // It is repeated "<>ToString@#4<>" times."&@@@namedExpr,"\n"];
   rules = Rule@@@namedExpr[[All,{3,1}]];
   {names,StringReplace[code,"\""->""],rules}
];
Utils`MakeUnknownInputDefinition@createUniqueDefinitions;

CXXReturnOutput::usage =
"@brief Generates c++ code for output value return inside GenericSum.
@param wilsonBasis:{Rule[_,_]...} list of basis for calculation.
@param ind (def. \"\") string which is responsible for an indent of code.
@returns String c++ code for output value initializations inside GenericSum.";
CXXReturnOutput[{},_String:""] :=
"return value;"
CXXReturnOutput[wilsonBasis:{Rule[_String,_]..},_String:""] :=
"return "<>ToString[ wilsonBasis[[All,1]] ]<>";";
Utils`MakeUnknownInputDefinition@CXXReturnOutput;
SetAttributes[CXXReturnOutput,{Protected,Locked}];

stringGeneratedCut::usage =
"@brief Function for dummy c++ code cut. It cuts string to a maximal possible
ones with length+ind for a given delSymb symbol and then join them.
@param string String String to cut.
@param length Integer Number which approximately corresponds to output width.
@param del String which corresponds to a symbol to delete.
@param ind (def. \"\") string which is responsible for an indent of code.";
stringGeneratedCut[string_String,length_Integer,del_String] :=
Module[
   {
      strs = StringSplit[string, del],
      f,initSet,numbers,dirtyStrings,cleanStrings
   },
   If[Length@strs==1,Return@string];
   f[{n1_Integer,i1_Integer},{n2_Integer,i2_Integer}] /; i1+i2<length :=
      f[{{n1,n2},i1+i2}];
   f[{n1_Integer,i1_Integer},{n2_Integer,i2_Integer}] :=
      f[{{n1},i1},{{n2},i2}];
   f[f[in___List,{{nums__},sum_}],{n2_Integer,i2_Integer}] /; sum+i2<length :=
      f[in,{{nums,n2},sum+i2}];
   f[f[in___List,{{nums__},sum_}],{n2_Integer,i2_Integer}] := 
      f[in,{{nums},sum},{{n2},i2}];
   initSet=Transpose[{Array[#&,Length@strs],StringLength/@strs}];
   numbers = ReplaceAll[First/@Fold[f,First@initSet,Rest@initSet],f->List];
   dirtyStrings = StringJoin[StringRiffle[strs[[#]],del]] &/@ numbers;
   cleanStrings = StringReplace[#, StartOfString~~" "...~~x___:>x] &/@ dirtyStrings;
   StringRiffle[cleanStrings,del<>"\n"]
];
Utils`MakeUnknownInputDefinition@stringGeneratedCut;
SetAttributes[stringGeneratedCut,{Protected,Locked}];

CXXCodeNameKey::usage =
"@brief Generates c++ code for type abbreviations stored in GenericFieldMap
(Associative Sequence) at Key positions.
@param genFields:{..} list of presenting generic fields.
@returns String c++ code for type abbreviations stored in GenericFieldMap
(Associative Sequence) at Key positions.";
CXXCodeNameKey[genFields:{`type`genericField..}] :=
   StringRiffle[Apply[
      StringTemplate["using `1` = typename at<GenericFieldMap,`2`>::type;"],
      {#.getName[cxx],CXXGenFieldKey@#}&/@genFields,
      {1}],"\n"];
Utils`MakeUnknownInputDefinition@CXXCodeNameKey;
SetAttributes[CXXCodeNameKey,{Protected,Locked}];

CXXSubsInGenericSum::usage =
"@brief If the give GenericSum depends on some subexpressions, then generates
code for their initialization.
@param GenericSum[_,_] GenericSum expression.
@param subs List of substitution rules for NPF object.
@returns String c++ code for initialization of subexpressions if they are
present in given GenericSum.";
CXXSubsInGenericSum[sum:`type`genericSum,subs:`type`subexpressions]:=
Module[
   {
      relevantSubs = DeleteDuplicates@Cases[sum.getExpression[],Alternatives@@(subs.getName[]),Infinity]
   },
   If[relevantSubs === {},
      "// This GenericSum does not depend on subexpressions",
      StringRiffle[StringTemplate[
         "`1`<GenericFieldMap> `1`_ { *this, index_map };"]/@relevantSubs,
         "\n"]]
];
Utils`MakeUnknownInputDefinition@CXXSubsInGenericSum;
SetAttributes[CXXSubsInGenericSum,{Protected,Locked}];

CXXBeginSum::usage =
"@brief Generates c++ code for sum beginning used inside GenericSum.
@param <{{generic field, restriction}..}> summation List of generic index
restriction rules pares, which, if are true should lead to a skip of summation.
@returns String c++ code for sum beginning used inside generic sums.";
CXXBeginSum[summation:`type`summation,preCXXRules_]:=
Module[{beginsOfFor},
   beginsOfFor =
      "for( const auto &"<>(#[[1]].getIndex[cxx])<>" : "<>"index_range<"<>(#[[1]].getName[cxx])<>">() ) {\n"<>
      "at_key<"<>CXXGenFieldKey@#[[1]]<>">( index_map ) = "<>(#[[1]].getIndex[cxx])<>";"<>parseRestrictionRule[#,preCXXRules] &/@summation;
   StringRiffle[beginsOfFor,"\n"]
];
Utils`MakeUnknownInputDefinition@CXXBeginSum;
SetAttributes[CXXBeginSum,{Protected,Locked}];

parseRestrictionRule[{genericField:`type`genericField,rule_},{extIndexRules_List,__},str_String:""] :=
Module[{f1,f2,getIndexOfExternalField,OrTwoDifferent},
   (* @note Here ind (in everywhere's notation) is str. *)
   getIndexOfExternalField[_[_[{ind_}]]] := "std::array<int,1> {"<>(ind/.extIndexRules)<>"}";
   getIndexOfExternalField[_[{ind_}]] := "std::array<int,1> {"<>(ind/.extIndexRules)<>"}";
   getIndexOfExternalField[_] := "std::array<int,0> {}";
   
   OrTwoDifferent[] := Module[
      {
         type1 = CXXFieldName@First@rule,
         type2 = CXXFieldName@Last@rule,
         ind = getIndexOfExternalField@First@rule,
         typeGen = genericField.getName[cxx],
         indGen = genericField.getIndex[cxx]
      },
      "\n"<>str<>"if( (boost::core::is_same<"<>typeGen<>","<>type1<>">::value || boost::core::is_same<"<>typeGen<>","<>type2<>">::value) && "<>indGen<>" == "<>ind<>" ) continue;"
   ];
   
   Switch[rule,
      Or[f1_,f2_],OrTwoDifferent[],
      False,"",
      _,"@todo This rule is ununderstandable!";Quit[1]]
];
Utils`MakeUnknownInputDefinition@parseRestrictionRule;

CXXEndSum::usage =
"@brief Generates c++ code for end of sum over generic fields inside GenericSum.
@param genFields:{...} list of presenting generic fields.
@returns String c++ code for end of sum over generic fields inside GenericSum.";
CXXEndSum[genFields:{`type`genericField..}] :=
   StringJoin[
      Array["}"&,Length@genFields],
      " // End of summation over generic fields"];
Utils`MakeUnknownInputDefinition@CXXEndSum;
SetAttributes[CXXEndSum,{Protected,Locked}];

CXXCodeFunCalculate::usage ="@brief Generates c++ code for functions which return result of generic sum
calculation.
@param genSumNames list of strings with names of generic sums.
@param wilsonBasis list of rules for a basis.
@returns String Generates c++ code for functions which return result of generic sum
calculation.";
CXXCodeFunCalculate[genSumNames:{__String},wilsonBasis:{Rule[_String,_]...}] :=
Module[
   {
      varName = "genericsum" (* Feel free to change me to another c++ name *),
      simpleSum,
      varNames,initVars,sumOfSums
   },
   If[wilsonBasis==={},
      simpleSum = StringRiffle[#<>"()"&/@genSumNames,"+"];
      "
      std::complex<double> calculate( void ) {
         return @SumOfSums@;
      } // End of calculate()".replaceTokens[{"@SumOfSums@"->simpleSum}],
      (*Else*)
      varNames = Array[varName<>ToString@#&,Length@genSumNames];(*{String..}*)
      initVars = MapThread["const auto "<>#1<>" = "<>#2<>"();"&,{varNames,genSumNames}]~StringRiffle~"\n   ";
      sumOfSums = StringRiffle[#<>".at(i)"&/@varNames,"+"];
      "
      std::array<std::complex<double>,@BasisLength@> calculate( void ) {
         std::array<std::complex<double>,@BasisLength@> genericSummation;
         constexpr int coeffsLength = genericSummation.size();
         @InitializeVariablesWhichStoreGenericSumsOutput@
         
         for ( std::size_t i=0; i<coeffsLength; i++ ) {
            genericSummation.at(i) += @SumOfVariables@;
         }
         return genericSummation;
      } // End of calculate()".replaceTokens[
      {
         "@BasisLength@"->ToString@Length@wilsonBasis,
         "@InitializeVariablesWhichStoreGenericSumsOutput@"->initVars,
         "@SumOfVariables@"->sumOfSums
      }]
   ]
];
Utils`MakeUnknownInputDefinition@CXXCodeFunCalculate;
SetAttributes[CXXCodeFunCalculate,{Protected,Locked}];

CXXClassInsertions::usage =
"@brief Generates c++ code for class insertions inside GenericSum.
@param genInsertions list of list with SARAH particle names.
@returns String c++ code for class insertions inside GenericSum.";
CXXClassInsertions[genInsertions:`type`classFields] :=
   StringRiffle["boost::mpl::vector<"<>StringRiffle[CXXFieldName@#&/@#,", "]<>">"&/@genInsertions,",\n"];
Utils`MakeUnknownInputDefinition@CXXClassInsertions;
SetAttributes[CXXClassInsertions,{Protected,Locked}];

CXXFactorInsertions::usage =
"@brief Generates c++ code for combinatorical factor insertions inside GenericSum.
@param combinatorialFactors list of integers.
@returns String c++ code for combinatorical factor insertions inside GenericSum.";
CXXFactorInsertions[combinatorialFactors:`type`classCombinatoricalFactors] :=
   StringRiffle["boost::mpl::int_<"<>ToString@#<>">"&/@combinatorialFactors,",\n"];
Utils`MakeUnknownInputDefinition@CXXFactorInsertions;
SetAttributes[CXXFactorInsertions,{Protected,Locked}];

CXXColourInsertions::usage =
"@brief Generates c++ code for colour factor insertions inside GenericSum.
@param colourFactors list of numbers.
@returns String c++ code for colour factor insertions inside GenericSum.";
CXXColourInsertions[colourFactors:{__?NumberQ}] :=
Module[
   {
      ReRatioColourFactors = {Numerator@#,Denominator@#} &/@ Re@colourFactors,
      ImRatioColourFactors = {Numerator@#,Denominator@#} &/@ Im@colourFactors
   },
   StringRiffle[
      StringReplace[
         MapThread[
            "detail::complex_helper<"<>
            "detail::ratio_helper<"<>ToString@#1<>">,"<>
            "detail::ratio_helper<"<>ToString@#2 <> ">>"&,
            {ReRatioColourFactors, ImRatioColourFactors}],
         {"{" -> "", "}" -> ""}],
   ",\n"]
];
Utils`MakeUnknownInputDefinition@CXXColourInsertions;
SetAttributes[CXXColourInsertions,{Protected,Locked}];

CXXFermionMetaLength::usage =
"@brief Generates c++ short name for the length of fermion basis.
@param wilsonBasis list of fermion chains.
@param ind (def. \"\\n\") dummy string.
@returns String c++ short name for the length of fermion basis.";
CXXFermionMetaLength[wilsonBasis:{___},_String:"\n"] :=
If[wilsonBasis==={},"// There is no basis in this GenericSum: skipping ",""]<>
"boost::mpl::int_<"<>ToString@Length@wilsonBasis<>">";
Utils`MakeUnknownInputDefinition@CXXFermionMetaLength;
SetAttributes[CXXFermionMetaLength,{Protected,Locked}];

(*auxiliary functions with names of newer Mathematica versions*)
If[TrueQ[$VersionNumber<10],
StringTemplate::usage=
"This is not a full replacement of Mathematica's StringTemplate.
It works correctly only for string, containing `i` insertions with i>0";
StringTemplate::errFailed=
"Failed for this input string
`1`";
StringTemplate[str_String] :=
Module[
   {
      args = DeleteDuplicates@StringCases[str,
         HoldPattern["`"~~DigitCharacter..~~"`"]],
      noControlStrs = DeleteDuplicates@StringSplit[str,
         "`"~~DigitCharacter~~"`"],
      argRules,noControlRules,preControl,return
   },
   argRules = Rule[#,"<>ToString@#"<>StringDrop[StringDrop[#,1],-1]<>"<>"] &/@
      args;
   noControlRules = Rule[#,"\""<>#<>"\""] &/@ noControlStrs;
   preControl = StringReplace[StringReplace[StringReplace[str,
      argRules], noControlRules],"<><>"->"<>"];
   If[StringTake[str,1] === "`",preControl = StringDrop[preControl,2]];
   If[StringTake[str,-1] === "`",preControl = StringDrop[preControl,-2]];
   return=ToExpression[preControl <> "&"];
   If[return===$Failed,
      Utils`AssertOrQuit[False,StringTemplate::errFailed,str],
      return]
];
StringTemplate[___] :=
   Utils`AssertOrQuit[False,StringTemplate::usage];

SetAttributes[{StringTemplate},{Protected, Locked}]
];
If[TrueQ[$VersionNumber<10.1],
StringRiffle::usage=
"This is not a full replacement of Mathematica's StringRiffle.
It works only for [{___String},_String] input.";
StringRiffle::err="`1`";
StringRiffle[strs:{___String},sep_String] := 
   StringJoin@Riffle[strs,sep];
StringRiffle[strs:{___String},{in_String,sep_String,fin_String}] := 
   in<>StringJoin@Riffle[strs,sep]<>fin;
StringRiffle[x___] :=
   Utils`AssertOrQuit[False,StringRiffle::err,{x}];
   
SetAttributes[{StringRiffle},{Protected, Locked}]
];

deletePrintFromSubkernel::usage =
"@brief Deletes last generated output of subkernel.
@note One cannot share Locked symbols.";
deletePrintFromSubkernel[] := "Redefined later";
If[$Notebooks,
   deletePrintFromSubkernel[] := 
   (
      SelectionMove[SelectedNotebook[],"Print",GeneratedCell,AutoScroll->False]; 
      (*NotebookDelete@Last@SelectedCells@SelectedNotebook[];*)
   ),
   deletePrintFromSubkernel[] :=
   WriteString[OutputStream["stdout", 1],"\033[A\033[K\033[A\033[K\033[A\033[K\033[A"];
];
SetAttributes[deletePrintFromSubkernel,Protected];

SetAttributes[
   {
   NPointFunction,
   GetSARAHModelName,
   LaunchSubkernelFor,
   CacheNameForMeta,CacheNPointFunction,CachedNPointFunction,
   GenerateFAModelFileOnKernel,WriteParticleNamespaceFile,
   FANamesForFields,RemoveEmptyGenSums,
   VerticesForNPointFunction,
   CreateCXXHeaders,
   CreateCXXFunctions,
   getLoopFlexibleSUSYRules,
   CXXArgStringNPF,
   CXXBodyNPF,CXXClassNameNPF,CXXClassForNPF,
   ToCXXPreparationRules,(*,CXXFieldIndices,*)CXXFieldName,
   CXXSubsInSub,CXXGenericFieldsInSub,CXXContextInitialize,
   ExtractColourFactor,CXXGenericSum
   }, 
   {Protected, Locked}];

End[];
$ContextPath = NPointFunctions`internal`contextPath;
Clear[NPointFunctions`internal`contextPath];
EndPackage[];
