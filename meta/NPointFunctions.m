(* :Copyright:

   ====================================================================
   This file is part of FlexibleSUSY.

   FlexibleSUSY is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published
   by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   FlexibleSUSY is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with FlexibleSUSY.  If not, see
   <http://www.gnu.org/licenses/>.
   ====================================================================

*)

(*@assumptions: 
1) there are no quartic gluon vertices inside diagrams => one can calculate
colour factor for diagram separately from Lorentz factor
2) 4-point vertices are not supported *)
(*@todo add function which cleans GenerisSum[0,{}] correctly*)
BeginPackage["NPointFunctions`",
   {
      "FlexibleSUSY`",
      "SARAH`",
      "CXXDiagrams`", (* RemoveLorentzConjugation, *)
      "Vertices`", (* StripFieldIndices *)
      "Parameters`", (* ExpressionToString *)
      "Utils`" (* AssertOrQuit, AssertWithMessage, EvaluateOrQuit *)
   }
];

LoopLevel::usage=
"Option for NPointFunctions`NPointFunction[].
Encodes the loop level at which to calculate amplitudes.

def. 1 | 0";
Regularize::usage=
"Option for NPointFunctions`NPointFunction[].
Encodes the regularization scheme to be used.

DimensionalReduction | DimensionalRegularization";
UseCache::usage=
"Option for NPointFunctions`NPointFunction[].
Cache and reuse the expressions generated by FeynArts/FormCalc.
@note @todo there is no difference between different ExcludedTopologies and
OnShellFlag values

def. True | False";
ZeroExternalMomenta::usage=
"Option for NPointFunctions`NPointFunction[].
Encodes whether to set the external momenta to zero or leave them undetermined.

def. True | False";
OnShellFlag::usage=
"Option for NPointFunctions`NPointFunction[].
Use on-shell external fields or not.

def. True | False";
ExcludedTopologies::usage=
"Option for NPointFunctions`NPointFunction[].
Exclude specific topologies in FeynArts.

def. {} |Any sublist of {OneParticleReducible,ExceptBoxes,ExceptTriangles}";

DimensionalReduction::usage=
"Possible value for the Regularize option

(Technically, a wrapper for FlexibleSUSY`.`DRbar)";
DimensionalRegularization::usage=
"Possible value for the Regularize option

(Technically, a wrapper for FlexibleSUSY`.`MSbar)";

OneParticleReducible::usage=
"Possible value for ExcludedTopologies.
No tree-level-type propagators, i.e. if the topology is one-particle 
irreducible.

(Technically, a wrapper for a case when the initialization of FeynArts`.` is 
not needed. Internally converts further to FeynArts`.`Irreducible.)";
ExceptBoxes::usage=
"Possible value for ExcludedTopologies. 
Exclude all topologies except box diagrams

(Technically, a wrapper for a case when the initialization of FeynArts`.` is 
not needed. Internally converts further to FeynArts`.`Loops@Except@3.)";
ExceptTriangles::usage=
"Possible value for ExcludedTopologies. 
Exclude all topologies except triangle diagrams

(Technically, a wrapper for a case when the initialization of FeynArts`.` is 
not needed. Internally converts further to FeynArts`.`Loops@Except@4.)";

GenericS::usage=
"A symbol that acts as a placeholder for any scalar field.";
GenericF::usage=
"A symbol that acts as a placeholder for any fermion field.";
GenericV::usage=
"A symbol that acts as a placeholder for any vector field.";
GenericU::usage=
"A symbol that acts as a placeholder for any ghost field.";
GenericT::usage=
"A symbol that acts as a placeholder for any tensor field.";

GenericSum::usage=
"Represent a sum over a set of generic fields.";
GenericIndex::usage=
"Represent an index of a generic field.";
LorentzIndex::usage=
"Represent a Lorentz index of a generic field.";

VerticesForNPointFunction::usage=
"@brief Return a list of all vertices needed to calculate a given 
n-point correlation function.
@param nPointFunction the given n-point correlation function
@returns a list of all vertices needed to calculate a given 
n-point correlation function.temp";
VerticesForNPointFunction::errUnknownInput=
"Correct input has to be generated by NPointFunction[].";

LoopFunctions::usage=
"Option for NPointFunctions`CreateCXXHeaders[] and 
NPointFunctions`CreateCXXFunctions[]
Controls whether to use FlexibleSUSY or LoopTools for loop functions.

def. \"LoopTools\" | \"FlexibleSUSY\"";
UseWilsonCoeffs::usage=
"Option for NPointFunctions`CreateCXXHeaders[].
Controls whether to use Wilson module or not

def. False | True";

FermionBasis::usage=
"Option for NPointFunctions`CreateCXXFunctions[].
Specify the fermion basis used for the matching.

@note should contain strings with names of fermion chains

def. {} | @todo";

(*functions*)
{NPointFunction,CreateCXXHeaders,CreateCXXFunctions};
SetAttributes[
   {
   LoopLevel,Regularize,UseCache,ZeroExternalMomenta,OnShellFlag,
   ExcludedTopologies,
   DimensionalReduction,DimensionalRegularization,
   OneParticleReducible,ExceptBoxes,ExceptTriangles,
   GenericS,GenericF,GenericV,GenericU,GenericT,                                (* @unote also exist in internal.m*)
   GenericSum,GenericIndex,LorentzIndex,                                        (* @unote also exist in internal.m*)
   LoopFunctions,UseWilsonCoeffs,FermionBasis
   }, 
   {Protected, Locked}];

Begin["`Private`"];

Options[NPFPattern] = {
   "Fields" -> _,
   "Sums" -> _,
   "ClFields" -> _,
   "CombFac" -> _,
   "ColFac" -> _,
   "Subs" -> _};
NPFPattern::usage =
Module[{Formatted},
   Formatted[num_Integer]:=
      StringJoin["\"",Part[#,1],"\" (def. ",ToString@Part[#,2],") "]&@
      Part[Options@NPFPattern,num];
   "@brief Is used to realize pattern check for NPointFunction object in
   other functions. Provides a nice way to pick required part of this object.
   Designed in a way which allows Mathematica to highlight the code correctly.
   @option "<>Formatted@1<>"allows to pick in and out fields
   @option "<>Formatted@2<>"allows to pick GenericSums
   @option "<>Formatted@3<>"allows to pick list of class replacements
   @option "<>Formatted@4<>"allows to pick list of class combinatorical factors
   @option "<>Formatted@5<>"allows to pick list of class colour factors
   @option "<>Formatted@6<>"allows to pick abbreviations
   @note any option should have form symbolName_ or Blank[]
   @returns Pattern where option specify the stuff to pick in this calculation."
];
NPFPattern::errUnknownOptions = 
"Unknown option(s):
`1`.

Currently supported options are:
`2`.";
NPFPattern::errWrongOptionValue =
"Any option should have form symbolName_ or Blank[] and not
`1`";
NPFPattern::errUnknownInput = 
"Correct input has the folliwing form:
NPFPattern[options] where options have names from list
`1`.";
NPFPattern[opts:OptionsPattern[]] :=
Module[{names=Part[Options@NPFPattern,All,1],Convert},
   Convert[num_] := If[OptionValue@Part[names,num] === _,
      "",
      StringDrop[ToString@OptionValue@Part[names,num],-1] <> ":"];
   ToExpression[StringJoin[
   "{",
      Convert@1 , "{{__},{__}},",
      "{",
         "{",
            Convert@2 , "{GenericSum[_,{__}]..}," ,
            Convert@3,"{{{__}..}..}," ,
            Convert@4 , "{{__Integer}..}," ,
            Convert@5 , "{{__}..}" ,
         "}," ,
         Convert@6 , "{Rule[_,_]...}" ,
      "}" ,
   "}"]]
] /; 
Module[
   {
      optionNames=Options[NPFPattern][[All,1]],
      unknownOptions,
      currentOptionValues,
      ConvertValue,CheckValue
   },
   unknownOptions = FilterRules[{opts},Except@optionNames];
   Utils`AssertOrQuit[unknownOptions === {},NPFPattern::errUnknownOptions,
      unknownOptions,"\""<>#<>"\""&/@optionNames];
   currentOptionValues = OptionValue[NPFPattern,#]&/@optionNames;
   ConvertValue = StringCases[ToString@#,x___~~"_"~~EndOfString:>x]&;
   CheckValue[{str_String}] := Symbol===Head@ToExpression@str;
   CheckValue[___] := False;
   Utils`AssertOrQuit[
      CheckValue@ConvertValue@#,
      NPFPattern::errWrongOptionValue,#]&/@currentOptionValues;
   True
];
NPFPattern[___] := 
Utils`AssertOrQuit[
   False,
   NPFPattern::errUnknownInput,
   "\""<>#<>"\""&/@Part[Options@NPFPattern,All,1]
];

Options[NPointFunction]={
   LoopLevel -> 1,
   Regularize -> Switch[FlexibleSUSY`FSRenormalizationScheme,
      FlexibleSUSY`DRbar, DimensionalReduction,
      FlexibleSUSY`MSbar, DimensionalRegularization],
   UseCache -> True,
   ZeroExternalMomenta -> True,
   OnShellFlag -> True,
   ExcludedTopologies -> {}
};
NPointFunction::usage=
"@brief Calculate the n-point correlation function for a List of incoming and 
a List of outgoing fields.
@param inFields a List of incoming fields
@param outFields a List of outgoing fields
@param LoopLevel the loop level at which to perform the calculation
@param Regularize the regularization scheme to apply
@param UseCache whether to attempt to read and write the result from and to 
the cache.
@param ZeroExternalMomenta whether to set the external momenta to zero or leave 
them undetermined.
@param ExcludedTopologies a list or single symbol of topologies to exclude when 
calculation the n-point correlation function
@returns the corresponding n-point correlation function
@note only a loop level of 1 is currently supported
@note the recognized regularization schemes are:
 - DimensionalReduction
 - DimensionalRegularization
@note when not setting the external momenta to zero one should use LoopTools 
for the evaluation of the loop functions.";
NPointFunction::errinFields=
"The element '`1`' of inFields is an incorrect one.

inFields should contain only names from the list of `2` particles
`3`.
@unote now only restricted set is supported";
NPointFunction::erroutFields=
"The element '`1`' of outFields is an incorrect one.

outFields should contain only names from the list of `2` particles
`3`.
@unote now only restricted set is supported";
NPointFunction::errLoopLevel=
"Incorrect number of loops.

Only loop level 1 is supported";
NPointFunction::errRegularize=
"Unknown regularization scheme `1`.

Currently DimensionalReduction, DimensionalRegularization are supported.";
NPointFunction::errUseCache=
"UseCache must be either True or False.";
NPointFunction::errZeroExternalMomenta=
"ZeroExternalMomenta must be either True or False";
NPointFunction::errOnShellFlag=
"OnShellFlag must be either True or False.";
NPointFunction::errExcludedTopologies=
"ExcludedTopologies must be sublist of 
{OneParticleReducible,ExceptBoxes,ExceptTriangles}.";
NPointFunction::errInputFields=                                                 (* @utodo modify it for usage of bosons also *)
"Only external scalars/fermions are supported (@todo FOR NOW).";
NPointFunction::errCalc=
"FeynArts+FormCalc calculations failed";
NPointFunction::errUnknownOptions=
   NPFPattern::errUnknownOptions;
NPointFunction::errUnknownInput=
"Correct input has the folliwing form:
NPointFunction[inFields,outFields,options]
where
 inFields and outFields are lists containing names of `1` particles 
  `2`,
 options have names from list 
  `3`.";
NPointFunction[inFields_,outFields_,opts:OptionsPattern[]] :=
Module[
   {
      loopLevel = OptionValue[LoopLevel],
      regularizationScheme = OptionValue[Regularize],
      zeroExternalMomenta = OptionValue[ZeroExternalMomenta],
      excludedTopologies = OptionValue[ExcludedTopologies],                     (*@todo is not checked yet!*)
      onShellFlag = OptionValue[OnShellFlag],
      outputDir = FileNameJoin@{
         SARAH`$sarahCurrentOutputMainDir,
         ToString@FlexibleSUSY`FSEigenstates
         },
      nPointFunctionsDir,feynArtsDir,feynArtsModel,particleNamesFile,
      particleNamespaceFile,substitutionsFile,formCalcDir,
      subKernel,
      fsMetaDir = FlexibleSUSY`$flexiblesusyMetaDir,
      currentPath, currentDirectory,
      inFANames,outFANames,
      nPointFunction
   },
   nPointFunctionsDir = FileNameJoin@{outputDir, "NPointFunctions"};            (* @unote cache saving *)
   If[!DirectoryQ@nPointFunctionsDir,CreateDirectory@nPointFunctionsDir];
   If[OptionValue@UseCache,
      nPointFunction = CachedNPointFunction[
         inFields,outFields,nPointFunctionsDir,Options@NPointFunction];
      If[nPointFunction =!= Null, Return@nPointFunction]];
   
   feynArtsDir = FileNameJoin@{outputDir, "FeynArts"};
   feynArtsModel = FileNameJoin@{feynArtsDir, GetFAClassesModelName[]};
   particleNamesFile = FileNameJoin@{feynArtsDir, GetFAParticleNamesFileName[]};
   particleNamespaceFile = FileNameJoin@{feynArtsDir, "ParticleNamespaces.m"};
   substitutionsFile = FileNameJoin@{feynArtsDir, GetFASubstitutionsFileName[]};

   formCalcDir = FileNameJoin@{outputDir, "FormCalc"};

   If[!FileExistsQ[feynArtsModel <> ".mod"],
      subKernel = LaunchSubkernelFor@"creation of FeynArts model file";
      GenerateFAModelFileOnKernel@subKernel;                                    (*generates .dat .mod .m files insiide FeynArts directory*)
      WriteParticleNamespaceFile@particleNamespaceFile;
      CloseKernels@subKernel;
   ];
   
   subKernel = LaunchSubkernelFor@"FormCalc code generation";
   
   inFANames = FANamesForFields[inFields, particleNamesFile];
   outFANames = FANamesForFields[outFields, particleNamesFile];

   currentPath = $Path;
   currentDirectory = Directory[];

   DistributeDefinitions[currentPath, currentDirectory,
      fsMetaDir, feynArtsDir, formCalcDir, feynArtsModel,
      particleNamesFile, substitutionsFile, particleNamespaceFile,
      inFANames, outFANames, loopLevel, regularizationScheme,
      zeroExternalMomenta, excludedTopologies, onShellFlag];

   nPointFunction = RemoveEmptyGenSums@ParallelEvaluate[
      $Path = currentPath;
      SetDirectory@currentDirectory;

      Get@FileNameJoin@{fsMetaDir, "NPointFunctions", "internal.m"};
      
      NPointFunctions`SetFAFCPaths[feynArtsDir, formCalcDir, feynArtsModel,
         particleNamesFile, substitutionsFile, particleNamespaceFile];

      NPointFunctions`NPointFunctionFAFC[
         ToExpression@inFANames, ToExpression@outFANames,
         LoopLevel -> loopLevel,
         Regularize -> regularizationScheme,
         ZeroExternalMomenta -> zeroExternalMomenta,
         ExcludedTopologies -> excludedTopologies,
         OnShellFlag -> onShellFlag],
      subKernel
   ];
   CloseKernels@subKernel;

   Utils`AssertWithMessage[nPointFunction =!= $Failed,
      NPointFunction::errCalc];

   If[OptionValue@UseCache,CacheNPointFunction[
      nPointFunction,nPointFunctionsDir,Options@NPointFunction]];

   nPointFunction
] /; And[
   MatchQ[inFields,
   {__?(Utils`AssertOrQuit[
         TreeMasses`IsParticle@#,
         NPointFunction::errinFields,
         #,
         GetSARAHModelName[],
         Cases[TreeMasses`GetParticles[], 
            _?TreeMasses`IsScalar|_?TreeMasses`IsFermion]                       (*@todo add |_?TreeMasses`IsVector*)
      ]&)}
   ],
   MatchQ[outFields,
   {__?( Utils`AssertOrQuit[
         TreeMasses`IsParticle@#,
         NPointFunction::erroutFields,
         #,
         GetSARAHModelName[],
         Cases[TreeMasses`GetParticles[], 
            _?TreeMasses`IsScalar|_?TreeMasses`IsFermion]                       (*@todo add |_?TreeMasses`IsVector*)
      ]&)}
   ],
   Utils`AssertOrQuit[
      FilterRules[{opts},Except@Part[Options@NPointFunction,All,1]] === {},
      NPointFunction::errUnknownOptions,
      FilterRules[{opts},Except@Part[Options@NPointFunction,All,1]],
      Part[Options@NPointFunction,All,1]
   ],
   Utils`AssertOrQuit[
      OptionValue@LoopLevel === 1,
      NPointFunction::errLoopLevel
   ],
   Utils`AssertOrQuit[
      MemberQ[{DimensionalReduction, DimensionalRegularization}, 
         OptionValue@Regularize],
      NPointFunction::errRegularize,
      OptionValue@Regularize
   ],
   Utils`AssertOrQuit[
      OptionValue@UseCache === True ||
      OptionValue@UseCache === False,
      NPointFunction::errUseCache
   ],
   Utils`AssertOrQuit[
      OptionValue@ZeroExternalMomenta === True ||
      OptionValue@ZeroExternalMomenta === False,
      NPointFunction::errZeroExternalMomenta
   ],
   Utils`AssertOrQuit[
      OptionValue@OnShellFlag === True ||
      OptionValue@OnShellFlag === False,
      NPointFunction::errOnShellFlag
   ],
   Utils`AssertOrQuit[
      And@@Map[
         MemberQ[{OneParticleReducible,ExceptBoxes,ExceptTriangles,Null},#]&,
         If[Head@#===List,#,{#}]&@OptionValue@ExcludedTopologies
      ],
      NPointFunction::errExcludedTopologies
   ],
   Utils`AssertOrQuit[                                                       (* @todo modify this in future*)
      And @@ (TreeMasses`IsScalar@# || TreeMasses`IsFermion@# &/@               (**)
      Join[inFields,outFields] ),                                               (**)
      NPointFunction::errInputFields                                            (**)
   ]                                                                            (**)
];
NPointFunction[___] :=
Utils`AssertOrQuit[
   False,
   NPointFunction::errUnknownInput,
   GetSARAHModelName[],
   Cases[TreeMasses`GetParticles[], 
      _?TreeMasses`IsScalar|_?TreeMasses`IsFermion],                            (*@todo add |_?TreeMasses`IsVector*)
   Options[NPointFunction][[All, 1]]
];

VerticesForNPointFunction[obj:NPFPattern[
   "Sums"->genSums_,"Subs"->substitutions_]
] :=
Module[
   {
      classRules = GetClassRules@obj, 
      positionsSubsWithVert =
         DeleteDuplicates[#[[1]] &/@ Position[substitutions, SARAH`Cp[__]]], 
      rulesWithVertices,vertsGen,GetVertex,
      StripIndices = Vertices`StripFieldIndices
   },
   rulesWithVertices = substitutions[[positionsSubsWithVert]];
   GetVertex[vertGen_,rules_] := vertGen/.#&/@rules;
   vertsGen = DeleteDuplicates@Cases[#, SARAH`Cp[fields__] :> {fields},
      Infinity,Heads -> True] &/@ (genSums/.rulesWithVertices);
   DeleteDuplicates[StripIndices/@#&/@Flatten[MapThread[GetVertex,{vertsGen,classRules}],2]]
];
VerticesForNPointFunction[___] :=
Utils`AssertOrQuit[False,VerticesForNPointFunction::errUnknownInput];

GetClassRules::usage=
"@brief Gives GenericField->SARAHField rules for given NPF object.
@param NPF object.
@returns List of GenericField->SARAHField rules for given NPF object";
GetClassRules::errUnknownInput=
"Input should be NPF object and not
`1`.";
GetClassRules[NPFPattern["Sums"->genSums_,"ClFields"->classFields_]] :=
MapThread[Function[r,MapThread[Rule,{#1,r}]]/@#2&,{Last/@genSums,classFields}];
GetClassRules[args___] :=
Utils`AssertOrQuit[False,GetClassRules::errUnknownInput,{args}];

GetSARAHModelName::usage=
"@brief Return the SARAH model name as to be passed to SARAH`.`Start[].
@returns the SARAH model name as to be passed to SARAH`.`Start[].";
GetSARAHModelName[] := 
If[SARAH`submodeldir =!= False,
      SARAH`modelDir <> "-" <> SARAH`submodeldir,
      SARAH`modelDir
];

GetFAClassesModelName::usage=
"@brief Return the model name that is used by SARAH to name the
FeynArts model file it creates.
@returns the model name that is used by SARAH to name the
FeynArts model file it creates.";
GetFAClassesModelName[] := 
   SARAH`ModelName <> ToString@FlexibleSUSY`FSEigenstates;

GetFAParticleNamesFileName::usage=
"@brief Return the file name that is used by SARAH to store 
FeynArts particle names.
@returns the file name that is used by SARAH to store 
FeynArts particle names.";
GetFAParticleNamesFileName[] := 
"ParticleNamesFeynArts.dat";

GetFASubstitutionsFileName::usage=
"@brief Return the model name that is used by SARAH to name the FeynArts 
substitution file it creates.
@returns the model name that is used by SARAH to name the
FeynArts substitution file it creates.";
GetFASubstitutionsFileName[] :=
   StringJoin["Substitutions-",SARAH`ModelName,
     ToString@FlexibleSUSY`FSEigenstates,".m"
   ];
   
LaunchSubkernelFor::usage=
"@brief Tries to launch a subkernel without errors.
If it fails, tries to explain the reason using message for specifying its
activity.
@param message String, which contains description of activity for which this
subkernel is launched for.
@returns subkernel name.
@note Mathematica 7 returns KernelObject[__], 11.3 returns {KernelObject[__]}
@note for Mathematica 7 some functions have the same names as in SARAH`.`";
LaunchSubkernelFor::errKernelLaunch=
"Unable to launch subkernel(s) during calculations for
`1`
because of error:";
LaunchSubkernelFor[message_String] /; $VersionNumber===7.0 :=
Module[{kernelName},
   Off[Parallel`Preferences`add::shdw,
      Parallel`Preferences`set::shdw,
      Parallel`Preferences`list::shdw,
      Parallel`Preferences`tr::shdw,
      Parallel`Protected`processes::shdw,
      SubKernels`Description::shdw];
   kernelName = Utils`EvaluateOrQuit[
      LaunchKernels[1],
      LaunchSubkernelFor::errKernelLaunch, message];
   On[Parallel`Preferences`add::shdw,
      Parallel`Preferences`set::shdw,
      Parallel`Preferences`list::shdw,
      Parallel`Preferences`tr::shdw,
      Parallel`Protected`processes::shdw,
      SubKernels`Description::shdw];
   kernelName
];
LaunchSubkernelFor[message_String] :=
Module[{kernelName},
   kernelName = Utils`EvaluateOrQuit[
      LaunchKernels[1],
      LaunchSubkernelFor::errKernelLaunch, message];
   If[Head@kernelName === List, kernelName[[1]], kernelName]
];

CacheNameForMeta::usage=
"@brief Return the name of the cache file for given meta information
@param nPointMeta the given meta information
@returns the name of the cache file for given meta information.
";
CacheNameForMeta[nPointMeta:{__Rule}] :=
   StringJoin["cache_",Riffle[ToString/@Flatten[Last/@nPointMeta], "_"],".m"]; 

CacheNPointFunction::usage=
"@brief Write a given n-point correlation function to the cache
@param nPointFunction the given n-point correlation function
@param cacheDir the directory to save cache
@param nPointMeta the meta information about the given n-point correlation 
function";
CacheNPointFunction[nPointFunction_,cacheDir_,nPointMeta:{__Rule}] := 
Module[
   {
      nPointFunctionsFile = FileNameJoin@{cacheDir,CacheNameForMeta@nPointMeta},
      fileHandle,
      nPointFunctions,
      position
   },
   If[FileExistsQ@nPointFunctionsFile,
      nPointFunctions = Get@nPointFunctionsFile,
      nPointFunctions = {}
   ];
   
   position = Position[nPointFunctions[[All,1]],nPointFunction[[1]]];
   If[Length@position === 1,
      nPointFunctions[[position[[1]]]] = nPointFunction,
      AppendTo[nPointFunctions, nPointFunction]
   ];

   fileHandle = OpenWrite@nPointFunctionsFile;
   Write[fileHandle,nPointFunctions];
   Close@fileHandle;
];

CachedNPointFunction::usage=
"@brief Retrieve an n-point correlation function from the cache
@param inFields the incoming fields of the n-point correlation function
@param outFields the outgoing fields of the n-point correlation function
@param cacheDir the directory to save cache
@param nPointMeta the meta information of the n-point correlation function
@returns the corresponding n-point correalation function from the
cache or `Null` if such a function could not be found.
";
CachedNPointFunction[inFields_,outFields_,cacheDir_,nPointMeta:{__Rule}] := 
Module[
   {
      nPointFunctionsFile = FileNameJoin@{cacheDir,CacheNameForMeta@nPointMeta}, 
      nPointFunctions, 
      position
   },
   If[!FileExistsQ@nPointFunctionsFile,Return@Null];
   nPointFunctions = Get@nPointFunctionsFile;
   position = Position[Vertices`StripFieldIndices[ nPointFunctions[[All,1]] ],
      {inFields, outFields}];
   If[Length@position == 1,nPointFunctions[[ position[[1,1]] ]],Null]
];

GenerateFAModelFileOnKernel::usage=
"@brief Generate the FeynArts model file on a given subkernel.";
GenerateFAModelFileOnKernel[kernel_Parallel`Kernels`kernel] :=
Module[
   {
      currentPath = $Path, 
      currentDir = Directory[],
      fsMetaDir = $flexiblesusyMetaDir,
      sarahInputDirs = SARAH`SARAH@SARAH`InputDirectories,
      sarahOutputDir = SARAH`SARAH@SARAH`OutputDirectory,
      SARAHModelName = GetSARAHModelName[], 
      eigenstates = FlexibleSUSY`FSEigenstates
   },
   DistributeDefinitions[currentPath, currentDir, fsMetaDir, sarahInputDirs, 
      sarahOutputDir, SARAHModelName, eigenstates];
      
   ParallelEvaluate[
      $Path = currentPath;
      SetDirectory@currentDir;
      Get@FileNameJoin@{fsMetaDir, "NPointFunctions", "createFAModelFile.m"};
      NPointFunctions`CreateFAModelFile[sarahInputDirs,sarahOutputDir,
         SARAHModelName, eigenstates];,
      kernel];
]

WriteParticleNamespaceFile::usage=
"@brief Write a file containing all field names and the contexts in which they 
live in Mathematica.
@note This is necessary because SARAH puts fields into different contexts.";
WriteParticleNamespaceFile[fileName_String] :=
Module[{fileHandle = OpenWrite@fileName},
   Write[fileHandle, {ToString@#, Context@#} & /@ TreeMasses`GetParticles[]];
   Close@fileHandle;
];

FANamesForFields::usage=
"@brief Translate SARAH-style fields to FeynArts-style fields
@param fields List of SARAH-style fields
@param particleNamesFile the path to the SARAH-created FeynArts
particle names file.
@returns A list of the FeynArts names (as strings) for the given
SARAH-style fields.";
FANamesForFields::errSARAH=
"NpointFunctions`.`Private`.`FANamesForFields[]: SARAH`.`:
It seems that SARAH`.` has changed conventions for
<ParticleNames>.dat file.";
FANamesForFields[fields_,particleNamesFile_String] :=
Module[
   {
      uniqueFields = DeleteDuplicates[
         CXXDiagrams`RemoveLorentzConjugation@# &/@ fields],
      faFieldNames
   },
   faFieldNames = 
   Flatten[
      StringCases[Utils`ReadLinesInFile@particleNamesFile, 
         ToString@# ~~ ": " ~~ x__ ~~ "]" ~~ ___ :> "FeynArts`" <> x <> "]"
      ] & /@ uniqueFields
   ];
   Utils`AssertWithMessage[Length@faFieldNames > 0, 
      FANamesForFields::errSARAH];
      
   fields /. MapThread[Rule, {uniqueFields, faFieldNames}] /. 
      {
         SARAH`bar@field_String :> "-" <> field, 
         Susyno`LieGroups`conj@field_String :> "-" <> field
      }
]

RemoveEmptyGenSums::usage=
"@brief Sometimes after FA+FC calculation some generic sums are empty. This
means that one can simply remove them (as well as corresponding
colour/combinatoric factors and field substitution rules). This work is done by
this function.
@param npfObject NPF object to clean.
@returns cleaned from empty GenericSums npfObject.";
RemoveEmptyGenSums::errUnknownInput=
"Input should be NPF object.";
RemoveEmptyGenSums[npfObject:NPFPattern[]]:=npfObject;
RemoveEmptyGenSums[
   {fields:{{__},{__}},
      {
         {
            sums:{GenericSum[_,{___}]..},
            rules:{{{__}..}..},
            comb:{{__Integer}..},
            col:{{__}..}
         },
         subs:{Rule[_,_]...}
      }
   }]:=
Module[{poss=Position[sums,GenericSum[0,{}]]},
   Print["Removing zero GenericSum at positions ",
      StringRiffle[ToString/@Flatten@poss,", "],"."];
   {fields,{Delete[#,poss]&/@{sums,rules,comb,col},subs}}
];
RemoveEmptyGenSums[___]:=
Utils`AssertOrQuit[False,RemoveEmptyGenSums::errUnknownInput];

Options[CreateCXXHeaders]={
   LoopFunctions -> "FlexibleSUSY",
   UseWilsonCoeffs -> False
};
CreateCXXHeaders::usage=
"@brief Create the c++ code for the necessary headers for evaluation of n-point
correlation functions.
@param LoopFunctions the loop function library to be used
@returns the c++ code for the necessary headers for evaluation
of n-point correlation functions.";
CreateCXXHeaders::errUnknownOptions=
   NPointFunction::errUnknownOptions;
CreateCXXHeaders::errLoopFunctions=
"Unsupported loop functions library `1`.

Currently \"LoopTools\", \"FlexibleSUSY\" are supported.";
CreateCXXHeaders::errUseWilsonCoeffs=
"UseWilsonCoeffs must be either True or False.";
CreateCXXHeaders::errUnknownInput=
"Correct input has the folliwing form:
NPointFunction[options]
where
 options have names from list 
  `1`.";
CreateCXXHeaders[opts:OptionsPattern[]] :=
Module[
   {
      mainHPP = "\"cxx_qft/" <> FlexibleSUSY`FSModelName <>
         If[OptionValue@UseWilsonCoeffs,
            "_npointfunctions_wilsoncoeffs.hpp\"",
            "_npointfunctions.hpp\""],
      loopHPP = Switch[OptionValue@LoopFunctions,
         "LoopTools","<clooptools.h>",
         "FlexibleSUSY","\"numerics.h\""]
   },
   "#include " <> mainHPP <> "\n" <>
   "#include \"concatenate.hpp\"\n" <>
   "#include <boost/fusion/include/at_key.hpp>" <> "\n" <>
   "#include " <> loopHPP
] /; And[
   Utils`AssertOrQuit[
      FilterRules[{opts},Except@Part[Options@CreateCXXHeaders,All,1]] === {},
      CreateCXXHeaders::errUnknownOptions,
      FilterRules[{opts},Except@Part[Options@CreateCXXHeaders,All,1]],
      Part[Options@CreateCXXHeaders,All,1]
   ],
   Utils`AssertOrQuit[
      MemberQ[{"LoopTools", "FlexibleSUSY"}, OptionValue@LoopFunctions],
      CreateCXXHeaders::errLoopFunctions,
      OptionValue@LoopFunctions
   ],
   Utils`AssertOrQuit[
      OptionValue@UseWilsonCoeffs === True ||
      OptionValue@UseWilsonCoeffs === False,
      CreateCXXHeaders::errUseWilsonCoeffs
   ]
];
CreateCXXHeaders[___] := 
Utils`AssertOrQuit[False,CreateCXXHeaders::errUnknownInput,
   Options[CreateCXXHeaders][[All, 1]]];

Options[CreateCXXFunctions]={
   LoopFunctions -> "FlexibleSUSY",
   FermionBasis -> {}
};
CreateCXXFunctions::usage=
"@brief Given a list of n-point correllation functions, a list
of c++ function names and a list of colour factor projections
create the c++ code for the numerical evaluation of the
n-point correllation functions.
@param nPointFunctions the list of n-point correlation functions
@param names the list of function names
@param colourProjectors a list or a singleton of colour factor
projections that shall be applied to the general expressions for the
colour factors in the corresponding n-point correllation function.
The result of applying such a projection must be a scalar. e.g
``exampleProjection[scalar_*SARAH`Delta[colourIndex1_, colourIndex2_]] 
:> scalar``
@param LoopFunctions the loop function library to be used.
@note Currently, only FlexibleSUSY and LoopTools are supported as
loop function libraries.
@returns a list of the form `{prototypes, definitions}` containing
the corresponding c++ code.
";
CreateCXXFunctions::errnPointFunctions=
"The element '`1`' of nPointFunctions is an incorrect one.

nPointFunctions should contain only NPointFunction objects
@note GenericSum should have non-zero first argument";
CreateCXXFunctions::errnames=
"The element '`1`' of errnames is an incorrect one.

names should contain only strings for c++ function names";
CreateCXXFunctions::errUnequalLength=
"Lengths of nPointFunctions, names and colourProjectors (if the last is a list)
should be the same.";
CreateCXXFunctions::errUnknownOptions=
   NPointFunction::errUnknownOptions;
CreateCXXFunctions::errLoopFunctions=
   CreateCXXHeaders::errLoopFunctions;
(*@todo check for FermionBasis*)
CreateCXXFunctions::errUnknownInput=
"Correct input has the folliwing form:
@todo
where
 options have names from list 
  `1`.";
CreateCXXFunctions[
   nPointFunctions_,
   names_,
   colourProjectors_,
   opts:OptionsPattern[]
] :=
Module[
   {
      loopFunctionRules = Switch[OptionValue@LoopFunctions,
         "LoopTools", {},
         "FlexibleSUSY", GetLTToFSRules[]],
      prototypes,
      definitionHeads,
      definitionBodies,
      auxilliaryClasses,
      definitions,
      noFermionChains = TrueQ[Length@OptionValue@FermionBasis === 0],
      basisLengths = Table[Length@OptionValue@FermionBasis,{Length@names}],
      colourProjectorList = If[Head@colourProjectors === List,colourProjectors,
         Table[colourProjectors,{Length@names}]]
   },
   prototypes = StringRiffle[MapThread[
      StringTemplate@"std::complex<double> `1`(`2`);",
      {names,CXXArgStringNPF[#,"def"]&/@nPointFunctions}],"\n"];

   definitionHeads = MapThread[If[noFermionChains,
      StringTemplate@"std::complex<double> `2`(`3`)",
      StringTemplate@"std::array<std::complex<double>,`1`> `2`(`3`)"],
      {basisLengths,names,CXXArgStringNPF/@nPointFunctions}];

   definitionBodies = CXXBodyNPF/@nPointFunctions;

   auxilliaryClasses = MapThread[CXXClassForNPF[##,OptionValue@FermionBasis]&,
      {nPointFunctions/.loopFunctionRules,colourProjectorList}];

   definitions =
      StringRiffle[auxilliaryClasses,"\n\n"] <> "\n\n" <>
      StringRiffle[MapThread[StringTemplate["`1`\n{\n`2`\n}"],
         {definitionHeads, definitionBodies}],"\n\n"];
   {prototypes, definitions}
] /; And[
   MatchQ[nPointFunctions,
      {__?(Utils`AssertOrQuit[
         MatchQ[#,NPFPattern[]],
         CreateCXXFunctions::errnPointFunctions,
         #]&)
      }],
   MatchQ[names,
      {__?(Utils`AssertOrQuit[
         StringQ@#,
         CreateCXXFunctions::errnames,
         #]&)
      }],
   Utils`AssertOrQuit[
      Length@nPointFunctions===Length@names,
      CreateCXXFunctions::errUnequalLength],
   If[Head@colourProjectors===List,
      Utils`AssertOrQuit[
         Length@colourProjectors===Length@names,
         CreateCXXFunctions::errUnequalLength],
      True],
   (*@todo check for colourProjectors*)
   Utils`AssertOrQuit[
      FilterRules[{opts},Except@Part[Options@CreateCXXFunctions,All,1]] === {},
      CreateCXXFunctions::errUnknownOptions,
      FilterRules[{opts},Except@Part[Options@CreateCXXFunctions,All,1]],
      Part[Options@CreateCXXFunctions,All,1]],
   Utils`AssertOrQuit[
      MemberQ[{"LoopTools", "FlexibleSUSY"}, OptionValue@LoopFunctions],
      CreateCXXFunctions::errLoopFunctions,
      OptionValue@LoopFunctions]
   (*@todo check for FermionBasis*)
];
CreateCXXFunctions[___] := 
Utils`AssertOrQuit[False,CreateCXXFunctions::errUnknownInput,
   Part[Options@CreateCXXFunctions,All,1]];

GetLTToFSRules::usage=
"@brief returns rules for LoopTools to FlexibleSUSY conventions.
@returns rules for LoopTools to FlexibleSUSY conventions.
@todo add specific rules for std::sqrt(0)
@todo add specific rules for std::sqrt(Sqr())";
GetLTToFSRules::errUnknownInput=
"Input should have no parameters.";
GetLTToFSRules[] :=
Module[{warning="\033[1;33mWarning\033[1;0m"},
   WriteString[OutputStream["stdout", 1],
      warning<>": Only remaps of A0, B0, C0, C00, D0 and D00 are implemented.\n"];
   WriteString[OutputStream["stdout", 1],
      warning<>": FlexibleSUSY C0, D0 and D00 require zero external momenta.\n"];
   {
      LoopTools`A0i[LoopTools`aa0, args__] :>
         "softsusy::a0"[Apply[Sequence,"std::sqrt"/@{args}],"context.scale()"],
      LoopTools`A0[arg_] :>
         "softsusy::a0"[Apply[Sequence,"std::sqrt"/@{arg}],"context.scale()"],
      LoopTools`B0i[LoopTools`bb0, args__] :>
         "softsusy::b0"[Apply[Sequence,"std::sqrt" /@ {args}],"context.scale()"],
      LoopTools`B0i[LoopTools`bb1, args__] :>
         "(-1)*softsusy::b1"[Apply[Sequence,Map[Sqrt, {args}] /. Sqrt[(Mass@x___)^2] :> Mass@x],"context.scale()"],
      LoopTools`C0i[LoopTools`cc0, 0, 0, 0, args__] :>
         "softsusy::c0"[Apply[Sequence,"std::sqrt" /@ {args}]],
      LoopTools`C0i[LoopTools`cc00, 0, 0, 0, args__] :>
         "softsusy::c00"[Apply[Sequence,"std::sqrt" /@ {args}], "context.scale()"],
      LoopTools`D0i[LoopTools`dd0, 0, 0, 0, 0, 0, 0, args__] :>
         "softsusy::d0"[Apply[Sequence,"std::sqrt" /@ {args}]],
      LoopTools`D0i[LoopTools`dd00, 0, 0, 0, 0, 0, 0, args__] :>
         "softsusy::d27"[Apply[Sequence,Map[Sqrt, {args}] /. Sqrt[(x___)^2] :> x]]
   }
];
GetLTToFSRules[__] :=
   Utils`AssertOrQuit[False,GetLTToFSRules::errUnknownInput];

CXXArgStringNPF::usage=
"@brief Returns the c++ arguments that the c++ version of the given n-point 
correlation function shall take.
Default value of zero for all external momenta is chosen if the second parameter
is \"def\".
@param nPointFunction the given n-point correlation function
@param control String that sets up the type of argument string
@return the c++ arguments that the c++ version of the given n-point 
correlation function shall take.
Default value of zero for all external momenta is chosen if the second parameter
is \"def\".";
CXXArgStringNPF::errUnknownInput=
"Input should be [NPointFunction object, String string]";
CXXArgStringNPF[nPointFunction:NPFPattern[],control_String:""] :=
Module[
   {
      str = If[control === "def",
         "const `1` &model,
          const std::array<int,`2`> &indices, 
          const std::array<Eigen::Vector4d,`3`> &momenta = { `4` }",
         "const `1` &model, 
          const std::array<int,`2`> &indices, 
          const std::array<Eigen::Vector4d,`3`> &momenta"],
      numInd = Length@ExternalIndicesNPF@nPointFunction,
      numMom = Length@ExternalMomentaNPF@nPointFunction,
      eigenType = FlexibleSUSY`FSModelName<>"_mass_eigenstates",
      momDef
   },
   momDef = StringRiffle[Table["Eigen::Vector4d::Zero()",{numMom}],", "];
   StringTemplate[str][eigenType,numInd,numMom,momDef]
];
CXXArgStringNPF[___] :=
   Utils`AssertOrQuit[False,CXXArgStringNPF::errUnknownInput];

ExternalIndicesNPF::usage=
"@brief Return a list of open field indices for a given NPointFunction object.
@param nPointFunction NPointFunction object.
@returns a list of the open field indices for a given NPointFunction object.";
ExternalIndicesNPF::errUnknownInput=
"Input should be [NPointFunction object]";
ExternalIndicesNPF[NPFPattern["Fields"->fields_]] :=
   DeleteDuplicates@Flatten@Level[fields,{4,5}];
ExternalIndicesNPF[___] :=
   Utils`AssertOrQuit[False,ExternalIndicesNPF::errUnknownInput];

ExternalMomentaNPF::usage=
"@brief Return a list of external momenta for a given NPointFunction object.
@param nPointFunction NPointFunction object.
@returns a list of the open field indices for a given NPointFunction object.";
ExternalMomentaNPF::errUnknownInput=
   ExternalIndicesNPF::errUnknownInput;
ExternalMomentaNPF[NPFPattern["Sums"->sums_,"Subs"->subs_]] :=
   DeleteDuplicates@
      Cases[{sums,subs},HoldPattern@SARAH`Mom[_Integer,___],Infinity];
ExternalMomentaNPF[___] :=
   Utils`AssertOrQuit[False,ExternalMomentaNPF::errUnknownInput];

CXXBodyNPF::usage=
"@brief Return the c++ code for the function body of the c++ version of a given
n-point correlation function.
@param nPointFunction NPointFunction object
@returns the c++ code for the function body of its c++ version.";
CXXBodyNPF::errUnknownInput=
   ExternalIndicesNPF::errUnknownInput;
CXXBodyNPF[nPointFunction:NPFPattern[]] :=
StringTemplate["`1` helper{ model, indices, momenta };\nreturn helper.calculate();"][
   CXXClassNameNPF@nPointFunction];
CXXBodyNPF[___] :=
   Utils`AssertOrQuit[False,CXXBodyNPF::errUnknownInput];

CXXClassNameNPF::usage=
"@brief Return the c++ name for the helper class of the c++
version of a given n-point correlation function.
@param NPointFunction object
@returns the c++ name for the helper class of the c++
version of a given n-point correlation function.";
CXXClassNameNPF::errUnknownInput=
   ExternalIndicesNPF::errUnknownInput;
CXXClassNameNPF[NPFPattern["Fields"->fields_]] :=
Module[{fieldNames = Vertices`StripFieldIndices/@Join@@fields},
   "nPoint" <> StringJoin@Map[ToString,fieldNames/.a_[b_]:>Sequence@@{a,b}]
];
CXXClassNameNPF[___] :=
   Utils`AssertOrQuit[False,CXXClassNameNPF::errUnknownInput];

CXXClassForNPF::usage=
"@brief Return the c++ code for the helper class of the c++ version of a given
n-point correlation function.
@param nPointFunction the given n-point correlation function
@param projectColourFactor the colour factor projection to be applied for the
given n-point correlation function
@returns the c++ code for the helper class of the c++ version of a given
n-point correlation function.";
CXXClassForNPF::errUnknownInput=
   CXXClassForNPF::usage;
CXXClassForNPF[
   nPointFunction:NPFPattern[
      "Sums"->genSums_,
      "CombFac"->combFac_,
      "ClFields"->clFields_,
      "ColFac"->colFac_,
      "Subs"->subexpressions_],
   projCol_,
   fermionBasis_:{}] :=
Module[
   {
      className = CXXClassNameNPF@nPointFunction,
      extIndices = ExternalIndicesNPF@nPointFunction,
      numberOfMomenta = Length@ExternalMomentaNPF@nPointFunction,
      cxxCorrelationContext,
      genFields = DeleteDuplicates[Flatten@GetClassRules@nPointFunction /. Rule[x_, _] :> x],
      genSumNames = Array[
         StringTemplate@"genericSum`1`",
         Length@genSums],
      initializeSums = StringRiffle[Array[
         StringTemplate@"const auto genericsum`1` = genericSum`1`();",
         Length@genSums],"\n"],
      genericSumCode, preCXXRules, cxxExpr,
      cxxSubexpressions,
      noFermionChains = TrueQ[Length@fermionBasis === 0],
      code
   },

   preCXXRules = ToCXXPreparationRules[extIndices,genFields,subexpressions];

   cxxSubexpressions = CXXCodeForSubexpressions[subexpressions, preCXXRules];

   genericSumCode = StringRiffle[MapThread[
      CXXGenericSum[##,subexpressions,preCXXRules,fermionBasis]&,
         {
            genSums,
            clFields,
            combFac,
            ExtractColourFactor[colFac,projCol],
            genSumNames
         }],
      "\n\n"];

   cxxExpr = StringRiffle[#<>If[noFermionChains,"()","().at(i)"]&/@genSumNames,"+"];

   cxxCorrelationContext = StringTemplate[
      "correlation_function_context<`1`,`2`>"][Length@extIndices,numberOfMomenta];
   
   code = "class `CLASS_NAME` : public `CONTEXT` {
      using generic_sum_base = `CONTEXT`;
      template<class GenericFieldMap>
      struct subexpression_base :
      generic_sum_base, index_map_interface<GenericFieldMap> {
         subexpression_base( const subexpression_base & ) = default;
         subexpression_base( const generic_sum_base &gsb, 
            const typename field_index_map<GenericFieldMap>::type &fim ) :
         generic_sum_base( gsb ), index_map_interface<GenericFieldMap>( fim )  
         {}
      }; // subexpression_base<GenericFieldMap>
      `KEY_STRUCTS`
      `SUBEXPRESSIONS`
      `GENERIC_SUMS`
      public:
      `CLASS_NAME`(`ARGS`) : `CONTEXT`{ model, indices, momenta }
      {}
      `CALCULATE_FUNC`
   };";
      
   StringReplace[code,{
   "`CLASS_NAME`"->className,
   "`CONTEXT`"->cxxCorrelationContext,
   "`KEY_STRUCTS`"->StringRiffle[StringTemplate["struct `1` {};"]/@CXXGenFieldKey/@genFields,"\n"],
   "`SUBEXPRESSIONS`"->cxxSubexpressions,
   "`GENERIC_SUMS`"->genericSumCode,
   "`ARGS`"->CXXArgStringNPF@nPointFunction,
   "`CALCULATE_FUNC`"->CXXCodeFunCalculate[cxxExpr,initializeSums,Length@fermionBasis]}]
];
CXXClassForNPF[___] :=
   Utils`AssertOrQuit[False,CXXClassForNPF::errUnknownInput];

ToCXXPreparationRules::usage=
"@brief Generate a list of rules for translating Mathematica expressions of
n-point correlation functions to c++ counterparts.
@param externalIndices the external indices of an n-point correlation function
@param genericFields the generic fields appearing in an n-point correlation
function
@param subexpressions the list of subexpressions needed to evaluate an n-point
correlation function
@returns a list of rules for translating Mathematica expressions of n-point
correlation functions to c++ counterparts.";
ToCXXPreparationRules[extIndices_List,genericFields_List,subexpressions_List] :=
Module[
   {
      externalIndexRules = MapThread[Rule,{extIndices,
         Map[StringTemplate@"this->external_indices(`1`)",
            Array[#-1&,Length@extIndices]]}],
      AuxVertexType,
      genericRules,subexprRules,massRules,couplingRules
   },
   genericRules=Flatten[Thread@Rule[
      {Susyno`LieGroups`conj@#, SARAH`bar@#, #},
      {CXXGenFieldName[Susyno`LieGroups`conj@#][CXXFieldIndices@#],
      CXXGenFieldName[SARAH`bar@#][CXXFieldIndices@#],
      CXXGenFieldName[#][CXXFieldIndices@#]}] &/@ genericFields];
      
   AuxVertexType[fields__]:= StringRiffle[
      If[IsGenericField@#,
         Head[#/.genericRules],
         CXXFieldName@#]&/@{fields},", "];
   couplingRules = {
      SARAH`Cp[fields__][1] :>
      I*StringTemplate["context.vertex<`1`>(lorentz_scalar{}, concatenate(`2`))"][
         AuxVertexType@fields,
         StringRiffle[CXXFieldIndices/@{fields},", "]
         ],
      SARAH`Cp[fields__][SARAH`PL] :>
      I*StringTemplate["context.vertex<`1`>(lorentz_left{}, concatenate(`2`))"][
         AuxVertexType@fields,
         StringRiffle[CXXFieldIndices/@{fields},", "]
         ],
      SARAH`Cp[fields__][SARAH`PR] :>
      I*StringTemplate["context.vertex<`1`>(lorentz_right{}, concatenate(`2`))"][
         AuxVertexType@fields,
         StringRiffle[CXXFieldIndices/@{fields},", "]
         ],
      SARAH`Cp[fields___][SARAH`Mom[f1_] - SARAH`Mom[f2_]] :>
      I*StringTemplate["context.vertex<`1`>(lorentz_momentum_diff{`2`,`3`}, concatenate(`4`))"][
         AuxVertexType@fields,
         First@@Position[{fields},f1,{1}]-1,                                    (*@note hope that nobody call particle List*)
         First@@Position[{fields},f2,{1}]-1,                                    (*@note hope that nobody call particle List*)
         StringRiffle[CXXFieldIndices/@{fields},", "]
         ],
      SARAH`Cp[fields__][SARAH`g[_,_]] :>
      I*StringTemplate["context.vertex<`1`>(lorentz_inverse_metric{}, concatenate(`2`))"][
         AuxVertexType@fields,
         StringRiffle[CXXFieldIndices/@{fields},", "]
         ],
      SARAH`Cp[fields__][(SARAH`Mom[f2_, _]-SARAH`Mom[f1_, _])*SARAH`g[_,_],
         (SARAH`Mom[f1_,_]-SARAH`Mom[f3_,_])*SARAH`g[_,_],
         (SARAH`Mom[f3_,_]-SARAH`Mom[f2_,_])*SARAH`g[_,_]] :>
      I*StringTemplate["context.vertex<`1`>(triple_vector{}, concatenate(`2`))"][
         AuxVertexType@fields,
         StringRiffle[CXXFieldIndices/@{fields},", "]
         ]
   };
   massRules = {
      SARAH`Mass[genField_String[genIndex_String]] :>
         StringTemplate["context.mass<`1`>(`2`)"][genField,genIndex],
      SARAH`Mass[extField_Symbol[{extIndex_String}]] :>                         (*@todo field without `conj or `bar*)
         StringTemplate["context.mass<fields::`1`>(std::array<int,1> {`2`})"][  (*@todo here only one external index is allowed*)
         extField,extIndex],                                                    (*@todo *)
      SARAH`Mass[extField_Symbol] :>                                            (*@todo field without `conj or `bar*)
         StringTemplate["context.mass<fields::`1`>(std::array<int,0> {})"][     (*@todo here only zero external indices are allowed*)
         extField]                                                              (*@todo *)
   };
   subexprRules = Rule[First@#, ToString@First@# <> "_()"] &/@ subexpressions;

   {externalIndexRules,couplingRules,genericRules, massRules, subexprRules}
];

CXXGenFieldName::usage=
"@brief Given a (possibly conjugated) generic field, return its c++ type.
@param genericField the given generic field
@returns the name of the c++ type for a (possibly conjugate) field.
@note functions saves its unique previous calls to improve the speed of
calculations.";
CXXGenFieldName::errUnknownInput=
"Input should be head@Field@GenericIndex@Integer, where head can be
bar, conj or nothing";
CXXGenFieldName[SARAH`bar[field_]] :=
   CXXGenFieldName[SARAH`bar[field]] =
   StringTemplate["typename bar<`1`>::type"][CXXGenFieldName@field];
CXXGenFieldName[Susyno`LieGroups`conj[field_]] :=
   CXXGenFieldName[Susyno`LieGroups`conj[field]] =
   StringTemplate["typename conj<`1`>::type"][CXXGenFieldName@field];
CXXGenFieldName[head_[GenericIndex[index_Integer]]] :=
   CXXGenFieldName[head[GenericIndex[index]]] =
   ToString[head]<>ToString[index];
CXXGenFieldName[___] :=
   Utils`AssertOrQuit[False,CXXGenFieldName::errUnknownInput];

CXXFieldName::usage = 
"@brief Given an explicit field (possibly conjugated), returns its c++ representation.
@param The given generic field
@returns String Name of the c++ representation for a field (possibly conjugate).";
CXXFieldName::errUnknownInput=
"Input should be either head@fieldName[{___}] or head@fieldName
with head being \"SARAH`.`bar\", \"Susyno`.`LieGroups`.`conj\" or nothing and not:
CXXFieldName@@`1`";
CXXFieldName[SARAH`bar[head_]] :=
   StringJoin["typename bar<",CXXFieldName@head,">::type"];
CXXFieldName[Susyno`LieGroups`conj[head_]] :=
   StringJoin["typename conj<",CXXFieldName@head,">::type"]
CXXFieldName[fieldName_Symbol[_?VectorQ] | fieldName_Symbol] :=
   StringJoin["fields::",SymbolName@fieldName];
CXXFieldName[x___] :=
   Utils`AssertOrQuit[False,CXXFieldName::errUnknownInput,{x}];

CXXFieldIndices::usage=
"@brief Return the c++ expression for the container of the indices of a given
(possibly generic) field.
@param field the given field
@returns the c++ expression for the container of the indices of a given
(possibly generic) field.
@note functions saves its unique previous calls to improve the speed of
calculations.";
CXXFieldIndices::errUnknownInput=
"Input should be head@Field@GenericIndex@Integer, where head can be
bar, conj or nothing, OR ExternalField OR ExternalField[{Indices}].";
CXXFieldIndices[SARAH`bar[field_]] :=
   CXXFieldIndices[SARAH`bar[field]] =
   CXXFieldIndices@field;
CXXFieldIndices[Susyno`LieGroups`conj[field_]] :=
   CXXFieldIndices[Susyno`LieGroups`conj[field]] =
   CXXFieldIndices@field;
CXXFieldIndices[head_[GenericIndex[index_Integer]]] := 
   CXXFieldIndices[head[GenericIndex[index]]] =
   StringTemplate["indices`1``2`"][StringTake[SymbolName@head,-1],index];
CXXFieldIndices[field_] :=
   If[Length@field === 0, "std::array<int,0>()",
      StringTemplate["std::array<int,`1`>{`2`}"][Length@@field,
         StringRiffle[ToString/@First@field,", "]]];
CXXFieldIndices[___] :=
   Utils`AssertOrQuit[False,CXXFieldIndices::errUnknownInput];

IsGenericField::usage=
"@brief Determine whether a given field is a generic or not.
@param field the given field
@returns `True` if the given field is generic and `False` otherwise.
@todo no tensor fields.
@note functions saves its unique previous calls to improve the speed of
calculations.";
IsGenericField::errUnknownInput=
"Only one argument is allowed.";
IsGenericField[field_] := IsGenericField[field] =
Module[{head = Head[CXXDiagrams`RemoveLorentzConjugation[field]]},
   Switch[head,
      GenericS, True, 
      GenericF, True, 
      GenericV, True, 
      GenericU, True, 
      _, False]
]; 
IsGenericField[___] :=
   Utils`AssertOrQuit[False,IsGenericField::errUnknownInput];

CXXCodeForSubexpressions::usage=
"@brief Create the c++ code encoding a given set of subexpressions.
@param subexpressions the list of subexpressions
@param preCXXRules a list of rules to apply to the subexpressions before
calling ``Parameters`ExpressionToString[]`` for the c++ translation.
@returns the c++ code encoding a given set of subexpressions.";
CXXCodeForSubexpressions[
   subexpressions:{___Rule},
   preCXXRules:{{(_Rule|_RuleDelayed)...}...}] :=
Module[
   {
      names = First/@subexpressions,
      exprs = Last/@subexpressions,
      relevantSubs,relevantGens,cxxExprs,data,outStrings,
      code = "
      template<class GenericFieldMap>
      struct @SubexpressionName@ : subexpression_base<GenericFieldMap> {
         template<class ...Args>
         @SubexpressionName@(Args&& ...args) :
         subexpression_base<GenericFieldMap>(std::forward<Args>(args)...) {
         } // End of constructor @SubexpressionName@<...>

         std::complex<double> operator()( void ) const {
            @CodeIfOtherSubexpressionsPresent@
            @CodeIfGenericFieldsPresent@
            @CodeIfMassesOrVerticesPresent@
            @ReturnResult@
         } // End of operator()( void )
      }; // End of struct @SubexpressionName@<GenericFieldMap>
      "
   },
   relevantSubs = DeleteDuplicates/@
      Map[Cases[#,subs:Alternatives@@names:>subs,Infinity,Heads->True]&,exprs];
   relevantGens = DeleteDuplicates/@
      Map[Cases[#,_[GenericIndex[_]],Infinity,Heads->True]&,exprs];
   cxxExprs = StringReplace[#,"\""->""]&@
      Map[Parameters`ExpressionToString[Fold[ReplaceAll,#,preCXXRules]]&,exprs];
   data = {ToString/@names,relevantSubs,relevantGens,exprs,cxxExprs};
   outStrings=MapThread[stringReplaceWithIndent[code,
      {
         "@SubexpressionName@"->#1,
         "@CodeIfOtherSubexpressionsPresent@"->CXXSubsInSub@#2,
         "@CodeIfGenericFieldsPresent@"->CXXGenericFieldsInSub@#3,
         "@CodeIfMassesOrVerticesPresent@"->CXXContextInitialize@#4,
         "@ReturnResult@"->stringGeneratedCut["return "<>#5<>";",100,","]
      }
   ]&,data];
   StringRiffle[outStrings,"\n\n"]
];

CXXGenFieldKey::usage=
"@brief Given a generic field, determine its key type used in the c++ code to
uniquely label it.
@param genericField given generic field.
@param {genericField..} given generic fields.
@param ind (def. \"\") string which is responsible for an indent of code.
@returns c++ key type of a generic field(s).";
CXXGenFieldKey[fields:{__}, _String:""] :=
   StringRiffle[CXXGenFieldKey/@fields,", "];
CXXGenFieldKey[head_[GenericIndex[index_Integer]]] :=
   ToString@head<>ToString@index<>"Key";
SetAttributes[CXXGenFieldKey,{Protected,Locked}]

CXXSubsInSub::usage=
"@brief Generates required c++ code for subexpression if other subexpressions
present there.
@param subs:{...} list of symbols.
@param ind (def. \"\") indent string for a c++ code.
@returns String c++ code for subexpression if other subexpressions present there.";
CXXSubsInSub::errUnknownInput=
"Correct input is
CXXSubsInSub@@{ {<symbol>...}, <string> }
and not
CXXSubsInSub@@`1`";
CXXSubsInSub[subs:{__Symbol},ind_String:""] :=
StringRiffle[
   ToString@#<>"<GenericFieldMap> "<>ToString@#<>"_ { *this };"&/@subs,
   "\n"<>ind
];
CXXSubsInSub[{},_String:""] :=
"// This subexpression does not depend on other ones";
CXXSubsInSub[x___] :=
   Utils`AssertOrQuit[False,CXXSubsInSub::errUnknownInput,{x}];

CXXGenericFieldsInSub::usage =
"@brief Generates required c++ code for subexpression if generic fields present
there.
@param fields:{...} list of presenting generic fields.
@param ind (def. \"\") indent string for a c++ code.
@returns c++ code for subexpression if generic fields present there.";
CXXGenericFieldsInSub::errUnknownInput =
"Correct input is
CXXGenericFieldsInSub@@{ {<generic field>...}, <string> }
and not
CXXGenericFieldsInSub@@`1`";
CXXGenericFieldsInSub[fields:{__?IsGenericField},ind_String:""] :=
Module[
   {
      names = CXXGenFieldName/@fields,
      indices = CXXFieldIndices/@fields,
      keys = CXXGenFieldKey/@fields,
      fLns,iLns,
      mainCommands = {
         "using boost::mpl::at;",
         "using boost::fusion::at_key;",
         "`1`",
         "`2`"},
      fCommand = "using `1` = typename at<GenericFieldMap, `2`>::type;",
      iCommand = "const auto &`1` = at_key<`2`>(this->index_map());"
   },
   fLns=StringRiffle[MapThread[StringTemplate@fCommand,{names,keys}],"\n"<>ind];
   iLns=StringRiffle[MapThread[StringTemplate@iCommand,{indices,keys}],"\n"<>ind];
   StringTemplate[StringRiffle[mainCommands,"\n"<>ind]][fLns,iLns]
];
CXXGenericFieldsInSub[{},_String:""] :=
"// This subexpression does not depend on generic fields";
CXXGenericFieldsInSub[x___] :=
Utils`AssertOrQuit[False,CXXGenericFieldsInSub::errUnknownInput,{x}];

CXXContextInitialize::usage =
"@brief Generates required c++ code if couplings or masses present.
@param expr Any expression to check for mass of coupling presence.
@param ind (def. \"\") indent string for a c++ code.
@returns String c++ code for subexpression if couplings or masses present there.";
CXXContextInitialize::errUnknownInput =
"Correct input is
CXXContextInitialize@@{ <any expression>, <string> }
and not
CXXContextInitialize@@`1`";
CXXContextInitialize[expr_,_String:""] :=
If[Not[FreeQ[expr,SARAH`Cp]&&FreeQ[expr,SARAH`Mass]],
   "const context_with_vertices &context =  *this;",
   "// Code in this scope does not depend on couplings or masses"
];
CXXContextInitialize[x___] :=
Utils`AssertOrQuit[False,CXXContextInitialize::errUnknownInput,{x}];

ExtractColourFactor::usage=                                                     (*@todo modify this to use some enum of proj-s*)
"@brief Extracts the colour factor for a given colour structure like 
e.g, Delta[ct1, ct2].";
ExtractColourFactor[colourfactors:{{__}..}, projection_] :=
If[projection === Identity,
   Map[Identity,colourfactors,{2}],
   Map[Coefficient[#, projection]&,colourfactors,{2}]
];

CXXGenericSum::usage=
"@brief Create the c++ code encoding a given sum over generic fields.
@param sum the sum over generic fields
@param genericInsertions the list of field insertions to be summed over
@param combinatorialFactors a list of combinatorial factors (~symmetry factors) 
to multiply the amplitudes of specific insertions with.
@param colourFactors a list of colour factors to multiply the amplitudes of
specific insertions with.
@param functionName the name of the resulting c++ function
@param subexpressions the list of subexpressions
@param preCXXRules a list of rules to apply to the subexpressions
before calling ``Parameters`ExpressionToString[]`` for the c++
translation.
@returns the c++ code encoding the given sum over generic fields.
@note the most time consuming procedure.";
CXXGenericSum::errColours=
"Colour factor is not a number after projection: `1`";
CXXGenericSum[
   sum:GenericSum[expr_,genericFields_],
   genericInsertions_List,combinatorialFactors_List,
   colourFactors_List,genSumName_String,subexpressions_List,preCXXRules_List,
   fermionBasis_:{}] :=
Module[
   {
      type = If[fermionBasis =!= {},
         StringTemplate["std::array<std::complex<double>,`1`>"][Length@fermionBasis],
         "std::complex<double>"],
      context = If[Not[FreeQ[expr,SARAH`Cp]&&FreeQ[expr,SARAH`Mass]],
         "const context_with_vertices &context = *this;",
         "// This GenericSum does not depend on couplings or masses"],
      storage = If[fermionBasis =!= {},
         StringJoin["std::complex<double>", #, " = 0.0;\n"]&/@fermionBasis,     (* Fermion basis is supposed to contain strings! S*)
         "std::complex<double> value = 0.0;"],
      cxxExpr,wilsonCoeffs,generatedCode,
      code = "
      template<class GenericFieldMap>
      struct @GenericSum_NAME@_impl : generic_sum_base {
         @GenericSum_NAME@_impl( const generic_sum_base &base ) : 
         generic_sum_base( base ) {
         } // End of constructor @GenericSum_NAME@_impl

         @ReturnType@ operator()( void ) {
            using boost::mpl::at;
            using boost::fusion::at_key;
            @GenericFieldShortNames@

            typename field_index_map<GenericFieldMap>::type index_map;
            @InitializeSubstitutions@
            @InitializeContext@
            @InitializeOutputVars@

            // Start of summation over generic fields
            @StartSumOverGenFields@
               @ChangeOutputVars@
            @EndSumOverGenFields@

            return @OutputVars@;
         } // End of operator()( void )
      }; // End of struct @GenericSum_NAME@_impl<GenericFieldMap>

      @ReturnType@ @GenericSum_NAME@( void ) {
         using GenericKeys = boost::mpl::vector< @GenericKeys@ >;
         using GenericInsertions = boost::mpl::vector<
            @ClassInsertions@
            >;
         using combinatorial_factors = boost::mpl::vector<
            @CombinatoricalFactors@
            >;
         using colour_factors = boost::mpl::vector<
            @ColorFactors@
            >;
         return accumulate_generic<
            GenericKeys,
            GenericInsertions,
            combinatorial_factors,
            colour_factors,
            @FermionBasisMETALength@,
            @GenericSum_NAME@_impl
            >( *this );
      } // End of function @GenericSum_NAME@()"
   },
   If[Length[fermionBasis] =!= 0,
      Utils`AssertWithMessage[Length[fermionBasis] === Length[expr],            (*what about fermion chains inside subexpressions?*)
        "CXXGenericSum[]: the length of the provided basis
         and the coefficients does not match."                                  (*how could we know a priori the length of the basis for a given amplitude*)
      ];
      cxxExpr = Map[Parameters`ExpressionToString[
        Fold[ReplaceAll, #, preCXXRules]]&, expr];
      cxxExpr = StringReplace[cxxExpr, "\"" -> ""];
      wilsonCoeffs = MapThread[StringJoin[#1, " += ", #2, ";\n\n"]&, {fermionBasis, cxxExpr}],
      (*normal(?) code*)
      cxxExpr = StringReplace[
         Parameters`ExpressionToString[Fold[ReplaceAll,expr,preCXXRules]],
         "\""->""];
   ];
   generatedCode = If[fermionBasis =!= {},StringJoin[wilsonCoeffs],"value += " <> cxxExpr<>";"];
   stringReplaceWithIndent[code,
      {
         "@GenericSum_NAME@"->genSumName,
         "@ReturnType@"->type,
         "@GenericFieldShortNames@"->CXXCodeNameKey@genericFields,
         "@InitializeSubstitutions@"->CXXSubsInGenericSum[sum,subexpressions],
         "@InitializeContext@"->context,
         "@InitializeOutputVars@"->storage,
         "@StartSumOverGenFields@"->CXXBeginSum@genericFields,
         "@ChangeOutputVars@"->stringGeneratedCut[generatedCode,100,","],
         "@EndSumOverGenFields@"->CXXEndSum@genericFields,
         "@OutputVars@"->"value" (* @todo If[fbQ,ToString[fermionBasis],"value"] *),
         "@GenericKeys@"->CXXGenFieldKey@genericFields,
         "@ClassInsertions@"->CXXClassInsertions@genericInsertions,
         "@CombinatoricalFactors@"->CXXFactorInsertions@combinatorialFactors,
         "@ColorFactors@"->CXXColourInsertions@colourFactors,
         "@FermionBasisMETALength@"->CXXFermionMetaLength@fermionBasis
      }
   ]
] /; And[
   MatchQ[colourFactors,
      {__?(Utils`AssertOrQuit[NumberQ@#,
         CXXGenericSum::errColours,
         #]&
      )}]
];

stringReplaceWithIndent::usage =
"@brief Function for smart c++ code replacements with indents. If replacement
rule contain a f[args___], then this function automatically makes it
f[args___,ind], where ind is responsible for an indent.
@param str String with tokens of arbitrary form, specified in the second
argument.
@param rules List of Rule[String,_] where on the lhs of rule there are tokens.
@note rules are supposed to return a String.";
stringReplaceWithIndent[
   str_?(StringMatchQ[#,"\n"~~__]&),
   rules:{Rule[_String,_]..}
] :=
Module[
   {
      tokens = rules[[All,1]],
      holdRules = Hold/@Unevaluated@rules,
      evaluatedRules = rules,
      generalIndent = StringCases[str,"\n"~~" "...,1],
      lines,now = 1,
      pmt, (* Potentially multiline token *)
      currentRule,currentIndent,modifiedRule
   },
   lines = StringSplit[str,generalIndent];
   Do[
      If[StringMatchQ[lines[[now]],___~~Alternatives@@tokens~~___],             (* Do we have tokens in the current line? *)
         pmt = StringCases[
            lines[[now]],
            StartOfString~~" "...~~tok:Alternatives@@tokens:>tok];
         If[pmt =!= {},
            pmt = pmt[[1]];
            currentRule = holdRules[[ Position[tokens,pmt][[1]] ]];
            If[MatchQ[currentRule, {Hold@Rule[_, _[___]]}],                     (* Is token multiline? *)
               currentIndent = StringCases[lines[[now]]," "...,1][[1]];
               modifiedRule = currentRule /.
                  Hold@Rule[t_,f_[args___]] :> Rule[t,f[args,currentIndent]];
               lines[[now]] = StringReplace[lines[[now]],modifiedRule];
            ];
         ];
      lines[[now]] = StringReplace[lines[[now]], evaluatedRules];
      ];
      now ++;,
      Length@lines
   ];
   StringRiffle[lines,"\n"]
];
SetAttributes[stringReplaceWithIndent,{Protected,Locked,HoldRest}];

stringGeneratedCut::usage =
"@brief Function for dummy c++ code cut. It cuts string to a maximal possible
ones with length+ind for a given delSymb symbol and then join them.
@param string String String to cut.
@param length Integer Number which approximately corresponds to output width.
@param del String which corresponds to a symbol to delete.
@param ind (def. \"\") string which is responsible for an indent of code.";
stringGeneratedCut[string_String,length_Integer,del_String,ind_String:""] :=
Module[
   {
      strs = StringSplit[string, del],
      f,initSet,numbers,dirtyStrings,cleanStrings
   },
   If[Length@strs==1,Return@string];
   f[{n1_Integer,i1_Integer},{n2_Integer,i2_Integer}] /; i1+i2<length :=
      f[{{n1,n2},i1+i2}];
   f[{n1_Integer,i1_Integer},{n2_Integer,i2_Integer}] :=
      f[{{n1},i1},{{n2},i2}];
   f[f[in___List,{{nums__},sum_}],{n2_Integer,i2_Integer}] /; sum+i2<length :=
      f[in,{{nums,n2},sum+i2}];
   f[f[in___List,{{nums__},sum_}],{n2_Integer,i2_Integer}] := 
      f[in,{{nums},sum},{{n2},i2}];
   initSet=Transpose[{Array[#&,Length@strs],StringLength/@strs}];
   numbers = ReplaceAll[First/@Fold[f,initSet],f->List];
   dirtyStrings = StringJoin[StringRiffle[strs[[#]],del]] &/@ numbers;
   cleanStrings = StringReplace[#, StartOfString~~" "...~~x___:>x] &/@ dirtyStrings;
   StringRiffle[cleanStrings,del<>"\n"<>ind]
];
SetAttributes[stringGeneratedCut,{Protected,Locked}];

CXXCodeNameKey::usage =
"@brief Generates c++ code for type abbreviations stored in GenericFieldMap
(Associative Sequence) at Key positions.
@param genFields:{..} list of presenting generic fields.
@param ind (def. \"\") string which is responsible for an indent of code.
@returns String c++ code for type abbreviations stored in GenericFieldMap
(Associative Sequence) at Key positions.";
CXXCodeNameKey::errUnknownInput =
"Input should be
CXXCodeNameKey@@{ {<generic Field>..}, <string> }
and not:
CXXCodeNameKey@@`1`";
CXXCodeNameKey[genFields:{__?IsGenericField},ind_String:""] :=
   StringRiffle[Apply[
      StringTemplate["using `1` = typename at<GenericFieldMap,`2`>::type;"],
      {CXXGenFieldName@#,CXXGenFieldKey@#}&/@genFields,
      {1}],"\n"<>ind];
CXXCodeNameKey[x___]:=
   Utils`AssertOrQuit[False,CXXCodeNameKey::errUnknownInput,{x}];
SetAttributes[CXXCodeNameKey,{Protected,Locked}];

CXXSubsInGenericSum::usage =
"@brief If the give GenericSum depends on some subexpressions, then generates
code for their initialization.
@param GenericSum[_,_] GenericSum expression.
@param subs List of substitution rules for NPF object.
@param ind (def. \"\") string which is responsible for an indent of code.
@returns String c++ code for initialization of subexpressions if they are
present in given GenericSum.";
CXXSubsInGenericSum::errUnknownInput =
"Input should be 
CXXSubsInGenericSum@@{ GenericSum[_,_], {<rule>..}, <string> }
and not:
CXXSubsInGenericSum@@`1`";
CXXSubsInGenericSum[GenericSum[expr_,_],subs:{Rule[_,_]...},ind_String:""]:=
Module[
   {
      relevantSubs = DeleteDuplicates@Cases[expr,Alternatives@@First/@subs,Infinity]
   },
   If[relevantSubs === {},
      "// This GenericSum does not depend on subexpressions",
      StringRiffle[StringTemplate[
         "`1`<GenericFieldMap> `1`_ { *this, index_map };"]/@relevantSubs,
         "\n"<>ind]]
];
CXXSubsInGenericSum[x___]:=
   Utils`AssertOrQuit[False,CXXSubsInGenericSum::errUnknownInput,{x}];
SetAttributes[CXXSubsInGenericSum,{Protected,Locked}];

CXXBeginSum::usage =
"@brief Generates c++ code for sum beginning used inside GenericSum.
@param genFields:{...} list of presenting generic fields.
@param ind (def. \"\") string which is responsible for an indent of code.
@returns String c++ code for sum beginning used inside generic sums.";
CXXBeginSum::errUnknownInput =
"Input should be 
CXXBeginSum@@{ {<generic_field>..}, <string> }
and not:
CXXBeginSum@@`1`";
CXXBeginSum[genFields:{__?IsGenericField},ind_String:""]:=
   StringRiffle[StringJoin[
      "for( const auto &",CXXFieldIndices@#," : ","index_range<",
      CXXGenFieldName@#,">() ) {","\n",ind,"at_key<",CXXGenFieldKey@#,
      ">( index_map ) = ",CXXFieldIndices@#,";"] &/@genFields,
      "\n"<>ind];
CXXBeginSum[x___]:=
   Utils`AssertOrQuit[False,CXXBeginSum::errUnknownInput,{x}];
SetAttributes[CXXBeginSum,{Protected,Locked}];

CXXEndSum::usage =
"@brief Generates c++ code for end of sum over generic fields inside GenericSum.
@param genFields:{...} list of presenting generic fields.
@param ind (def. \"\") dummy string variable.
@returns String c++ code for end of sum over generic fields inside GenericSum.";
CXXEndSum::errUnknownInput =
"Input should be 
CXXEndSum@@{ {<generic_field>..}, <string> }
and not:
CXXEndSum@@`1`";
CXXEndSum[genFields:{__?IsGenericField},_String:""] :=
   StringJoin[
      Array["}"&,Length@genFields],
      " // End of summation over generic fields"];
CXXEndSum[x___]:=
   Utils`AssertOrQuit[False,CXXEndSum::errUnknownInput,{x}];
SetAttributes[CXXEndSum,{Protected,Locked}];

CXXCodeFunCalculate::usage =
"@brief Generates c++ code for functions which return result of generic sum
calculation
@param cxxExpr string with sums of generic sums.
@param initializeSums string with initializations of
@param fermionBasisLength integer length of fermion basis
@returns String c++ code for sum beginning used inside generic sums.";
CXXCodeFunCalculate::errUnknownInput =
   CXXCodeFunCalculate::usage;
CXXCodeFunCalculate[
   cxxExpr_String,initializeSums_String,fermionBasisLength_Integer
]:=
If[TrueQ[fermionBasisLength === 0],
   StringTemplate["std::complex<double> calculate( void ) { return `1`; }"][cxxExpr],
   StringTemplate["std::array<std::complex<double>,`3`> calculate( void )
   {
      std::array<std::complex<double>,`3`> genericSummation;
      constexpr int coeffsLength = genericSummation.size();
      `2`
      for ( std::size_t i=0; i<coeffsLength; i++ )
      {
         genericSummation.at(i) += `1`;
      }
      return genericSummation;
   }"][cxxExpr,initializeSums,fermionBasisLength]
];
CXXCodeFunCalculate[___]:=
   Utils`AssertOrQuit[False,CXXCodeFunCalculate::errUnknownInput];

CXXClassInsertions::usage =
"@brief Generates c++ code for class insertions inside GenericSum.
@param genInsertions list of list with SARAH particle names.
@param ind (def. \"\") string which is responsible for an indent of code.
@returns String c++ code for class insertions inside GenericSum.";
CXXClassInsertions::errUnknownInput =
"Input should be 
CXXClassInsertions@@{ {{<SARAH_field>..}..}, <string> }
and not:
CXXClassInsertions@@`1`";
CXXClassInsertions[genInsertions:{{__}..},ind_String:""] := 
   StringRiffle["boost::mpl::vector<"<>StringRiffle[CXXFieldName@#&/@#,", "]<>">"&/@genInsertions,",\n"<>ind];
CXXClassInsertions[x___]:=
   Utils`AssertOrQuit[False,CXXClassInsertions::errUnknownInput,{x}];
SetAttributes[CXXClassInsertions,{Protected,Locked}];

CXXFactorInsertions::usage =
"@brief Generates c++ code for combinatorical factor insertions inside GenericSum.
@param combinatorialFactors list of integers.
@param ind (def. \"\") string which is responsible for an indent of code.
@returns String c++ code for combinatorical factor insertions inside GenericSum.";
CXXFactorInsertions::errUnknownInput =
"Input should be 
CXXFactorInsertions@@{ {<integer>..}, <string> }
and not:
CXXFactorInsertions@@`1`";
CXXFactorInsertions[combinatorialFactors:{__Integer},ind_String:""] := 
   StringRiffle["boost::mpl::int_<"<>ToString@#<>">"&/@combinatorialFactors,",\n"<>ind];
CXXFactorInsertions[x___]:=
   Utils`AssertOrQuit[False,CXXFactorInsertions::errUnknownInput,{x}];
SetAttributes[CXXFactorInsertions,{Protected,Locked}];

CXXColourInsertions::usage =
"@brief Generates c++ code for colour factor insertions inside GenericSum.
@param colourFactors list of numbers.
@param ind (def. \"\") string which is responsible for an indent of code.
@returns String c++ code for colour factor insertions inside GenericSum.";
CXXColourInsertions::errUnknownInput =
"Input should be 
CXXColourInsertions@@{ {<number>..}, <string> }
and not:
CXXColourInsertions@@`1`";
CXXColourInsertions[colourFactors:{__?NumberQ},ind_String:""] :=
Module[
   {
      ReRatioColourFactors = {Numerator@#,Denominator@#} &/@ Re@colourFactors,
      ImRatioColourFactors = {Numerator@#,Denominator@#} &/@ Im@colourFactors
   },
   StringRiffle[
      StringReplace[
         MapThread[
            "detail::complex_helper<"<>
            "detail::ratio_helper<"<>ToString@#1<>">,"<>
            "detail::ratio_helper<"<>ToString@#2 <> ">>"&,
            {ReRatioColourFactors, ImRatioColourFactors}],
         {"{" -> "", "}" -> ""}],
   ",\n"<>ind]
];
CXXColourInsertions[x___]:=
   Utils`AssertOrQuit[False,CXXColourInsertions::errUnknownInput,{x}];
SetAttributes[CXXColourInsertions,{Protected,Locked}];

CXXFermionMetaLength::usage =
"@brief Generates c++ short name for the length of fermion basis.
@param fermionBasis list of fermion chains.
@param ind (def. \"\\n\") dummy string.
@returns String c++ short name for the length of fermion basis.";
CXXFermionMetaLength::errUnknownInput =
"Input should be 
CXXFermionMetaLength@@{ {...}, <string> }
and not:
CXXFermionMetaLength@@`1`";
CXXFermionMetaLength[fermionBasis:{___},_String:"\n"] :=
If[fermionBasis==={},"// There are no fermion chains in this GenericSum: skipping "]<>
"boost::mpl::int_<"<>ToString@Length@fermionBasis<>">";
CXXFermionMetaLength[x___]:=
   Utils`AssertOrQuit[False,CXXFermionMetaLength::errUnknownInput,{x}];
SetAttributes[CXXFermionMetaLength,{Protected,Locked}];

(*auxiliary functions with names of newer Mathematica versions*)
If[TrueQ[$VersionNumber<10],
StringTemplate::usage=
"This is not a full replacement of Mathematica's StringTemplate.
It works correctly only for string, containing `i` insertions with i>0";
StringTemplate::errFailed=
"Failed for this input string
`1`";
StringTemplate[str_String] :=
Module[
   {
      args = DeleteDuplicates@StringCases[str,
         HoldPattern["`"~~DigitCharacter..~~"`"]],
      noControlStrs = DeleteDuplicates@StringSplit[str,
         "`"~~DigitCharacter~~"`"],
      argRules,noControlRules,preControl,return
   },
   argRules = Rule[#,"<>ToString@#"<>StringDrop[StringDrop[#,1],-1]<>"<>"] &/@
      args;
   noControlRules = Rule[#,"\""<>#<>"\""] &/@ noControlStrs;
   preControl = StringReplace[StringReplace[StringReplace[str,
      argRules], noControlRules],"<><>"->"<>"];
   If[StringTake[str,1] === "`",preControl = StringDrop[preControl,2]];
   If[StringTake[str,-1] === "`",preControl = StringDrop[preControl,-2]];
   return=ToExpression[preControl <> "&"];
   If[return===$Failed,
      Utils`AssertOrQuit[False,StringTemplate::errFailed,str],
      return]
];
StringTemplate[___] :=
   Utils`AssertOrQuit[False,StringTemplate::usage];

SetAttributes[{StringTemplate},{Protected, Locked}]
];
If[TrueQ[$VersionNumber<10.1],
StringRiffle::usage=
"This is not a full replacement of Mathematica's StringRiffle.
It works only for [{___String},_String] input.";
StringRiffle[strs:{___String},sep_String] := 
   StringJoin@Riffle[strs,sep];
StringRiffle[strs:{___String},{in_String,sep_String,fin_String}] := 
   in<>StringJoin@Riffle[strs,sep]<>fin;
StringRiffle[___] :=
   Utils`AssertOrQuit[False,StringRiffle::usage];
   
SetAttributes[{StringRiffle},{Protected, Locked}]
];

SetAttributes[
   {
   NPFPattern,NPointFunction,
   GetSARAHModelName,
   GetFAClassesModelName, GetFAParticleNamesFileName, GetFASubstitutionsFileName,
   LaunchSubkernelFor,
   CacheNameForMeta,CacheNPointFunction,CachedNPointFunction,
   GenerateFAModelFileOnKernel,WriteParticleNamespaceFile,
   FANamesForFields,RemoveEmptyGenSums,
   VerticesForNPointFunction,
   CreateCXXHeaders,
   CreateCXXFunctions,
   GetLTToFSRules,
   CXXArgStringNPF,ExternalIndicesNPF,ExternalMomentaNPF,
   CXXBodyNPF,CXXClassNameNPF,CXXClassForNPF,
   ToCXXPreparationRules,(*,CXXGenFieldName,CXXFieldIndices,*)CXXFieldName,(*
   IsGenericField*)
   CXXSubsInSub,CXXGenericFieldsInSub,CXXContextInitialize,
   ExtractColourFactor,CXXGenericSum,
   CXXCodeFunCalculate
   }, 
   {Protected, Locked}];

End[];
EndPackage[];
