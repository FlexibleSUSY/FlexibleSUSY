(* :Copyright:

   ====================================================================
   This file is part of FlexibleSUSY.

   FlexibleSUSY is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published
   by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   FlexibleSUSY is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with FlexibleSUSY.  If not, see
   <http://www.gnu.org/licenses/>.
   ====================================================================

*)

(*@assumptions: 
1) there is no quartic gluon vertices inside diagrams => one can calculate
colour factor for diagram separately from Lorentz factor
2) 4-point vertices are not supported *)
(*@todo add function which cleans GenerisSum[0,{}] correctly*)
BeginPackage["NPointFunctions`",{"FlexibleSUSY`","SARAH`","CXXDiagrams`","Vertices`","Parameters`","Utils`"}];
NPointFunction::usage=
"@brief Calculate the n-point correlation function for a List of incoming and 
a List of outgoing fields.
@param inFields a List of incoming fields
@param outFields a List of outgoing fields
@param LoopLevel the loop level at which to perform the calculation
@param Regularize the regularization scheme to apply
@param UseCache whether to attempt to read and write the result from and to 
the cache.
@param ZeroExternalMomenta whether to set the external momenta to zero or leave 
them undetermined.
@param ExcludedTopologies a list or single symbol of topologies to exclude when 
calculation the n-point correlation function
@returns the corresponding n-point correlation function
@note only a loop level of 1 is currently supported
@note the recognized regularization schemes are:
 - DimensionalReduction
 - DimensionalRegularization
@note when not setting the external momenta to zero one should use LoopTools 
for the evaluation of the loop functions.";
NPointFunction::errinFields=
"The element '`1`' of inFields is an incorrect one.

inFields should contain only names from the list of `2` particles
`3`.
@unote now only restricted set is supported";
NPointFunction::erroutFields=
"The element '`1`' of outFields is an incorrect one.

outFields should contain only names from the list of `2` particles
`3`.
@unote now only restricted set is supported";
NPointFunction::errLoopLevel=
"Incorrect number of loops.

Only loop level 1 is supported";
NPointFunction::errRegularize=
"Unknown regularization scheme `1`.

Currently DimensionalReduction, DimensionalRegularization are supported.";
NPointFunction::errUseCache=
"UseCache must be either True or False.";
NPointFunction::errZeroExternalMomenta=
"ZeroExternalMomenta must be either True or False";
NPointFunction::errOnShellFlag=
"OnShellFlag must be either True or False.";
NPointFunction::errExcludedTopologies=
"ExcludedTopologies must be sublist of 
{OneParticleReducible,ExceptBoxes,ExceptTriangles}.";
NPointFunction::errInputFields=                                                 (* @utodo modify it for usage of bosons also *)
"Only external scalars/fermions are supported (@todo FOR NOW).";
NPointFunction::errCalc=                                                        (* @utodo one needs to be more specific about problem *)
"Calculation failed";
NPointFunction::errUnknownOptions=
"Unknown option(s): 
`1`.

Currently supported options are:
`2`.";
NPointFunction::errUnknownInput=
"Correct input has the folliwing form:
NPointFunction[inFields,outFields,options]
where
 inFields and outFields are lists containing names of `1` particles 
  `2`,
 options have names from list 
  `3`.";

LoopLevel::usage=
"Option for NPointFunctions`NPointFunction[].
Encodes the loop level at which to calculate amplitudes.

def. 1 | 0";
Regularize::usage=
"Option for NPointFunctions`NPointFunction[].
Encodes the regularization scheme to be used.

DimensionalReduction | DimensionalRegularization";
UseCache::usage=
"Option for NPointFunctions`NPointFunction[].
Cache and reuse the expressions generated by FeynArts/FormCalc.
@note @todo there is no difference between different ExcludedTopologies and
OnShellFlag values

def. True | False";
ZeroExternalMomenta::usage=
"Option for NPointFunctions`NPointFunction[].
Encodes whether to set the external momenta to zero or leave them undetermined.

def. True | False";
OnShellFlag::usage=
"Option for NPointFunctions`NPointFunction[].
Use on-shell external fields or not.

def. True | False";
ExcludedTopologies::usage=
"Option for NPointFunctions`NPointFunction[].
Exclude specific topologies in FeynArts.

def. {} |Any sublist of {OneParticleReducible,ExceptBoxes,ExceptTriangles}";

DimensionalReduction::usage=
"Possible value for the Regularize option

(Technically, a wrapper for FlexibleSUSY`.`DRbar)";
DimensionalRegularization::usage=
"Possible value for the Regularize option

(Technically, a wrapper for FlexibleSUSY`.`MSbar)";

OneParticleReducible::usage=
"Possible value for ExcludedTopologies.
No tree-level-type propagators, i.e. if the topology is one-particle 
irreducible.

(Technically, a wrapper for a case when the initialization of FeynArts`.` is 
not needed. Internally converts further to FeynArts`.`Irreducible.)";
ExceptBoxes::usage=
"Possible value for ExcludedTopologies. 
Exclude all topologies except box diagrams

(Technically, a wrapper for a case when the initialization of FeynArts`.` is 
not needed. Internally converts further to FeynArts`.`Loops@Except@3.)";
ExceptTriangles::usage=
"Possible value for ExcludedTopologies. 
Exclude all topologies except triangle diagrams

(Technically, a wrapper for a case when the initialization of FeynArts`.` is 
not needed. Internally converts further to FeynArts`.`Loops@Except@4.)";

GenericS::usage=
"A symbol that acts as a placeholder for any scalar field.";
GenericF::usage=
"A symbol that acts as a placeholder for any fermion field.";
GenericV::usage=
"A symbol that acts as a placeholder for any vector field.";
GenericU::usage=
"A symbol that acts as a placeholder for any ghost field.";
GenericT::usage=
"A symbol that acts as a placeholder for any tensor field.";

GenericSum::usage=
"Represent a sum over a set of generic fields.";
GenericIndex::usage=
"Represent an index of a generic field.";
LorentzIndex::usage=
"Represent a Lorentz index of a generic field.";

VerticesForNPointFunction::usage=
"@brief Return a list of all vertices needed to calculate a given 
n-point correlation function.
@param nPointFunction the given n-point correlation function
@returns a list of all vertices needed to calculate a given 
n-point correlation function.temp";
VerticesForNPointFunction::errUnknownInput=
"Correct input has to be generated by NPointFunction[].";

CreateCXXHeaders::usage=
"@brief Create the c++ code for the necessary headers for evaluation of n-point
correlation functions.
@param LoopFunctions the loop function library to be used
@returns the c++ code for the necessary headers for evaluation
of n-point correlation functions.";
CreateCXXHeaders::errUnknownOptions=
   NPointFunction::errUnknownOptions;
CreateCXXHeaders::errLoopFunctions=
"Unsupported loop functions library `1`.

Currently \"LoopTools\", \"FlexibleSUSY\" are supported.";
CreateCXXHeaders::errUseWilsonCoeffs=
"UseWilsonCoeffs must be either True or False.";
CreateCXXHeaders::errUnknownInput=
"Correct input has the folliwing form:
NPointFunction[options]
where
 options have names from list 
  `1`.";

LoopFunctions::usage=
"Option for NPointFunctions`CreateCXXHeaders[] and 
NPointFunctions`CreateCXXFunctions[]
Controls whether to use FlexibleSUSY or LoopTools for loop functions.

def. \"LoopTools\" | \"FlexibleSUSY\"";
UseWilsonCoeffs::usage=
"Option for NPointFunctions`CreateCXXHeaders[].
Controls whether to use Wilson module or not

def. True | False";

CreateCXXFunctions::usage="
@brief Given a list of n-point correllation functions, a list
of c++ function names and a list of colour factor projections
create the c++ code for the numerical evaluation of the
n-point correllation functions.
@param nPointFunctions the list of n-point correlation functions
@param names the list of function names
@param colourFactorProjections a list or a singleton of colour factor
projections that shall be applied to the general expressions for the
colour factors in the corresponding n-point correllation function.
The result of applying such a projection must be a scalar. e.g
``exampleProjection[scalar_ *
  SARAH`Delta[colourIndex1_, colourIndex2_]] :> scalar``
@param LoopFunctions the loop function library to be used.
@note Currently, only FlexibleSUSY and LoopTools are supported as
loop function libraries.
@returns a list of the form `{prototypes, definitions}` containing
the corresponding c++ code.
";
CreateCXXFunctions::errnPointFunctions=
"The element '`1`' of nPointFunctions is an incorrect one.

nPointFunctions should contain only NPointFunction objects
@note GenericSum should have non-zero first argument";
CreateCXXFunctions::errnames=
"The element '`1`' of errnames is an incorrect one.

names should contain only strings for c++ function names";
CreateCXXFunctions::errUnequalLength=
"Lengths of nPointFunctions and names should be the same";
CreateCXXFunctions::errUnknownOptions=
   NPointFunction::errUnknownOptions;
CreateCXXFunctions::errLoopFunctions=
   CreateCXXHeaders::errLoopFunctions;
(*@todo check for FermionBasis*)
CreateCXXFunctions::errUnknownInput=
"Correct input has the folliwing form:
@todo
where
 options have names from list 
  `1`.";

FermionBasis::usage=
"Option for NPointFunctions`CreateCXXFunctions[].
Specify the fermion basis used for the matching.

def. {} | @todo";

SetAttributes[
   {
   LoopLevel,Regularize,UseCache,ZeroExternalMomenta,OnShellFlag,
   ExcludedTopologies,
   DimensionalReduction,DimensionalRegularization,
   OneParticleReducible,ExceptBoxes,ExceptTriangles,
   GenericS,GenericF,GenericV,GenericU,GenericT,                                (* @unote also exist in internal.m*)
   GenericSum,GenericIndex,LorentzIndex,                                        (* @unote also exist in internal.m*)
   LoopFunctions,UseWilsonCoeffs, FermionBasis
   }, 
   {Protected, Locked}];

A0i::usage="A symbol representing an A0 function.";
B0i::usage="A symbol representing an B0 function.";
C0i::usage="A symbol representing an C0 function.";
D0i::usage="A symbol representing an D0 function.";

aa0::usage="A symbol denoting a part of an A function.";

bb0::usage="A symbol denoting a part of a B function.";
bb1::usage="A symbol denoting a part of a B function.";

cc0::usage="A symbol denoting a part of a C function.";
cc1::usage="A symbol denoting a part of a C function.";
cc2::usage="A symbol denoting a part of a C function.";

dd0::usage="A symbol denoting a part of a D function.";
dd1::usage="A symbol denoting a part of a D function.";
dd2::usage="A symbol denoting a part of a D function.";
dd3::usage="A symbol denoting a part of a D function.";

Begin["`Private`"];
Options[NPointFunctionPattern] = {
   "Fields" -> _,
   "Sums" -> _,
   "ClRules" -> _,
   "CombFac" -> _,
   "ColFac" -> _,
   "Subs" -> _};
NPointFunctionPattern::usage =
Module[{Formatted},
   Formatted[num_Integer]:=
      StringJoin["\"",Part[#,1],"\" (def. ",ToString@Part[#,2],") "]&@
      Part[Options@NPointFunctionPattern,num];
   "@brief Is used to realize pattern check for NPointFunction object in
   other functions. Provides a nice way to pick required part of this object.
   Designed in a way which allows Mathematica to highlight the code correctly.
   @option "<>Formatted@1<>"allows to pick in and out fields
   @option "<>Formatted@2<>"allows to pick GenericSums
   @option "<>Formatted@3<>"allows to pick list of class replacements
   @option "<>Formatted@4<>"allows to pick list of class combinatorical factors
   @option "<>Formatted@5<>"allows to pick list of class colour factors
   @option "<>Formatted@6<>"allows to pick abbreviations
   @note any option should have form symbolName_ or Blank[]
   @returns Pattern where option specify the stuff to pick in this calculation."
];
NPointFunctionPattern::errUnknownOptions = 
   NPointFunction::errUnknownOptions;
NPointFunctionPattern::errWrongOptionValue =
"Any option should have form symbolName_ or Blank[].";
NPointFunctionPattern::errUnknownInput = 
"Correct input has the folliwing form:
NPointFunctionPattern[options]
where
 options have names from list
  `1`.";
NPointFunctionPattern[opts:OptionsPattern[]] :=
Module[{names=Part[Options@NPointFunctionPattern,All,1],Convert},
   Convert[num_] := If[OptionValue@Part[names,num] === _,
      "",
      StringDrop[ToString@OptionValue@Part[names,num],-1] <> ":"];
   ToExpression[StringJoin[
   "{",
      Convert@1 , "{{__},{__}},",
      "{",
         "{",
            Convert@2 , "{GenericSum[_,{__}]..}," ,
            Convert@3,"{{{Rule[_,_]..}..}..}," ,
            Convert@4 , "{{__Integer}..}," ,
            Convert@5 , "{{__}..}" ,
         "}," ,
         Convert@6 , "{Rule[_,_]...}" ,
      "}" ,
   "}"]]
] /; And[
   Utils`TestWithMessage[
      FilterRules[{opts},Except@Part[Options@NPointFunctionPattern,All,1]]==={},
      NPointFunctionPattern::errUnknownOptions, 
      FilterRules[{opts},Except@Part[Options@NPointFunctionPattern,All,1]], 
      "\""<>#<>"\""&/@Part[Options@NPointFunctionPattern,All,1]],
   Utils`TestWithMessage[
      And@@Map[StringMatchQ[
         ToString@#,
         ___?(Symbol === Head@ToExpression@#&) ~~ "_"]&,
         Map[OptionValue[NPointFunctionPattern,#]&,
            Part[Options@NPointFunctionPattern,All,1]]],
      NPointFunctionPattern::errWrongOptionValue]
];
NPointFunctionPattern[___] := 
Utils`TestWithMessage[
   False,
   NPointFunctionPattern::errUnknownInput,
   "\""<>#<>"\""&/@Part[Options@NPointFunctionPattern,All,1]
];

Options[NPointFunction]={
   LoopLevel -> 1,
   Regularize -> Switch[FlexibleSUSY`FSRenormalizationScheme,
      FlexibleSUSY`DRbar, DimensionalReduction,
      FlexibleSUSY`MSbar, DimensionalRegularization],
   UseCache -> True,
   ZeroExternalMomenta -> True,
   OnShellFlag -> True,
   ExcludedTopologies -> {}
};
NPointFunction[inFields_,outFields_,opts:OptionsPattern[]] :=
Module[
   {
      loopLevel = OptionValue[LoopLevel],
      regularizationScheme = OptionValue[Regularize],
      zeroExternalMomenta = OptionValue[ZeroExternalMomenta],
      excludedTopologies = OptionValue[ExcludedTopologies],                     (*@todo is not checked yet!*)
      onShellFlag = OptionValue[OnShellFlag],
      nPointMeta = OptionValue@{LoopLevel,Regularize,ZeroExternalMomenta},
      outputDir = FileNameJoin@{
         SARAH`$sarahCurrentOutputMainDir,
         ToString@FlexibleSUSY`FSEigenstates
         },
      nPointFunctionsDir,feynArtsDir,feynArtsModel,particleNamesFile,
      particleNamespaceFile,substitutionsFile,formCalcDir,
      subKernel,
      fsMetaDir = FlexibleSUSY`$flexiblesusyMetaDir,
      currentPath, currentDirectory,
      inFANames,outFANames,
      nPointFunction
   },
   nPointFunctionsDir = FileNameJoin@{outputDir, "NPointFunctions"};            (* @unote cache saving *)
   If[!DirectoryQ@nPointFunctionsDir,CreateDirectory@nPointFunctionsDir];
   If[OptionValue@UseCache,
      nPointFunction = CachedNPointFunction[
         inFields,outFields,nPointFunctionsDir,nPointMeta];
      If[nPointFunction =!= Null, Return@nPointFunction]];
   
   feynArtsDir = FileNameJoin@{outputDir, "FeynArts"};
   feynArtsModel = FileNameJoin@{feynArtsDir, GetFAClassesModelName[]};
   particleNamesFile = FileNameJoin@{feynArtsDir, GetFAParticleNamesFileName[]};
   particleNamespaceFile = FileNameJoin@{feynArtsDir, "ParticleNamespaces.m"};
   substitutionsFile = FileNameJoin@{feynArtsDir, GetFASubstitutionsFileName[]};

   formCalcDir = FileNameJoin@{outputDir, "FormCalc"};

   If[!FileExistsQ[feynArtsModel <> ".mod"],
      subKernel = LaunchSubkernelFor@"creation of FeynArts model file";
      GenerateFAModelFileOnKernel@subKernel;                                    (*generates .dat .mod .m files insiide FeynArts directory*)
      WriteParticleNamespaceFile@particleNamespaceFile;
      CloseKernels@subKernel;
   ];

   subKernel = LaunchSubkernelFor@"FormCalc code generation";
   
   inFANames = FANamesForFields[inFields, particleNamesFile];
   outFANames = FANamesForFields[outFields, particleNamesFile];

   currentPath = $Path;
   currentDirectory = Directory[];
   DistributeDefinitions[currentPath, currentDirectory,
      fsMetaDir, feynArtsDir, formCalcDir, feynArtsModel,
      particleNamesFile, substitutionsFile, particleNamespaceFile,
      inFANames, outFANames, loopLevel, regularizationScheme,
      zeroExternalMomenta, excludedTopologies, onShellFlag];

   nPointFunction = ParallelEvaluate[
      $Path = currentPath;
      SetDirectory@currentDirectory;

      Get@FileNameJoin@{fsMetaDir, "NPointFunctions", "internal.m"};

      NPointFunctions`SetFAFCPaths[feynArtsDir, formCalcDir, feynArtsModel,
         particleNamesFile, substitutionsFile, particleNamespaceFile];

      NPointFunctions`NPointFunctionFAFC[
         ToExpression@inFANames, ToExpression@outFANames,
         LoopLevel -> loopLevel,
         Regularize -> regularizationScheme,
         ZeroExternalMomenta -> zeroExternalMomenta,
         ExcludedTopologies -> excludedTopologies,
         OnShellFlag -> onShellFlag],
      subKernel
   ];

   CloseKernels[subKernel];

   Utils`AssertWithMessage[nPointFunction =!= $Failed,
      NPointFunction::errCalc];

   If[OptionValue@UseCache,
      CacheNPointFunction[nPointFunction,nPointFunctionsDir,nPointMeta]];

   nPointFunction
] /; And[
   MatchQ[inFields,
   {_?(Utils`TestWithMessage[
         TreeMasses`IsParticle@#,
         NPointFunction::errinFields,
         #,
         GetSARAHModelName[],
         Cases[TreeMasses`GetParticles[], 
            _?TreeMasses`IsScalar|_?TreeMasses`IsFermion]                       (*@todo add |_?TreeMasses`IsVector*)
      ]&)
   ..}
   ],
   MatchQ[outFields,
   {_?( Utils`TestWithMessage[
         TreeMasses`IsParticle@#,
         NPointFunction::erroutFields,
         #,
         GetSARAHModelName[],
         Cases[TreeMasses`GetParticles[], 
            _?TreeMasses`IsScalar|_?TreeMasses`IsFermion]                       (*@todo add |_?TreeMasses`IsVector*)
      ]& )
   ..}
   ],
   Utils`TestWithMessage[
      FilterRules[{opts},Except@Part[Options@NPointFunction,All,1]] === {},
      NPointFunction::errUnknownOptions,
      FilterRules[{opts},Except@Part[Options@NPointFunction,All,1]],
      Part[Options@NPointFunction,All,1]
   ],
   Utils`TestWithMessage[
      OptionValue@LoopLevel === 1,
      NPointFunction::errLoopLevel
   ],
   Utils`TestWithMessage[
      MemberQ[{DimensionalReduction, DimensionalRegularization}, 
         OptionValue@Regularize],
      NPointFunction::errRegularize,
      OptionValue@Regularize
   ],
   Utils`TestWithMessage[
      OptionValue@UseCache === True ||
      OptionValue@UseCache === False,
      NPointFunction::errUseCache
   ],
   Utils`TestWithMessage[
      OptionValue@ZeroExternalMomenta === True ||
      OptionValue@ZeroExternalMomenta === False,
      NPointFunction::errZeroExternalMomenta
   ],
   Utils`TestWithMessage[
      OptionValue@OnShellFlag === True ||
      OptionValue@OnShellFlag === False,
      NPointFunction::errOnShellFlag
   ],
   Utils`TestWithMessage[
      And@@Map[
         MemberQ[{OneParticleReducible,ExceptBoxes,ExceptTriangles,Null},#]&,
         If[Head@#===List,#,{#}]&@OptionValue@ExcludedTopologies
      ],
      NPointFunction::errExcludedTopologies
   ],
   Utils`TestWithMessage[                                                       (* @todo modify this in future*)
      And @@ (TreeMasses`IsScalar@# || TreeMasses`IsFermion@# &/@               (**)
      Join[inFields,outFields] ),                                               (**)
      NPointFunction::errInputFields                                            (**)
   ]                                                                            (**)
];
NPointFunction[___] :=
Utils`TestWithMessage[
   False,
   NPointFunction::errUnknownInput,
   GetSARAHModelName[],
   Cases[TreeMasses`GetParticles[], 
      _?TreeMasses`IsScalar|_?TreeMasses`IsFermion],                            (*@todo add |_?TreeMasses`IsVector*)
   Options[NPointFunction][[All, 1]]
];

VerticesForNPointFunction[NPointFunctionPattern[
   "Sums"->genSums_,"ClRules"->classRules_,"Subs"->substitutions_]
] :=
Module[
   {
      positionsOfVertInSubs =
         DeleteDuplicates[#[[1]] & /@ Position[substitutions, SARAH`Cp[__]]], 
      rulesWithVertices,vertsGen,GetVertex
   },
   rulesWithVertices = substitutions[[positionsOfVertInSubs]];
   GetVertex[vertGen:{{__}..},rules:{{Rule[_,_]..}..}] := vertGen/.# &/@ rules;
   vertsGen = DeleteDuplicates@Cases[#, SARAH`Cp[fields__] :> {fields},
      Infinity,Heads -> True] &/@ (genSums/.rulesWithVertices);
   DeleteDuplicates@Flatten[
      Vertices`StripFieldIndices@Thread[GetVertex[vertsGen, classRules]], 2]
];
VerticesForNPointFunction[___] :=
Utils`TestWithMessage[False,VerticesForNPointFunction::errUnknownInput];

GetSARAHModelName::usage=
"@brief Return the SARAH model name as to be passed to SARAH`.`Start[].
@returns the SARAH model name as to be passed to SARAH`.`Start[].";
GetSARAHModelName[] := 
If[SARAH`submodeldir =!= False,
      SARAH`modelDir <> "-" <> SARAH`submodeldir,
      SARAH`modelDir
];

GetFAClassesModelName::usage=
"@brief Return the model name that is used by SARAH to name the
FeynArts model file it creates.
@returns the model name that is used by SARAH to name the
FeynArts model file it creates.";
GetFAClassesModelName[] := 
   SARAH`ModelName <> ToString@FlexibleSUSY`FSEigenstates;

GetFAParticleNamesFileName::usage=
"@brief Return the file name that is used by SARAH to store 
FeynArts particle names.
@returns the file name that is used by SARAH to store 
FeynArts particle names.";
GetFAParticleNamesFileName[] := 
"ParticleNamesFeynArts.dat";

GetFASubstitutionsFileName::usage=
"@brief Return the model name that is used by SARAH to name the FeynArts 
substitution file it creates.
@returns the model name that is used by SARAH to name the
FeynArts substitution file it creates.";
GetFASubstitutionsFileName[] :=
   StringJoin["Substitutions-",SARAH`ModelName,
     ToString@FlexibleSUSY`FSEigenstates,".m"
   ];

LaunchSubkernelFor::usage=
"@brief Tries to launch a subkernel without errors.
If it fails, tries to explain the reason using message for specifying its
activity.
@param message String, which contains description of activity for which this
subkernel is launched for.
@returns subkernel name.
@note Mathematica 7 returns KernelObject[__], 11.3 returns {KernelObject[__]}
@note for Mathematica 7 some functions have the same names as in SARAH`.`";
LaunchSubkernelFor::errKernelLaunch=
"Unable to launch subkernel(s) during calculations for
`1`
because of error:";
LaunchSubkernelFor[message_String] /; $VersionNumber === 7.0 :=
Module[{kernelName},
   Off[Parallel`Preferences`add::shdw,
      Parallel`Preferences`set::shdw,
      Parallel`Preferences`list::shdw,
      Parallel`Preferences`tr::shdw,
      Parallel`Protected`processes::shdw,
      SubKernels`Description::shdw];
   kernelName = Utils`PureEvaluate[
      LaunchKernels[1],
      LaunchSubkernelFor::errKernelLaunch, message];
   On[Parallel`Preferences`add::shdw,
      Parallel`Preferences`set::shdw,
      Parallel`Preferences`list::shdw,
      Parallel`Preferences`tr::shdw,
      Parallel`Protected`processes::shdw,
      SubKernels`Description::shdw];
   kernelName
];
LaunchSubkernelFor[message_String] :=
Module[{kernelName},
   kernelName = Utils`PureEvaluate[
      LaunchKernels[1],
      LaunchSubkernelFor::errKernelLaunch, message];
   If[Head@kernelName === List, kernelName[[1]], kernelName]
];

CacheNameForMeta::usage=
"@brief Return the name of the cache file for given meta information
@param nPointMeta the given meta information
@returns the name of the cache file for given meta information.
";
CacheNameForMeta[nPointMeta_] :=
   StringJoin["cache_",Riffle[ToString /@ nPointMeta, "_"],".m"]; 

CacheNPointFunction::usage=
"@brief Write a given n-point correlation function to the cache
@param nPointFunction the given n-point correlation function
@param cacheDir the directory to save cache
@param nPointMeta the meta information about the given n-point correlation 
function";
CacheNPointFunction[nPointFunction_,cacheDir_,nPointMeta_] := 
Module[
   {
      nPointFunctionsFile = FileNameJoin@{cacheDir,CacheNameForMeta@nPointMeta},
      fileHandle,
      nPointFunctions,
      position
   },
   If[FileExistsQ@nPointFunctionsFile,
      nPointFunctions = Get@nPointFunctionsFile,
      nPointFunctions = {}
   ];
   
   position = Position[nPointFunctions[[All,1]],nPointFunction[[1]]];
   If[Length@position === 1,
      nPointFunctions[[position[[1]]]] = nPointFunction,
      AppendTo[nPointFunctions, nPointFunction]
   ];

   fileHandle = OpenWrite@nPointFunctionsFile;
   Write[fileHandle,nPointFunctions];
   Close@fileHandle;
];

CachedNPointFunction::usage=
"@brief Retrieve an n-point correlation function from the cache
@param inFields the incoming fields of the n-point correlation function
@param outFields the outgoing fields of the n-point correlation function
@param cacheDir the directory to save cache
@param nPointMeta the meta information of the n-point correlation function
@returns the corresponding n-point correalation function from the
cache or `Null` if such a function could not be found.
";
CachedNPointFunction[inFields_,outFields_,cacheDir_,nPointMeta_] := 
Module[
   {
      nPointFunctionsFile = FileNameJoin@{cacheDir,CacheNameForMeta@nPointMeta}, 
      nPointFunctions, 
      position
   },
   If[!FileExistsQ@nPointFunctionsFile,Return@Null];
   nPointFunctions = Get@nPointFunctionsFile;
   position = Position[Vertices`StripFieldIndices[ nPointFunctions[[All,1]] ],
      {inFields, outFields}];
   If[Length@position == 1,nPointFunctions[[ position[[1,1]] ]],Null]
];

GenerateFAModelFileOnKernel::usage=
"@brief Generate the FeynArts model file on a given subkernel.";
GenerateFAModelFileOnKernel[kernel_Parallel`Kernels`kernel] :=
Module[
   {
      currentPath = $Path, 
      currentDir = Directory[],
      fsMetaDir = $flexiblesusyMetaDir,
      sarahInputDirs = SARAH`SARAH@SARAH`InputDirectories,
      sarahOutputDir = SARAH`SARAH@SARAH`OutputDirectory,
      SARAHModelName = GetSARAHModelName[], 
      eigenstates = FlexibleSUSY`FSEigenstates
   },
   DistributeDefinitions[currentPath, currentDir, fsMetaDir, sarahInputDirs, 
      sarahOutputDir, SARAHModelName, eigenstates];
      
   ParallelEvaluate[
      $Path = currentPath;
      SetDirectory@currentDir;
      Get@FileNameJoin@{fsMetaDir, "NPointFunctions", "createFAModelFile.m"};
      NPointFunctions`CreateFAModelFile[sarahInputDirs,sarahOutputDir,
         SARAHModelName, eigenstates];,
      kernel];
]

WriteParticleNamespaceFile::usage=
"@brief Write a file containing all field names and the contexts in which they 
live in Mathematica.
@note This is necessary because SARAH puts fields into different contexts.";
WriteParticleNamespaceFile[fileName_String] :=
Module[{fileHandle = OpenWrite@fileName},
   Write[fileHandle, {ToString@#, Context@#} & /@ TreeMasses`GetParticles[]];
   Close@fileHandle;
];

FANamesForFields::usage=
"@brief Translate SARAH-style fields to FeynArts-style fields
@param fields List of SARAH-style fields
@param particleNamesFile the path to the SARAH-created FeynArts
particle names file.
@returns A list of the FeynArts names (as strings) for the given
SARAH-style fields.";
FANamesForFields::errSARAH=
"NpointFunctions`.`Private`.`FANamesForFields[]: SARAH`.`:
It seems that SARAH`.` has changed conventions for
<ParticleNames>.dat file.";
FANamesForFields[fields_,particleNamesFile_String] :=
Module[
   {
      uniqueFields = DeleteDuplicates[
         CXXDiagrams`RemoveLorentzConjugation@# &/@ fields],
      faFieldNames
   },
   faFieldNames = 
   Flatten[
      StringCases[Utils`ReadLinesInFile@particleNamesFile, 
         ToString@# ~~ ": " ~~ x__ ~~ "]" ~~ ___ :> "FeynArts`" <> x <> "]"
      ] & /@ uniqueFields
   ];
   Utils`AssertWithMessage[Length@faFieldNames > 0, 
      FANamesForFields::errSARAH];
      
   fields /. MapThread[Rule, {uniqueFields, faFieldNames}] /. 
      {
         SARAH`bar@field_String :> "-" <> field, 
         Susyno`LieGroups`conj@field_String :> "-" <> field
      }
]

Options[CreateCXXHeaders]={
   LoopFunctions -> "FlexibleSUSY",
   UseWilsonCoeffs -> True
};
CreateCXXHeaders[opts:OptionsPattern[]] :=
Module[
   {
      mainHPP = "\"cxx_qft/" <> FlexibleSUSY`FSModelName <>
         If[OptionValue@UseWilsonCoeffs,
            "_npointfunctions_wilsoncoeffs.hpp\"",
            "_npointfunctions.hpp\""],
      loopHPP = Switch[OptionValue@LoopFunctions,
         "LoopTools","<clooptools.h>",
         "FlexibleSUSY","\"numerics.h\""]
   },
   "#include " <> mainHPP <> "\n" <>
   "#include \"concatenate.hpp\"\n" <>
   "#include <boost/fusion/include/at_key.hpp>" <> "\n" <>
   "#include " <> loopHPP
] /; And[
   Utils`TestWithMessage[
      FilterRules[{opts},Except@Part[Options@CreateCXXHeaders,All,1]] === {},
      CreateCXXHeaders::errUnknownOptions,
      FilterRules[{opts},Except@Part[Options@CreateCXXHeaders,All,1]],
      Part[Options@CreateCXXHeaders,All,1]
   ],
   Utils`TestWithMessage[
      MemberQ[{"LoopTools", "FlexibleSUSY"}, OptionValue@LoopFunctions],
      CreateCXXHeaders::errLoopFunctions,
      OptionValue@LoopFunctions
   ],
   Utils`TestWithMessage[
      OptionValue@UseWilsonCoeffs === True ||
      OptionValue@UseWilsonCoeffs === False,
      CreateCXXHeaders::errUseWilsonCoeffs
   ]
];
CreateCXXHeaders[___] := 
Utils`TestWithMessage[False,CreateCXXHeaders::errUnknownInput,
   Options[CreateCXXHeaders][[All, 1]]];

Options[CreateCXXFunctions]={
   LoopFunctions -> "FlexibleSUSY",
   FermionBasis -> {}
};
CreateCXXFunctions[nPointFunctions_List, names_List,
    colourFactorProjections_,OptionsPattern[]] :=
  Module[{loopFunctionRules, prototypes,
          definitionHeads, definitionBodies,
          auxilliaryClasses, definitions,
          internalFermionBasis = OptionValue[FermionBasis]},
    loopFunctionRules = Switch[OptionValue[LoopFunctions],
      "LoopTools", {},
      "FlexibleSUSY",
         Print["Warning: Using FlexibleSUSY loop functions will only remap A0, B0, C0, C00, D0 and D00."];
         Print["Warning: FlexibleSUSY loop functions C0, D0 and D00 require zero external momenta."];
         {
           LoopTools`A0i[LoopTools`aa0, args__] :> "softsusy::a0"[Sequence @@ ("std::sqrt" /@ List[args]),
                                             "context.scale()"],
           LoopTools`A0[arg_] :> "softsusy::a0"[Sequence @@ ("std::sqrt" /@ List[arg]),
                                             "context.scale()"],
           LoopTools`B0i[LoopTools`bb0, args__] :> "softsusy::b0"[Sequence @@ ("std::sqrt" /@ List[args]),
                                             "context.scale()"],
           LoopTools`B0i[LoopTools`bb1, args__] :> "(-1)*softsusy::b1"[Sequence @@ (Map[Sqrt, List[args]] /. Sqrt[(Mass[x___])^2] :> Mass[x]),
                                             "context.scale()"],
           LoopTools`C0i[LoopTools`cc0, 0, 0, 0, args__] :> "softsusy::c0"[Sequence @@ ("std::sqrt" /@ List[args])],
           LoopTools`C0i[LoopTools`cc00, 0, 0, 0, args__] :> "softsusy::c00"[Sequence @@ ("std::sqrt" /@ List[args]), "context.scale()"],
           LoopTools`D0i[LoopTools`dd0, 0, 0, 0, 0, 0, 0, args__] :> "softsusy::d0"[Sequence @@ ("std::sqrt" /@ List[args])],
           LoopTools`D0i[LoopTools`dd00, 0, 0, 0, 0, 0, 0, args__] :> "softsusy::d27"[Sequence @@ (Map[Sqrt, List[args]] /. Sqrt[(x___)^2] :> x)]
         },
       _, Return["Option LoopFunctions must be either LoopTools or FlexibleSUSY"]];

    prototypes = StringJoin[Riffle[
      "std::complex<double> " <>Part[#,2]<>"("<>CXXArgStringNPF@Part[#,1]<>");" &/@
      Transpose[{nPointFunctions, names}], "\n"]];
    
    If[Length[internalFermionBasis] === 0,
      definitionHeads = "std::complex<double> " <> #[[2]] <>
          CXXArgStringForNPointFunctionDefinition[#[[1]]] & /@
        Transpose[{nPointFunctions, names}],
      definitionHeads = "std::array<std::complex<double>, " <> ToString[Length[internalFermionBasis]] <> "> "
          <> #[[2]] <>
          CXXArgStringForNPointFunctionDefinition[#[[1]]] & /@
        Transpose[{nPointFunctions, names}]
    ];
      
    definitionBodies = CXXBodyForNPointFunction /@ nPointFunctions;
    If[Length[internalFermionBasis] === 0,
      auxilliaryClasses = CXXClassForNPointFunction[Sequence @@ #] & /@
        Transpose[{
          nPointFunctions /. loopFunctionRules,
          If[Head[colourFactorProjections] === List,
            colourFactorProjections,
            Table[colourFactorProjections, {Length[names]}]]
        }],
      auxilliaryClasses = CXXClassForNPointFunction[Sequence @@ #, FermionBasis -> internalFermionBasis] & /@
        Transpose[{
          nPointFunctions /. loopFunctionRules,
          If[Head[colourFactorProjections] === List,
            colourFactorProjections,
            Table[colourFactorProjections, {Length[names]}]]
        }]
    ];

    definitions = StringJoin[Riffle[auxilliaryClasses,"\n\n"]] <> "\n\n" <>
      StringJoin[Riffle[#[[1]] <> "\n{\n" <> #[[2]] <> "\n}" & /@
         Transpose[{definitionHeads, definitionBodies}], "\n\n"]];

    {prototypes, definitions}
  ]
Options[CreateCXXFunctionsNew]={
   LoopFunctions -> "FlexibleSUSY",
   FermionBasis -> {}
};
CreateCXXFunctionsNew[nPointFunctions_, names_,colourFactorProjections_, opts:OptionsPattern[]] :=
Module[
   {
      loopFunctionRules = Switch[OptionValue@LoopFunctions,
         "LoopTools", {},
         "FlexibleSUSY", GetLTToFSRules[]],
      prototypes,
      definitionHeads,
      definitionBodies,
      auxilliaryClasses,
      definitions,
      internalFermionBasis = OptionValue[FermionBasis]
   },
   prototypes = StringJoin@Riffle[Map[
      "std::complex<double> "<>Part[#,1]<>"("<>CXXArgStringNPF@Part[#,2]<>");"&,
      Transpose@{names,nPointFunctions}
      ],"\n"];
   
    If[Length[internalFermionBasis] === 0,
      definitionHeads = "std::complex<double> " <> #[[2]] <>
          CXXArgStringForNPointFunctionDefinition[#[[1]]] & /@
        Transpose[{nPointFunctions, names}],
      definitionHeads = "std::array<std::complex<double>, " <> ToString[Length[internalFermionBasis]] <> "> "
          <> #[[2]] <>
          CXXArgStringForNPointFunctionDefinition[#[[1]]] & /@
        Transpose[{nPointFunctions, names}]
    ];
      
    definitionBodies = CXXBodyForNPointFunction /@ nPointFunctions;
    If[Length[internalFermionBasis] === 0,
      auxilliaryClasses = CXXClassForNPointFunction[Sequence @@ #] & /@
        Transpose[{
          nPointFunctions /. loopFunctionRules,
          If[Head[colourFactorProjections] === List,
            colourFactorProjections,
            Table[colourFactorProjections, {Length[names]}]]
        }],
      auxilliaryClasses = CXXClassForNPointFunction[Sequence @@ #, FermionBasis -> internalFermionBasis] & /@
        Transpose[{
          nPointFunctions /. loopFunctionRules,
          If[Head[colourFactorProjections] === List,
            colourFactorProjections,
            Table[colourFactorProjections, {Length[names]}]]
        }]
    ];

    definitions = StringJoin[Riffle[auxilliaryClasses,"\n\n"]] <> "\n\n" <>
      StringJoin[Riffle[#[[1]] <> "\n{\n" <> #[[2]] <> "\n}" & /@
         Transpose[{definitionHeads, definitionBodies}], "\n\n"]];

    {prototypes, definitions}
] /; And[
   MatchQ[nPointFunctions,
      {_?(Utils`TestWithMessage[
         MatchQ[#,NPointFunctionPattern[]],
         CreateCXXFunctions::errnPointFunctions,
         #]&)
      ..}],
   MatchQ[names,
      {_?(Utils`TestWithMessage[
         StringQ@#,
         CreateCXXFunctions::errnames,
         #]&)
      ..}],
   Utils`TestWithMessage[
      Length@nPointFunctions===Length@names,
      CreateCXXFunctions::errUnequalLength],
   (*@todo check for colourFactorProjections*)
   Utils`TestWithMessage[
      FilterRules[{opts},Except@Part[Options@CreateCXXFunctions,All,1]] === {},
      CreateCXXFunctions::errUnknownOptions,
      FilterRules[{opts},Except@Part[Options@CreateCXXFunctions,All,1]],
      Part[Options@CreateCXXFunctions,All,1]],
   Utils`TestWithMessage[
      MemberQ[{"LoopTools", "FlexibleSUSY"}, OptionValue@LoopFunctions],
      CreateCXXFunctions::errLoopFunctions,
      OptionValue@LoopFunctions]
   (*@todo check for FermionBasis*)
];
CreateCXXFunctions[___] := 
Utils`TestWithMessage[False,CreateCXXFunctions::errUnknownInput,
   Options[CreateCXXFunctions][[All, 1]]];

GetLTToFSRules::usage=
"@brief returns rules for LoopTools to FlexibleSUSY conventions
@returns rules for LoopTools to FlexibleSUSY conventions
@todo add specific rules for std::sqrt(0)
@todo add specific rules for std::sqrt(Sqr())";
GetLTToFSRules[] :=
Module[{},
   Print["Warning: Only remaps of A0, B0, C0, C00, D0 and D00 are implemented"];
   Print["Warning: FlexibleSUSY C0, D0 and D00 require zero external momenta."];
   {
      LoopTools`A0i[LoopTools`aa0, args__] :>
         "softsusy::a0"[Apply[Sequence,"std::sqrt"/@{args}],"context.scale()"],
      LoopTools`A0[arg_] :>
         "softsusy::a0"[Apply[Sequence,"std::sqrt"/@{arg}],"context.scale()"],
      LoopTools`B0i[LoopTools`bb0, args__] :>
         "softsusy::b0"[Apply[Sequence,"std::sqrt" /@ {args}],"context.scale()"],
      LoopTools`B0i[LoopTools`bb1, args__] :>
         "(-1)*softsusy::b1"[Apply[Sequence,Map[Sqrt, {args}] /. Sqrt[(Mass@x___)^2] :> Mass@x],"context.scale()"],
      LoopTools`C0i[LoopTools`cc0, 0, 0, 0, args__] :>
         "softsusy::c0"[Apply[Sequence,"std::sqrt" /@ {args}]],
      LoopTools`C0i[LoopTools`cc00, 0, 0, 0, args__] :>
         "softsusy::c00"[Apply[Sequence,"std::sqrt" /@ {args}], "context.scale()"],
      LoopTools`D0i[LoopTools`dd0, 0, 0, 0, 0, 0, 0, args__] :>
         "softsusy::d0"[Apply[Sequence,"std::sqrt" /@ {args}]],
      LoopTools`D0i[LoopTools`dd00, 0, 0, 0, 0, 0, 0, args__] :>
         "softsusy::d27"[Apply[Sequence,Map[Sqrt, {args}] /. Sqrt[(x___)^2] :> x]]
   }
];

CXXArgStringNPF::usage=
"@brief Return the c++ arguments that the c++ version of the given n-point 
correlation function shall take. Default value of zero for all external
momenta is chosen.
@param nPointFunction the given n-point correlation function
@returns the c++ arguments that the c++ version of the given
n-point correlation function shall take. Default value of zero for all external
momenta is chosen.";
CXXArgStringNPF::errUnknownInput=
"Input @param should be NPointFunction object";
CXXArgStringNPF[nPointFunction:NPointFunctionPattern[]] :=
Module[
   {
      numInd = Length@ExternalIndicesNPF@nPointFunction,
      numMom = Length@ExternalMomentaNPF@nPointFunction,
      eigenType = FlexibleSUSY`FSModelName<>"_mass_eigenstates",
      arrayIndType,arrayMomType,momDef
   },
   arrayIndType = "std::array<int,"<>ToString@numInd<>">";
   arrayMomType = "std::array<Eigen::Vector4d,"<>ToString@numMom<>">";
   momDef = StringJoin@Riffle[Table["Eigen::Vector4d::Zero()",{numMom}],", "];
   "const "<>eigenType<>" &model, " <>
   "const "<>arrayIndType<>" &indices, "<>
   "const "<>arrayMomType<>" &momenta = { "<>momDef<>" }"
];
CXXArgStringNPF[___] :=
   Utils`TestWithMessage[False,CXXArgStringNPF::errUnknownInput];

ExternalIndicesNPF::usage=
"@brief Return a list of open field indices for a given NPointFunction object.
@param NPointFunction object
@returns a list of the open field indices for a given NPointFunction object.";
ExternalIndicesNPF::errUnknownInput=
   CXXArgStringNPF::errUnknownInput;
ExternalIndicesNPF[NPointFunctionPattern["Fields"->fields_]] :=
   DeleteDuplicates@Flatten@Level[fields,{4,5}];
ExternalIndicesNPF[___] :=
   Utils`TestWithMessage[False,ExternalIndicesNPF::errUnknownInput];

ExternalMomentaNPF::usage=
"@brief Return a list of external momenta for a given NPointFunction object.
@param NPointFunction object
@returns a list of the open field indices for a given NPointFunction object.";
ExternalMomentaNPF::errUnknownInput=
   CXXArgStringNPF::errUnknownInput;
ExternalMomentaNPF[NPointFunctionPattern["Sums"->sums_,"Subs"->subs_]] :=
   DeleteDuplicates@
      Cases[{sums,subs},HoldPattern@SARAH`Mom[_Integer,___],Infinity];
ExternalMomentaNPF[___] :=
   Utils`TestWithMessage[False,ExternalMomentaNPF::errUnknownInput];

SetAttributes[
   {
   NPointFunctionPattern,NPointFunction,
   GetSARAHModelName,
   GetFAClassesModelName, GetFAParticleNamesFileName, GetFASubstitutionsFileName,
   LaunchSubkernelFor,
   CacheNameForMeta,CacheNPointFunction,CachedNPointFunction,
   GenerateFAModelFileOnKernel,WriteParticleNamespaceFile,
   FANamesForFields,
   VerticesForNPointFunction,
   CreateCXXHeaders,
   CreateCXXFunctions,
   GetLTToFSRules,
   CXXArgStringNPF,ExternalIndicesNPF,ExternalMomentaNPF
   }, 
   {Protected, Locked}];

CXXArgStringForNPointFunctionDefinition::usage="
@brief Return the c++ arguments that the c++ version of the given
n-point correlation function shall take without default values for
the arguments.
@param nPointFunction the given n-point correlation function
@returns the c++ arguments that the c++ version of the given
n-point correlation function shall take without default values for
the arguments.
";
CXXArgStringForNPointFunctionDefinition[nPointFunction_] :=
  Module[{numberOfIndices, numberOfMomenta},
    numberOfIndices = Length@ExternalIndicesNPF@nPointFunction;
    numberOfMomenta = Length@ExternalMomentaNPF@nPointFunction;

    "( const " <> FlexibleSUSY`FSModelName <> "_mass_eigenstates &model, const std::array<int, " <>
      ToString[numberOfIndices] <> "> &indices, const std::array<Eigen::Vector4d, " <>
      ToString[numberOfMomenta] <> "> &momenta )"
  ]

CXXBodyForNPointFunction::usage="
@brief Return the c++ code for the function body of the c++
version of a given n-point correlation function.
@param nPointFunction the given n-point correlation function
@returns the c++ code for the function body of its c++
version.
";
CXXBodyForNPointFunction[nPointFunction_] :=
  Module[{},
    CXXClassNameForNPointFunction[nPointFunction] <>
      " helper{ model, indices, momenta };\n" <>
    "return helper.calculate();"
  ]

CXXClassForNPointFunction::usage="
@brief Return the c++ code for the helper class of the c++
version of a given n-point correlation function.
@param nPointFunction the given n-point correlation function
@param projectColourFactor the colour factor projection to be
applied for the given n-point correlation function
@returns the c++ code for the helper class of the c++
version of a given n-point correlation function.
";
CXXClassForNPointFunction[nPointFunction_, projectColourFactor_,
    OptionsPattern[{FermionBasis -> {}}]] :=
  Module[{className = CXXClassNameForNPointFunction[nPointFunction],
          externalIndices, cxxCorrelationContext,
          numberOfIndices, numberOfMomenta, genericSumPositions,
          genericIndices, genericFields, genericSumNames,
          genericSumCode, preCXXRules, cxxExpr,
          subexpressions, cxxSubexpressions, InitializeSums},
    externalIndices = ExternalIndicesNPF@nPointFunction;
    numberOfIndices = Length@externalIndices;
    numberOfMomenta = Length@ExternalMomentaNPF@nPointFunction;
    genericSumPositions = Position[nPointFunction[[2,1,1]], GenericSum[__]];
    genericIndices = DeleteDuplicates[Flatten[
      Extract[nPointFunction[[2,1,1]], genericSumPositions][[All,2]], 1]];
    genericFields = #[[1]][GenericIndex[#[[2]]]] & /@ genericIndices;
    genericSumNames = Table["genericSum" <> ToString[k],
                            {k,Length[genericSumPositions]}];
    InitializeSums = Table["const auto genericsum" <> ToString[k] <> " = " <>
      genericSumNames[[k]] <> "();\n", {k, Length[genericSumPositions]}];


    subexpressions = nPointFunction[[2,2]];
    preCXXRules = ToCXXPreparationRules[
      externalIndices, genericFields, subexpressions];

    cxxSubexpressions = 
      CXXCodeForSubexpressions[subexpressions, preCXXRules];
    
    If[Length[OptionValue[FermionBasis]] === 0,
    genericSumCode = StringJoin[Riffle[
      CXXCodeForGenericSum[Sequence @@ #, subexpressions, preCXXRules] & /@
        Transpose[{
          Extract[nPointFunction[[2,1,1]], genericSumPositions],
          Extract[nPointFunction[[2,1,2]], genericSumPositions],
          Extract[nPointFunction[[2,1,3]], genericSumPositions],
          ExtractColourFactor[#, projectColourFactor]& /@
            Extract[nPointFunction[[2,1,4]], genericSumPositions],
          genericSumNames}],
      "\n\n"]],
    genericSumCode = StringJoin[Riffle[
      CXXCodeForGenericSum[Sequence @@ #, subexpressions, preCXXRules, FermionBasis -> OptionValue[FermionBasis]] & /@
        Transpose[{
          Extract[nPointFunction[[2,1,1]], genericSumPositions],
          Extract[nPointFunction[[2,1,2]], genericSumPositions],
          Extract[nPointFunction[[2,1,3]], genericSumPositions],
          ExtractColourFactor[#, projectColourFactor]& /@
            Extract[nPointFunction[[2,1,4]], genericSumPositions],
          genericSumNames}],
      "\n\n"]]
    ];
    
    If[Length[OptionValue[FermionBasis]] === 0,
      cxxExpr = Plus @@ ReplacePart[nPointFunction[[2,1,1]],
        Rule @@@ Transpose[{genericSumPositions, # <> "()" & /@ genericSumNames}]],
      cxxExpr = Plus @@ ReplacePart[nPointFunction[[2,1,1]],
        Rule @@@ Transpose[{genericSumPositions, # <> "().at(i)" & /@ genericSumNames}]]
    ];
    cxxExpr = Parameters`ExpressionToString[cxxExpr];
    cxxExpr = StringReplace[cxxExpr, "\"" -> ""];

    cxxCorrelationContext = "correlation_function_context<" <>
       ToString[numberOfIndices] <> ", " <> ToString[numberOfMomenta] <>
    ">";
    
    "class " <> className <> "\n" <>
    ": public " <> cxxCorrelationContext <> "\n{\n" <>
    "using generic_sum_base = " <> cxxCorrelationContext <> ";\n" <>
    "template<class GenericFieldMap> struct subexpression_base\n" <>
    ": generic_sum_base,\n" <>
    "  index_map_interface<GenericFieldMap>\n" <>
    "{\n" <> 
    "subexpression_base( const subexpression_base & ) = default;\n" <>
    "subexpression_base( const generic_sum_base &gsb, \n" <>
    "const typename field_index_map<GenericFieldMap>::type &fim )\n" <>
    ": generic_sum_base( gsb ), index_map_interface<GenericFieldMap>( fim )\n" <>
    "{}\n" <>
    "};\n\n" <>

    StringJoin[Riffle[
        "struct " <> CXXKeyOfGenericField[#] <> " {};" & /@ genericFields,
      "\n"]] <> "\n\n" <>

    cxxSubexpressions <> "\n\n" <> 
    genericSumCode <> "\n\n" <>
    "public:\n" <>
    className <> CXXArgStringForNPointFunctionDefinition[nPointFunction] <> "\n" <>
    ": " <> cxxCorrelationContext <> "{ model, indices, momenta }\n{}\n\n" <>
    If[Length[OptionValue[FermionBasis]] === 0, 
      "std::complex<double> calculate( void )\n{\nreturn " <> cxxExpr,

      "std::array<std::complex<double>, " <> ToString[Length[OptionValue[FermionBasis]]] <> "> " <>
      "calculate( void )\n{\nstd::array<std::complex<double>, " <> ToString[Length[OptionValue[FermionBasis]]] <> "> " <>
      "genericSummation;\n" <> "constexpr int coeffsLength = genericSummation.size();\n" <> InitializeSums <>
      "for ( std::size_t i=0; i<coeffsLength; i++ ) {\n" <>
      "  genericSummation.at(i) += " <> cxxExpr <> ";\n}\n" <> "return genericSummation"
    ] <>
    ";\n}" <>
    "\n};"
  ]

ToCXXPreparationRules::usage="
@brief Generate a list of rules for translating Mathematica
expressions of n-point correlation functions to c++ counterparts.
@param externalIndices the external indices of an n-point
correlation function
@param genericFields the generic fields appearing in an n-point
correlation function
@param subexpressions the list of subexpressions needed to evaluate
an n-point correlation function
@returns a list of rules for translating Mathematica
expressions of n-point correlation functions to c++ counterparts.
";
ToCXXPreparationRules[externalIndices_List, 
    genericFields_List, subexpressions_List] :=
  Module[{externalIndexRules, genericRules,
          subexprRules, massRules, couplingRules},
    externalIndexRules = Rule[#[[1]],
        "this->external_indices(" <> ToString[#[[2]]] <> ")"] & /@
      Transpose[{externalIndices, Table[k, {k, Length[externalIndices]}] - 1}];

    genericRules = Join[
      Rule[Susyno`LieGroups`conj[#], CXXNameOfGenericField[Susyno`LieGroups`conj[#]][
        CXXIndicesForField[#]]] & /@ genericFields,
      Rule[SARAH`bar[#], CXXNameOfGenericField[SARAH`bar[#]][
        CXXIndicesForField[#]]] & /@ genericFields,
      Rule[#, CXXNameOfGenericField[#][
        CXXIndicesForField[#]]] & /@ genericFields
    ];

    couplingRules = {
      SARAH`Cp[fields___][1] :>
      I * "context.vertex<" <> StringJoin[Riffle[
        If[IsGenericField[#], Head[# /. genericRules],
           CXXNameOfField[Vertices`StripFieldIndices[#],
             prefixNamespace -> "fields"]] & /@ {fields},
        ", "]] <>
      ">( lorentz_scalar{}, concatenate( " <>
        StringJoin[Riffle[CXXIndicesForField /@ {fields}, ", "]] <> 
      " ) )",
      SARAH`Cp[fields___][SARAH`PL] :>
      I * "context.vertex<" <> StringJoin[Riffle[
        If[IsGenericField[#], Head[# /. genericRules],
           CXXNameOfField[Vertices`StripFieldIndices[#],
             prefixNamespace -> "fields"]] & /@ {fields},
        ", "]] <>
      ">( lorentz_left{}, concatenate( " <>
        StringJoin[Riffle[CXXIndicesForField /@ {fields}, ", "]] <> 
      " ) )",
      SARAH`Cp[fields___][SARAH`PR] :>
      I * "context.vertex<" <> StringJoin[Riffle[
        If[IsGenericField[#], Head[# /. genericRules],
           CXXNameOfField[Vertices`StripFieldIndices[#],
             prefixNamespace -> "fields"]] & /@ {fields},
        ", "]] <>
      ">( lorentz_right{}, concatenate( " <>
        StringJoin[Riffle[CXXIndicesForField /@ {fields}, ", "]] <> 
      " ) )",
      SARAH`Cp[fields___][SARAH`Mom[f1_] - SARAH`Mom[f2_]] :>
      I * "context.vertex<" <> StringJoin[Riffle[
        If[IsGenericField[#], Head[# /. genericRules],
           CXXNameOfField[Vertices`StripFieldIndices[#],
             prefixNamespace -> "fields"]] & /@ {fields},
        ", "]] <>
      ">( lorentz_momentum_diff{" <>
            ToString[Position[{fields},f1,{1},Heads->False][[1,1]]-1] <> ", " <>
            ToString[Position[{fields},f2,{1},Heads->False][[1,1]]-1] <> "}, " <>
        "concatenate( " <>
        StringJoin[Riffle[CXXIndicesForField /@ {fields}, ", "]] <> 
      " ) )",
      SARAH`Cp[fields___][SARAH`g[_,_]] :>
      I * "context.vertex<" <> StringJoin[Riffle[
        If[IsGenericField[#], Head[# /. genericRules],
           CXXNameOfField[Vertices`StripFieldIndices[#],
             prefixNamespace -> "fields"]] & /@ {fields},
        ", "]] <>
      ">( lorentz_inverse_metric{}, concatenate( " <>
        StringJoin[Riffle[CXXIndicesForField /@ {fields}, ", "]] <> 
      " ) )",
      SARAH`Cp[fields__][(SARAH`Mom[f2_, _] - SARAH`Mom[f1_, _]) * SARAH`g[_, _], (SARAH`Mom[f1_, _] - SARAH`Mom[f3_, _])SARAH`g[_, _],
        (SARAH`Mom[f3_, _] - SARAH`Mom[f2_, _]) * SARAH`g[_, _]] :>
      I * "context.vertex<" <> StringJoin[Riffle[
        If[IsGenericField[#], Head[# /. genericRules],
           CXXNameOfField[Vertices`StripFieldIndices[#],
             prefixNamespace -> "fields"]] & /@ {fields},
        ", "]] <>
        ">( triple_vector{}, concatenate( " <>
        StringJoin[Riffle[CXXIndicesForField /@ {fields}, ", "]] <>
      " ) )"
    };
    massRules = {SARAH`Mass[field_String[indices_String]] :>
      "context.mass<" <> field <> ">( " <> indices <> " )",
      SARAH`Mass[field_[{indices__}]] :>
        "context.mass<" <> "fields::" <> ToString[field] <> ">( " <>
        "std::array<int, " <> ToString[Length[{indices}]] <> "> " <>
        ToString[{indices}] <> " )"
    };
    subexprRules = Rule[#[[1]], ToString[#[[1]]] <> "_()"] & /@
      subexpressions;

    {externalIndexRules, couplingRules,
     genericRules, massRules, subexprRules}
  ]

CXXCodeForSubexpressions::usage="
@brief Create the c++ code encoding a given set of subexpressions.
@param subexpressions the list of subexpressions
@param preCXXRules a list of rules to apply to the subexpressions
before calling ``Parameters`ExpressionToString[]`` for the c++
translation.
@returns the c++ code encoding a given set of subexpressions.
";
CXXCodeForSubexpressions[subexpressions_List, preCXXRules_List] :=
  Module[{names = ToString /@ subexpressions[[All,1]],
          exprs = subexpressions[[All,2]], subexpr,
          relevantSubexpressions, relevantGenericFields,
          needsContexts, cxxExprs},
    relevantGenericFields = DeleteDuplicates /@
      (Cases[#,_[GenericIndex[_]], Infinity, Heads -> True] & /@ exprs);

    relevantSubexpressions = DeleteDuplicates /@
      (Cases[#,
        Pattern[subexpr, Alternatives @@ subexpressions[[All,1]]] :> subexpr,
          Infinity,
            Heads -> True] & /@ exprs);

    needsContexts = !(FreeQ[#, SARAH`Cp] && FreeQ[#, SARAH`Mass]) & /@ exprs;

    cxxExprs = Parameters`ExpressionToString[
      Fold[ReplaceAll, #, preCXXRules]] & /@ exprs;
    cxxExprs = StringReplace[#, "\"" -> ""] & /@ cxxExprs;

    StringJoin[Riffle[
    Module[{name = #[[1]], genericFields = #[[2]],
       subs = #[[3]], needsContext = #[[4]], cxxExpr = #[[5]]},
    "template<class GenericFieldMap> struct " <> name <>
    "\n: subexpression_base<GenericFieldMap>\n{\n" <>
    "template<class ...Args> " <> name <> "( Args &&...args )\n" <>
    ": subexpression_base<GenericFieldMap>( std::forward<Args>( args )... )\n{}\n\n" <>
    "std::complex<double> operator()( void ) const\n{\n" <>

    If[Length[subs] =!= 0,
      StringJoin[ToString[#] <> "<GenericFieldMap> " <>
        ToString[#] <> "_{ *this };\n" & /@
        subs] <> "\n",
      ""] <>

    If[Length[genericFields] =!= 0,
      "using boost::mpl::at;\n" <>
      "using boost::fusion::at_key;\n\n" <>

      StringJoin[Module[{genericField = #},
        "using " <> CXXNameOfGenericField[genericField] <>
        " = typename at<GenericFieldMap, " <>
          CXXKeyOfGenericField[genericField] <>
        ">::type;\n"
        ] & /@ genericFields] <> "\n" <>

      StringJoin[Module[{genericField = #},
        "const auto &" <> CXXIndicesForField[genericField] <>
        " = at_key<" <> CXXKeyOfGenericField[genericField] <>
          ">( this->index_map() );\n"
        ] & /@ genericFields] <> "\n",
      ""] <>

    If[needsContext,
       "const context_with_vertices &context =  *this;\n\n",
       ""] <>
    
    "return " <> cxxExpr <> ";\n}\n};"] & /@
      Transpose[{names, relevantGenericFields,
                 relevantSubexpressions, needsContexts, cxxExprs}],
    "\n\n"]]
  ]

CXXCodeForGenericSum::usage="
@brief Create the c++ code encoding a given sum over generic fields.
@param sum the sum over generic fields
@param genericInsertions the list of field insertions to be summed
over
@param combinatorialFactors a list of combinatorial factors
(~symmetry factors) to multiply the amplitudes of specific insertions
with.
@param colourFactors a list of colour factors to multiply the
amplitudes of specific insertions with.
@param functionName the name of the resulting c++ function
@param subexpressions the list of subexpressions
@param preCXXRules a list of rules to apply to the subexpressions
before calling ``Parameters`ExpressionToString[]`` for the c++
translation.
@returns the c++ code encoding the given sum over generic fields.
";
CXXCodeForGenericSum[sum_GenericSum, genericInsertions_List,
    combinatorialFactors_List, colourFactors_List, functionName_String,
    subexpressions_List, preCXXRules_List,
    OptionsPattern[{FermionBasis -> {}}]] :=
  Module[{expr = sum[[1]], indices = sum[[2]], internalFermionBasis = OptionValue[FermionBasis],
          sortedGenericInsertions, genericFields, relevantSubexpressions,
          subexpr, needsContext, cxxExpr, ReRatioColourFactors, ImRatioColourFactors,
          wilsonCoeffs},
    Utils`AssertWithMessage[NumberQ[#],
      "CXXDiagrams`CXXCodeForGenericSum[]: Projected colour factor is
not a number: " <> ToString[#]] & /@ colourFactors;
    ReRatioColourFactors = {Numerator[#], Denominator[#]} & /@ Re[colourFactors];
    ImRatioColourFactors = {Numerator[#], Denominator[#]} & /@ Im[colourFactors];

    relevantSubexpressions = DeleteDuplicates[Cases[expr,
      Pattern[subexpr, Alternatives @@ subexpressions[[All,1]]] :> subexpr,
      Infinity, Heads -> True]];

    needsContext = !(FreeQ[expr, SARAH`Cp] && FreeQ[expr, SARAH`Mass]);
    
    If[Length[internalFermionBasis] =!= 0,

      Utils`AssertWithMessage[Length[internalFermionBasis] === Length[expr],
        "CXXCodeForGenericSum[]: the length of the provided basis \
         and the coefficients does not match."
      ];
      cxxExpr = Map[Parameters`ExpressionToString[
        Fold[ReplaceAll, #, preCXXRules]]&, expr];
      cxxExpr = StringReplace[cxxExpr, "\"" -> ""];
      wilsonCoeffs = MapThread[StringJoin[#1, " += ", #2, ";\n\n"]&, {internalFermionBasis, cxxExpr}],

      cxxExpr = Parameters`ExpressionToString[
        Fold[ReplaceAll, expr, preCXXRules]];
      cxxExpr = StringReplace[cxxExpr, "\"" -> ""]
    ];
    
    genericFields = Sort[indices[[#,1]][GenericIndex[indices[[#,2]]]] & /@
      Table[k, {k,Length[indices]}]];
    sortedGenericInsertions = SortBy[#, First] & /@ genericInsertions;

    "template<class GenericFieldMap> struct " <> functionName <> "_impl\n" <>
    ": generic_sum_base\n{\n" <>
    functionName <> "_impl( const generic_sum_base &base )\n" <>
    ": generic_sum_base( base ) {} \n\n" <>
    If[Length[internalFermionBasis] === 0,
      "std::complex<double> ",
      "std::array<std::complex<double>, " <> ToString[Length[internalFermionBasis]] <> "> "
    ]
    <> "operator()( void )\n{\n" <>
    "using boost::mpl::at;\n" <>
    "using boost::fusion::at_key;\n\n" <>

    StringJoin[
      "using " <> CXXNameOfGenericField[#] <>
      " = typename at<GenericFieldMap, " <>
        CXXKeyOfGenericField[#] <>
      ">::type;\n" &
      /@ genericFields] <> "\n" <>

    "typename field_index_map<GenericFieldMap>::type index_map;\n\n" <>

    If[Length[relevantSubexpressions] =!= 0,
       StringJoin[ToString[#] <> "<GenericFieldMap> " <>
         ToString[#] <> "_{ *this, index_map };\n" & /@
         relevantSubexpressions] <> "\n",
       ""] <>

    If[needsContext,
       "const context_with_vertices &context = *this;\n",
       ""] <>
    If[Length[internalFermionBasis] === 0,
      "std::complex<double> value = 0.0;\n\n",
      Map[StringJoin["std::complex<double>", #, " = 0.0;\n"]&,
                     internalFermionBasis]
    ] <>

    StringJoin[Riffle[
      "for( const auto &" <> CXXIndicesForField[#] <> " : " <>
        "index_range<" <> CXXNameOfGenericField[#] <> ">() ) {\n" <>
      "at_key<" <> CXXKeyOfGenericField[#] <> ">( index_map ) = " <>
        CXXIndicesForField[#] <> ";" & /@
      genericFields, "\n"]] <> "\n\n" <>
    If[Length[internalFermionBasis] === 0,
      "value += " <> cxxExpr <> ";\n",
      StringJoin[wilsonCoeffs]
    ] <>
    StringJoin[Table["}",{k,Length[indices]}]] <> "\n\n" <> 

    "return " <>
    If[Length[OptionValue[FermionBasis]] === 0,
      "value;",
      ToString[internalFermionBasis] <> ";"] <>
    "\n}\n};\n\n" <>

    If[Length[OptionValue[FermionBasis]] === 0,
      "std::complex<double>",
      "std::array<std::complex<double>, 2>"]
    <> functionName <> "( void )\n{\n" <>
    "using GenericKeys = boost::mpl::vector<\n" <>
    StringJoin[Riffle[CXXKeyOfGenericField /@ genericFields, ",\n"]] <>
    "\n>;\n\n" <>

    "using GenericInsertions" <> " = boost::mpl::vector<\n" <>
    StringJoin[Riffle[
      "boost::mpl::vector<" <> StringJoin[Riffle[
          CXXDiagrams`CXXNameOfField[#, prefixNamespace -> "fields"] & /@ #, ", "]] <>
        ">" & /@ sortedGenericInsertions[[All,All,2]],
      ",\n"]] <> "\n>;\n\n" <>

    "using combinatorial_factors" <> " = boost::mpl::vector<\n" <>
    StringJoin[Riffle[
      "boost::mpl::int_<" <> ToString[#] <> ">" & /@ combinatorialFactors,
      ", "]] <> "\n>;\n" <>
    "using colour_factors" <> " = boost::mpl::vector<\n" <>
    StringJoin[Riffle[
      StringReplace["detail::complex_helper<detail::ratio_helper<"
        <> ToString[#1] <> ">, detail::ratio_helper<" <> ToString[#2] <> ">>" & @@@
        Transpose[{ReRatioColourFactors, ImRatioColourFactors}], {"{" -> "", "}" -> ""}],
      ", "]] <> "\n>;\n\n" <>

    If[Length[internalFermionBasis] =!= 0,
      "using wilsoncoeffs_length = boost::mpl::int_<" <> ToString[Length[internalFermionBasis]]  <> ">;" <>
      "return accumulate_generic<GenericKeys, GenericInsertions,\n" <>
        "combinatorial_factors, colour_factors, wilsoncoeffs_length, ",
      "return accumulate_generic<GenericKeys, GenericInsertions,\n" <>
        "combinatorial_factors, colour_factors, "]
      <> functionName <> "_impl>( *this );\n}"
  ]

CXXIndicesForField::usage="
@brief Return the c++ expression for the container of the indices
of a given (possibly generic) field.
@param field the given field
@returns the c++ expression for the container of the indices
of a given (possibly generic) field.
";
CXXIndicesForField[SARAH`bar[field_]] := CXXIndicesForField[field]
CXXIndicesForField[Susyno`LieGroups`conj[field_]] := CXXIndicesForField[field]
CXXIndicesForField[head_[GenericIndex[index_Integer]]] := 
  "indices" <> StringTake[SymbolName[head],-1] <> ToString[index]
CXXIndicesForField[field_] :=
  If[Length[field] === 0, "std::array<int, 0>()",
     "std::array<int, " <> ToString[Length[field[[1]]]] <> ">{ " <>
       StringJoin[Riffle[ToString /@ field[[1]], ", "]] <> " }"]

IsGenericField::usage="
@brief Determine whether a given field is a generic or a concrete
one.
@param field the given field
@returns `True` if the given field is generic and `False` otherwise.
";
IsGenericField[field_] :=
  Module[{head = Head[CXXDiagrams`RemoveLorentzConjugation[field]]},
    Switch[head,
           GenericS, True, 
           GenericF, True, 
           GenericV, True, 
           GenericU, True, 
           _, False]
  ] 

ExtractColourFactor::usage="
@brief Extracts the colour factor for a given colour structure like 
  e.g, Delta[ct1, ct2].
";
ExtractColourFactor[colourfactors_List, projection_] :=
  If[projection === Identity,
    Identity /@ colourfactors,
    Coefficient[#, projection]& /@ colourfactors
  ]

CXXKeyOfGenericField::usage="
@brief Given a generic field, determine its key type used in the c++
code to uniquely label it.
@param genericField the given generic field
@returns its c++ key type.
";
CXXKeyOfGenericField[head_[GenericIndex[index_Integer]]] :=
  ToString[head] <> ToString[index] <> "Key"

CXXNameOfGenericField::usage="
@brief Given a (possibly conjugated) generic field,
return its c++ type.
@param genericField the given generic field
@returns its c++ type.
";
CXXNameOfGenericField[head_[GenericIndex[index_Integer]]] :=
  ToString[head] <> ToString[index]
CXXNameOfGenericField[SARAH`bar[field_]] :=
  "typename bar<" <> CXXNameOfGenericField[field] <> ">::type";
CXXNameOfGenericField[Susyno`LieGroups`conj[field_]] :=
  "typename conj<" <> CXXNameOfGenericField[field] <> ">::type";

CXXClassNameForNPointFunction::usage="
@brief Return the c++ name for the helper class of the c++
version of a given n-point correlation function.
@param nPointFunction the given n-point correlation function
@returns the c++ name for the helper class of the c++
version of a given n-point correlation function.
";
CXXClassNameForNPointFunction[nPointFunction_] :=
  Module[{fields},
    fields = Vertices`StripFieldIndices[
      Join[nPointFunction[[1,1]], nPointFunction[[1,2]]]];
    "nPoint" <> StringJoin[ToString /@ Flatten[fields //. a_[b_] :> {a,b}]]
  ]

GenericFieldType::usage="
@brief Determine the generic field type of a given field.
@param field the given field
@returns the generic type of the given generic field.
";
GenericFieldType[field_] :=
  Module[{head = CXXDiagrams`AtomHead[CXXDiagrams`RemoveLorentzConjugation[field]]},
    Switch[head,
           GenericS, GenericS,
           GenericF, GenericF,
           GenericV, GenericV,
           GenericU, GenericU,
           GenericT, GenericT,
           _, If[TreeMasses`IsScalar[head],GenericS,
                 If[TreeMasses`IsFermion[head],GenericF,
                    If[TreeMasses`IsVector[head],GenericV,
                      If[TreeMasses`IsGhost[head],GenericU,
                         "unrecognized field type " <> ToString[head]]]]]]

  ]
  
End[];
EndPackage[];
