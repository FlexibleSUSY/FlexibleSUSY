(* ::Package:: *)

(* :Copyright:

   ====================================================================
   This file is part of FlexibleSUSY.

   FlexibleSUSY is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published
   by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   FlexibleSUSY is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with FlexibleSUSY.  If not, see
   <http://www.gnu.org/licenses/>.
   ====================================================================

*)

(* There is a problem with Global`args which comes from mathematica paclets.*)
Quiet[Needs["FeynArts`"], {FeynArts`args::shdw}];
(* Change this to 2 to see more output (if 1 then less). *)
FeynArts`$FAVerbose = 0;

Needs["FormCalc`"];
(* Change this to 1,2 or 3 to see more output. *)
FormCalc`$FCVerbose = 0;

(* Next Format makes some pattern generate mistakes. *)
Format[FormCalc`DiracChain[FormCalc`Private`s1_FormCalc`Spinor,FormCalc`Private`om_,FormCalc`Private`g___,FormCalc`Private`s2_FormCalc`Spinor]] =.;
Needs["Utils`"];

BeginPackage["NPointFunctions`"];

{SetInitialValues, NPointFunctionFAFC}

Off[General::shdw];
{Irreducible, Triangles} ~ SetAttributes ~ {Protected, Locked};
On[General::shdw];

{
   LorentzIndex, GenericSum, GenericIndex,
   GenericS, GenericF, GenericV, GenericU,
   LoopLevel, Regularize, ZeroExternalMomenta, OnShellFlag, KeepProcesses,
   DimensionalReduction, DimensionalRegularization, OperatorsOnly, ExceptLoops,
   FourFermionScalarPenguins,
   FourFermionMassiveVectorPenguins, FourFermionFlavourChangingBoxes
} ~ SetAttributes ~ {Locked,Protected};

Begin["`internal`"];

`settings`topologyReplacements::usage = "
@brief A set of rules for exclude topologies routines used inside
       FeynArts`CreateTopologies.";

`settings`diagrams::usage = "
@brief A function, which becomes a set of settings, after acting on set of
       diagrams, generated by FeynArts`InsertFields. Allows to remove/simplify
       this set. The structure is the following: `List' of `Rule's, each of them
       is a `keepProcesses' element on lhs, and the `List' of two elements on
       the rhs. The first one represents the set of actions, which should be
       performed in the case, when `keepProcesses' contains lhs element, while
       the second one - the set of actions for the absence of the lhs element.
       Each of these elements has four entries: 1) a topologyQ function, 2) a
       two-argument function, which acts on generic level of insertions and
       the expression, which is used for the selection criteria, 3) a selection
       criteria, appropriate for the used two-argument function, 4) a `String'
       message to be printed after the application of the rule.
@param ds A set of diagrams, generated by FeynArts`InsertFields.
@returns A set of settings.";

`settings`diagrams::usage = "
@brief A set of settings used for modifications of diagrams and amplitudes after
       the usage of FeynArts`CreateFeynAmp. Allows to remove/simplify this set.
       Was created for modification of class insertions.
       The structure is the following: `List' of `Rule's, each of them
       is a `keepProcesses' element on lhs, and the `List' of two elements on
       the rhs. The first one represents the set of actions, which should be
       performed in the case, when `keepProcesses' contains lhs element, having
       in mind 'keep if the action is true'. The second one - the set of actions
       for the absence of the lhs element.
       Each of these elements has three entries: 1) a topologyQ function, 2) a
       list of three elements: some class variable, two-argument function, entry
       to compare with, 3) a `String' message to be printed after the rule is
       applied.";

`directory`internal::usage = "
@brief A `String' variable, containing the directory name of `internal.m' file.";
`directory`internal = DirectoryName@FindFile@$Input;
`directory`internal ~ SetAttributes ~ {Protected, Locked};

`type`keepProcesses = {__Symbol};
`type`keepProcesses ~ SetAttributes ~ {Protected, Locked};

`process`directory::usage = "
@brief A structure of the pattern {Rule[{__Symbol}, _String]..}, which connects
       the name of symbols, used for the calculation of some process, with the
       name of directory/file, where process specific information is stored.";
`settings`file = {
   {
      FourFermionScalarPenguins,
      FourFermionMassiveVectorPenguins,
      FourFermionFlavourChangingBoxes
   } -> #@"LToLConversion"
} &@ ( FileNameJoin@{`directory`internal, #, "settings.m"}& );
`settings`file ~ SetAttributes ~ {Protected, Locked};

`type`vertex = FeynArts`Vertex[_Integer][_Integer];
`type`vertex ~ SetAttributes ~ {Protected, Locked};

`type`propagator = FeynArts`Propagator[ FeynArts`External|FeynArts`Incoming|FeynArts`Outgoing|FeynArts`Internal|FeynArts`Loop[_Integer] ][`type`vertex,`type`vertex,Repeated[FeynArts`Field[_Integer],{0,1}]];
`type`propagator ~ SetAttributes ~ {Protected, Locked};

`type`topology = FeynArts`Topology[_Integer][`type`propagator..];
`type`topology ~ SetAttributes ~ {Protected, Locked};

`type`diagram = Rule[`type`topology,FeynArts`Insertions[Generic][__]];

getTopology[d:`type`diagram] := First@d;
getTopology // Utils`MakeUnknownInputDefinition;
getTopology ~ SetAttributes ~ {Protected, Locked};

getInsertions[d:`type`diagram] := Last@d;
getInsertions // Utils`MakeUnknownInputDefinition;
getInsertions ~ SetAttributes ~ {Protected, Locked};

`type`diagramSet = FeynArts`TopologyList[_][`type`diagram..];
`type`nullableDiagramSet = FeynArts`TopologyList[_][Rule[`type`topology,FeynArts`Insertions[Generic][___]]...];

`type`amplitude = FeynArts`FeynAmp[
   FeynArts`GraphID[FeynArts`Topology==_Integer,Generic==_Integer],
   Integral[FeynArts`FourMomentum[FeynArts`Internal,_Integer]],
   _,
   {__}->FeynArts`Insertions[FeynArts`Classes][{__}..]
];
`type`amplitudeSet = FeynArts`FeynAmpList[__][`type`amplitude..];

`type`indexCol = FeynArts`Index[Global`Colour,_Integer];
`type`indexGlu = FeynArts`Index[Global`Gluon,_Integer];
`type`indexGeneric = FeynArts`Index[Generic, _Integer];

indexGeneric[index:_Integer] :=
   FeynArts`Index[Generic, index];
indexGeneric // Utils`MakeUnknownInputDefinition;
indexGeneric ~ SetAttributes ~ {Protected,Locked};

`type`fa`field = FeynArts`S|FeynArts`F|FeynArts`V|FeynArts`U;

`type`FAfieldGeneric = `type`fa`field[`type`indexGeneric];

`type`fc`particle = `type`fa`field[_Integer, Repeated[{_Symbol}, {0, 1}]];
`type`fc`mass = 0|_Symbol|_Symbol@_Symbol;
`type`fc`external = {`type`fc`particle, FormCalc`k@_Integer, `type`fc`mass, {}};
`type`fc`process = {`type`fc`external..} -> {`type`fc`external..};
`type`fc`amplitude = FormCalc`Amp[`type`fc`process][_];
`type`fc`amplitudeSet = {`type`fc`amplitude..};

`type`pickTopoAmp = {Rule[True | False,{__Integer}]..};
`type`saveAmpClass = {Rule[_Integer,{__Integer} | All]..};

With[{
      new = Repeated[Alternatives[FeynArts`Loop, FeynArts`Internal], {0, 1}]
   },

`type`genericMass = FeynArts`Mass[`type`fa`field[`type`indexGeneric], new];

genericMass::usage = "
@note In FeynArts 3.11 the pattern for a generic mass was changed and since it
      contains Loop and Internal as well.";
genericMass[field:`type`fa`field, index:_Integer] :=
   FeynArts`Mass[field@indexGeneric@index, new];
genericMass[field:`type`fa`field] :=
   FeynArts`Mass[field@`type`indexGeneric, new];
genericMass // Utils`MakeUnknownInputDefinition;
genericMass ~ SetAttributes ~ {Protected, Locked};

];

Get@FileNameJoin@{`directory`internal, "actions.m"};
Get@FileNameJoin@{`directory`internal, "chains.m"};
Get@FileNameJoin@{`directory`internal, "time.m"};
Get@FileNameJoin@{`directory`internal, "topologies.m"};

getClassVariables[amp:`type`amplitude] :=
   amp[[4, 1]];
getClassVariables // Utils`MakeUnknownInputDefinition;
getClassVariables ~ SetAttributes ~ {Protected, Locked};

getClassInsertions[amp:`type`amplitude] :=
   amp[[4, 2]];
getClassInsertions // Utils`MakeUnknownInputDefinition;
getClassInsertions ~ SetAttributes ~ {Protected, Locked};

getClassRules[amp:`type`amplitude] :=
   Thread[getClassVariables@amp -> Transpose[List@@getClassInsertions@amp]];
getClassRules // Utils`MakeUnknownInputDefinition;
getClassRules ~ SetAttributes ~ {Protected, Locked};

getTruePositions::usage = "
@brief Converts a list with a boolean variables to the list of positions for
       all `True' entries.
@param list A `List' of booleans.
@returns A list of integers (of an empty one)."
getTruePositions[list:{(True|False)...}] :=
   Flatten@Position[list, True];
getTruePositions // Utils`MakeUnknownInputDefinition;
getTruePositions ~ SetAttributes ~ {Protected, Locked};

getProcess[set:`type`diagramSet|`type`amplitudeSet] :=
   Cases[Head@set, (FeynArts`Process -> e:_) :> e][[1]];
getProcess[set:`type`fc`amplitudeSet] :=
   Part[Head@Part[set, 1], 1];
getProcess // Utils`MakeUnknownInputDefinition;
getProcess ~ SetAttributes ~ {Protected,Locked};

`get`masses[set:`type`fc`amplitudeSet] :=
   Flatten[List@@getProcess@set, 1][[All, 3]];
`get`masses[set:`type`amplitudeSet] :=
   FeynArts`Mass[#] &/@ getField[set, All];
`get`masses // Utils`MakeUnknownInputDefinition;
`get`masses ~ SetAttributes ~ {Protected, Locked};

getField[set:`type`diagramSet, number:_Integer] :=
   Flatten[List @@ getProcess[set], 1][[number]] /;
   0<number<=Plus@@(Length/@getProcess@set);
getField[set:`type`amplitudeSet, In] :=
   First /@ getProcess[set][[1]];
getField[set:`type`amplitudeSet, Out] :=
   First /@ getProcess[set][[2]];
getField[set:`type`amplitudeSet, All] :=
   First /@ Flatten[List @@ getProcess[set], 1];
getField // Utils`MakeUnknownInputDefinition;
getField ~ SetAttributes ~ {Protected, Locked};

Module[{once},

setGenerationIndices::errOnce = "
This function should be called only once.";
setGenerationIndices::errNoModel = "
Please call FeynArts`.`InitializeModel first.";
setGenerationIndices::usage = "
@brief Looks into the definition of the model and gets names or generation
       indices in order to create appropriate type.
@note `type`indexGeneration cannot be used in the function definitions, because
      it is defined after their actual definition.";
setGenerationIndices[] :=
Module[{
      filter = (FeynArts`Indices -> e_) :> e,
      rules = {FeynArts`Index -> Identity, Global`Colour :> {}, Global`Gluon :> {}}
   },
   Utils`AssertOrQuit[Head@once === Symbol, setGenerationIndices::errOnce];
   Utils`AssertOrQuit[FeynArts`$Model =!= "", setGenerationIndices::errNoModel];

   indices = Cases[FeynArts`M$ClassesDescription, filter, Infinity];
   indices = DeleteDuplicates@Flatten[indices //. rules];

   `type`indexGeneration = FeynArts`Index[Alternatives@@indices, _Integer];
   `type`indexGeneration ~ SetAttributes ~ {Protected, Locked};
   once = {};
];
setGenerationIndices // Utils`MakeUnknownInputDefinition;
setGenerationIndices ~ SetAttributes ~ {Protected, Locked};

];

createGetSetOnce::usage = "
@brief Defines safe getter and setter for a given symbol by prepending \"set\"
       and \"get\" in front of it. This variable can be set only once.
@param sym A symbol, which serves as a root name for a new functions, i.e. for
       MySymbol symbol setMySymbol and getMySymbol will be created.
@param pattern An expression, which will be used for a pattern for a set
       function, i.e. it will have the form setMySymbol[new:pattern].";
createGetSetOnce[{sym:_Symbol, pattern:_}] :=
Module[{
      set = Symbol["set"<>SymbolName@sym],
      get = Symbol["get"<>SymbolName@sym],
      once, value
   },

   set::errOnce = "The value can be set only once.";
   set[new:pattern] := (
      Utils`AssertOrQuit[Head@once === Symbol, set::errOnce];
      once = {};
      value = new;
   );
   set // Utils`MakeUnknownInputDefinition;
   Evaluate[set] ~ SetAttributes ~ {Protected, Locked};

   get::errNotSet = "The value should be set first.";
   get[] := (
      Utils`AssertOrQuit[Head@once =!= Symbol, get::errNotSet];
      value
   );
   get // Utils`MakeUnknownInputDefinition;
   Evaluate[get] ~ SetAttributes ~ {Protected, Locked};

];
createGetSetOnce // Utils`MakeUnknownInputDefinition;
createGetSetOnce ~ SetAttributes ~ {Protected, Locked};

createGetSetOnce /@ {
   {ParticleFile, _String},
   {SubstitutionsFile, _String},
   {NamespaceFile, _String},
   {SubexpressionRules, {__}},
   {AmplitudeRules, {__}}
};

SetInitialValues::usage= "
@brief Set the FeynArts and FormCalc paths, creates required directories.
@param FCDirS the directory designated for FormCalc output
@param FAModelS the name of the FeynArts model file
@param particleNamesFileS the name of the SARAH-generated particle names file
@param substitutionsFileS the name of the SARAH-generated substitutions file
@param particleNamespaceFileS the name of the particle namespace file
@note Allowed to be called only once";
SetInitialValues::errOnce=
"Paths for FeynArts and FormCalc have been defined already.";
SetInitialValues[FCDir_String, FAModel_String,
   particleNamesFileS_String, substitutionsFileS_String,
   particleNamespaceFileS_String] :=
Module[{
      fieldNames
   },
   If[!DirectoryQ@FCDir, CreateDirectory@FCDir];
   SetDirectory@FCDir;

   FeynArts`InitializeModel@FAModel;
   SetOptions[FeynArts`InsertFields,
      FeynArts`Model -> FAModel,
      FeynArts`InsertionLevel -> FeynArts`Classes
   ];

   setGenerationIndices[];

   `type`specificMass =
      FeynArts`Mass[`type`fa`field[_Integer, {Alternatives[`type`indexCol, `type`indexGlu, `type`indexGeneration]..}]];

   setParticleFile@particleNamesFileS;
   setSubstitutionsFile@substitutionsFileS;
   setNamespaceFile@particleNamespaceFileS;

   fieldNames = getFieldNames[];
   setFieldRules@fieldNames;

   setSubexpressionRules@Join[
      getMassRules@fieldNames,
      getFieldRules[],
      getCouplingRules[],
      getGeneralRules[]
   ];

   setAmplitudeRules@Join[
      getSubexpressionRules[],
      getSumRules[],
      {FeynArts`IndexSum -> Sum}
   ];
];
SetInitialValues // Utils`MakeUnknownInputDefinition;
SetInitialValues ~ SetAttributes ~ {Protected,Locked};

getFieldNames::usage = "
@brief Loads and connects particle definitions for SARAH` and FeynArts`.
@returns List of Lists, each contains four String entries:
         1) SARAH` context of particle;
         2) SARAH` name of particle;
         3) FeynArts` type of particle;
         4) FeynArts` integer number of particle.";
getFieldNames[] :=
Module[{
      regex = "(\\w+): ([SFVU])\\[(\\d+)\\]",
      lines = Utils`ReadLinesInFile@getParticleFile[],
      namespaceRules = Rule[First@#, Sequence[Last@#, First@#]] &/@ Get@getNamespaceFile[],
      names
   },
   names = StringCases[lines, RegularExpression@regex :> {"$1","$2","$3"}] ~ Flatten ~ 1;
   names /. namespaceRules
];
getFieldNames // Utils`MakeUnknownInputDefinition;
getFieldNames ~ SetAttributes ~ {Protected, Locked};

getMassRules::usage = "
@brief Generates mass replacement rules for a given set of particles.
@param fieldNames Set of field names.
@returns A List of replacements rules for masses.";
getMassRules[fieldNames:{{_, _, _, _}..}] :=
Module[
   {
      faMasses = Symbol["Mass" <> #[[2]]] &/@ fieldNames,
      sarahNames = Symbol[#[[1]] <> #[[2]]] &/@ fieldNames,
      massRules
   },
   massRules = MapThread[
      {
         #1[index_] :> SARAH`Mass@#2@{Symbol["SARAH`gt" <> StringTake[SymbolName@index, -1]]},
         #1[indices__] :> SARAH`Mass@#2@indices,
         #1 :> SARAH`Mass@#2
      } &,
      {faMasses, sarahNames}
   ];
   Append[Flatten@massRules,
      FeynArts`Mass[field_, _ : Null] :> SARAH`Mass[field]
   ]
];
getMassRules // Utils`MakeUnknownInputDefinition;
getMassRules ~ SetAttributes ~ {Protected, Locked};

Module[{once, rules},

setFieldRules::errOnce = "The value can be set only once.";
setFieldRules::usage = "
@brief Generates field replacement rules for a given set of particles.
@param fieldNames Set of field names.
@returns A List of replacements rules for fields.";
setFieldRules[fieldNames:{{_, _, _, _}..}] :=
Module[
   {
      fullNames = Map[ToExpression, {#[[1]] <> #[[2]], #[[3]], #[[4]]} &/@ fieldNames, 2],
      bose = FeynArts`S|FeynArts`V, fermi = FeynArts`U|FeynArts`F
   },
   Utils`AssertOrQuit[Head@once === Symbol, setFieldRules::errOnce];
   rules = Join[
      # /. {n_, t_, i_} :> Rule[t@i, n],
      # /. {n_, t_, i_} :> RuleDelayed[t[i, {ind__}], n@{ind}],
      # /.
      {
         {n_, t:bose,  _} :> RuleDelayed[Times[-1,f:n], Susyno`LieGroups`conj@n],
         {n_, t:fermi, _} :> RuleDelayed[Times[-1,f:n], SARAH`bar@n]
      },
      # /.
      {
         {n_, t:bose,  _} :> RuleDelayed[Times[-1,f:n@{ind__}], Susyno`LieGroups`conj@n@{ind}],
         {n_, t:fermi, _} :> RuleDelayed[Times[-1,f:n@{ind__}], SARAH`bar@n@{ind}]
      },
      {
         ind:`type`indexGeneration :> Symbol["SARAH`gt" <> ToString@Last@ind],
         ind:`type`indexCol :> Symbol["SARAH`ct" <> ToString@Last@ind],
         ind:`type`indexGlu :> (Print["Warning: check indexRules of internal.m"];Symbol["SARAH`ct" <> ToString@Last@ind])
      },
      {
         FeynArts`S -> GenericS,
         FeynArts`F -> GenericF,
         FeynArts`V -> GenericV,
         FeynArts`U -> GenericU
      },
      {
         Times[-1,field:_GenericS|_GenericV] :> Susyno`LieGroups`conj@field,
         Times[-1,field:_GenericF|_GenericU] :> SARAH`bar@field
      }
   ] &@ fullNames;
   once = {};
];
setFieldRules // Utils`MakeUnknownInputDefinition;
setFieldRules ~ SetAttributes ~ {Protected, Locked};

getFieldRules::errNotSet = "The value should be set first.";
getFieldRules[] := (
   Utils`AssertOrQuit[Head@once =!= Symbol, getFieldRules::errNotSet];
   rules
);
getFieldRules // Utils`MakeUnknownInputDefinition;
getFieldRules ~ SetAttributes ~ {Protected, Locked};

];

getExternalMomentumRules[option:True|False|OperatorsOnly|ExceptLoops,
   amplitudes:`type`amplitudeSet] :=
Module[{
      fsFields
   },
   Switch[option,
      True,
         {SARAH`Mom[_Integer,_] :> 0},
      False|OperatorsOnly|ExceptLoops,
         (
            fsFields = getField[amplitudes, All] //. getFieldRules[];
            {SARAH`Mom[i_Integer, lorIndex_] :> SARAH`Mom[fsFields[[i]], lorIndex]}
         )
   ]
];
getExternalMomentumRules // Utils`MakeUnknownInputDefinition;
getExternalMomentumRules ~ SetAttributes ~ {Protected,Locked};

getSumRules::usage = "
@brief Sum translation rules from FeynArts/FormCalc to FlexibleSUSY language.";
getSumRules[] := {
   FeynArts`SumOver[_,_,FeynArts`External] :> Sequence[],
   Times[expr:_, FeynArts`SumOver[index:_Symbol, max:_Integer]] :>
      SARAH`sum[index, 1, max, expr],
   Times[expr:_, FeynArts`SumOver[index:_Symbol, {min:_Integer, max:_Integer}]] :>
      SARAH`sum[index, min, max, expr],
   SARAH`sum[i:_Symbol, _Integer, max:_Integer, FeynArts`SumOver[_Symbol, max2:_Integer]] :>
      SARAH`sum[i, 1, max, max2],
   SARAH`sum[i:_Symbol, _Integer, max:_Integer, FeynArts`SumOver[_, {min2:_Integer, max2:_Integer}]] :>
      SARAH`sum[i, 1, max, max2-min2]
};
getSumRules // Utils`MakeUnknownInputDefinition;
getSumRules ~ SetAttributes ~ {Protected, Locked};

getGeneralRules::usage = "
@brief General translation rules from FeynArts/FormCalc to FlexibleSUSY
       language.
@note See sec. 4.4. of FormCalc manual for details.";
getGeneralRules[] := {
   FormCalc`Finite -> 1,
   FormCalc`Den[a:_,b:_] :> 1/(a-b),
   FormCalc`Pair[a:_,b:_] :> SARAH`sum[#, 1, 4, SARAH`g[#, #]*Append[a, #]*Append[b, #]],
   f:`type`FAfieldGeneric :> Head[f][GenericIndex@Last@Last@f],
   FormCalc`k[i:_Integer, pairIndex:___] :> SARAH`Mom[i, pairIndex]
} &@ Unique@"SARAH`lt";
getGeneralRules // Utils`MakeUnknownInputDefinition;
getGeneralRules ~ SetAttributes ~ {Protected, Locked};

Module[{PL, PR, MT, FV, g, md},

   {PL, PR} = Alternatives[
      FeynArts`NonCommutative@Global`ChiralityProjector@#,

      FeynArts`NonCommutative[
         Global`DiracMatrix@FeynArts`KI1@3,
         Global`ChiralityProjector@#
      ]
   ] &/@ {-1, 1};

   Quiet[
      MT[i1:_Symbol, i2:_Symbol] :=
         Global`MetricTensor[FeynArts`KI1[i1:_Integer], FeynArts`KI1[i2:_Integer]];
      If[FormCalc`$FormCalc < 9.7,

         FV[i1:_Symbol, i2:_Symbol, Repeated[_, {0, 1}]] :=
            FeynArts`Mom[i1:_Integer] - FeynArts`Mom[i2:_Integer];,

         FV[i1:_Symbol, i2:_Symbol] := Global`FourVector[
            FeynArts`Mom[i1:_Integer] - FeynArts`Mom[i2:_Integer],
            FeynArts`KI1[3]
         ];
         FV[i1:_Symbol, i2:_Symbol, i3:_Symbol] := Global`FourVector[
            FeynArts`Mom[i1:_Integer] - FeynArts`Mom[i2:_Integer],
            FeynArts`KI1[i3:_Integer]
         ];
      ],
      RuleDelayed::rhs
   ];

   g[f:{__}, i1:_Integer, i2:_Integer] :=
      SARAH`g[LorentzIndex@Part[f, i1], LorentzIndex@Part[f, i2]];

   md[fields:{__}, i1:_Integer, i2:_Integer] :=
      SARAH`Mom@Part[fields, i1] - SARAH`Mom@Part[fields, i2];

   md[fields:{__}, i1:_Integer, i2:_Integer, i3:_Integer] :=
      SARAH`Mom[Part[fields, i1], LorentzIndex@Part[fields, i3]] -
      SARAH`Mom[Part[fields, i2], LorentzIndex@Part[fields, i3]];

   getCouplingRules[] :=
   With[{
         f = FeynArts`G[_][0][fields__], s = SARAH`Cp[fields]
      },
      {
         f@1 :> s@1,
         f@PL :> s@SARAH`PL,
         f@PR :> s@SARAH`PR,
         f@MT[i1, i2] :> s@g[{fields}, i1, i2],
         f@FV[i1, i2] :> s@md[{fields}, i1, i2],

         f[
            FV[i2, i1, i3] * MT[i1, i2] +
            FV[i1, i3, i2] * MT[i1, i3] +
            FV[i3, i2, i1] * MT[i2, i3]
         ] :>
         s[
            md[{fields}, i2, i1, i3] * g[{fields}, i1, i2],
            md[{fields}, i1, i3, i2] * g[{fields}, i1, i3],
            md[{fields}, i3, i2, i1] * g[{fields}, i2, i3]
         ]
      }
   ];
   getCouplingRules // Utils`MakeUnknownInputDefinition;
   getCouplingRules ~ SetAttributes ~ {Protected, Locked};

];

expandRules::usage = "
@brief Expands a set of compact rules into the full one.
@param rules A set of compact rules to expand.
@returns A set of rules.";
expandRules[{}] :=
   {};
expandRules[rules:{Rule[{__Symbol}, _]..}] :=
   rules /. Rule[e:_, s:_] :> Sequence @@ (Rule[#, s] &/@ e);
expandRules // Utils`MakeUnknownInputDefinition;
expandRules ~ SetAttributes ~ {Protected, Locked};

getSettings::usage = "
@brief Loads the file with process-specific settings. If there is no process
       file to load, defines default settins.
@param keepProcesses A set of process names to keep.
@returns Null.
@todo Check which settings exist and apply defauld definitions for non-existing
      ones.";
getSettings[keepProcesses:`type`keepProcesses] :=
Module[{
      rules = expandRules@`settings`file,
      file
   },
   file = DeleteDuplicates[keepProcesses /. rules];

   BeginPackage["NPointFunctions`"];
   Begin["`internal`"];

   If[MatchQ[file, {_String}],
      Get@Part[file, 1];,
      `settings`topologyReplacements = {};
      `settings`diagrams[`type`diagramSet] := {};
      `settings`amplitudes = {};
      `settings`sum[`type`diagramSet] := {};
      `settings`massless[`type`diagramSet] := {};
      `settings`momenta = {};
      `settings`regularization = {};
      `settings`order = {};
      `settings`chains = {};
   ];

   `settings`topologyReplacements ~ SetAttributes ~ {Protected, Locked};
   `settings`diagrams ~ SetAttributes ~ {Protected, Locked};
   `settings`amplitudes ~ SetAttributes ~ {Protected, Locked};
   `settings`sum ~ SetAttributes ~ {Protected, Locked};
   `settings`massless ~ SetAttributes ~ {Protected, Locked};
   `settings`momenta ~ SetAttributes ~ {Protected, Locked};
   `settings`regularization ~ SetAttributes ~ {Protected, Locked};
   `settings`order ~ SetAttributes ~ {Protected, Locked};
   `settings`chains ~ SetAttributes ~ {Protected, Locked};

   End[];
   EndPackage[];
];
getSettings // Utils`MakeUnknownInputDefinition;
getSettings ~ SetAttributes ~ {Protected, Locked};

Options[NPointFunctionFAFC]={
   LoopLevel -> 1,
   Regularize -> DimensionalReduction,
   ZeroExternalMomenta -> True,
   OnShellFlag -> False,
   KeepProcesses -> {}
};
NPointFunctionFAFC::usage = "
@brief Applies FeynArts` routines for a given process, preparing it for
       FormCalc`.
@returns A structure, representing NPF object.
@todo If topologies are not generated, then check and return.";
NPointFunctionFAFC[inFields_, outFields_, options:OptionsPattern[]] :=
Module[{
      topologies, diagrams, amplitudes
   },
   getSettings@OptionValue@KeepProcesses;

   topologies = FeynArts`CreateTopologies[
      OptionValue@LoopLevel,
      Length@inFields -> Length@outFields,
      FeynArts`ExcludeTopologies -> getExcludeTopologies@OptionValue@KeepProcesses
   ];
   diagrams = FeynArts`InsertFields[topologies, inFields -> outFields];
   diagrams = modify[diagrams, OptionValue@KeepProcesses];

   amplitudes = FeynArts`CreateFeynAmp@diagrams;
   {diagrams, amplitudes} = modify[{diagrams, amplitudes}, OptionValue@KeepProcesses];

   {
      {getField[amplitudes, In], getField[amplitudes, Out]} //. getFieldRules[],
      calculateAmplitudes[
         {diagrams, amplitudes},
         Sequence@@FilterRules[
            {options},
            {Regularize, ZeroExternalMomenta, OnShellFlag}
         ]
      ]
   }
];
NPointFunctionFAFC // Utils`MakeUnknownInputDefinition;
NPointFunctionFAFC ~ SetAttributes ~ {Protected, Locked};

getSumSettings::usage = "
@brief Some topologies can lead to physically incorrect summation on C++ level.
       This function provides required information in order to prevent this.
@param diagrams A set of diagrams.
@returns A set of restrictions on generic sums.";
getSumSettings[diagrams:`type`diagramSet] :=
Module[{
     replacements = {},
     actions = `settings`sum@diagrams, res
   },
   Do[AppendTo[replacements, applyAction[diagrams, ac]];, {ac, actions}];
   res = List@@(diagrams /. replacements);
   res = If[MatchQ[#, `type`diagram], Table[{},{Length@getInsertions@#}], First[#]] &/@ res;
   Flatten[res, 1]
];
getSumSettings // Utils`MakeUnknownInputDefinition;
getSumSettings ~ SetAttributes ~ {Protected,Locked};

collectSame::usage = "
@brief Finds the same keys in the list of rules and for them collects RHSs
       into one list, i.e.:
          collectSame@{a->{1}, b->{2}, a->{3}} leads to {a->{1,3}, b->2}.
@param list A list of rules.
@return A list of rules.";
collectSame[list:{Rule[_, {_}]...}] :=
   (#->Cases[list, (#->{el_}):>el, Infinity]) &/@ DeleteDuplicates[First/@list];
collectSame // Utils`MakeUnknownInputDefinition;
collectSame ~ SetAttributes ~ {Protected, Locked};

`get`masslessSettings::usage = "
@brief In some topologies field insertions can lead to physically incorrect
       simplifications if they are done naively. This function provides
       rules in order to prevent this.
@param diagrams A set of diagrams.
@returns A set of rules for amplitudes.";
`get`masslessSettings[diagrams:`type`diagramSet] :=
Module[{
     rules = foreach[applyAction[diagrams, #2]&, `settings`massless@diagrams],
     res
   },
   rules = collectSame@rules;
   res = List@@(diagrams /. rules);
   res = If[MatchQ[#, `type`diagram],
      Table[{}, {Length@getInsertions@#}],
      {First@#}
   ] &/@ res;
   Flatten[res, 1]
];
`get`masslessSettings // Utils`MakeUnknownInputDefinition;
`get`masslessSettings ~ SetAttributes ~ {Protected,Locked};

getRegularizationSettings::usage = "
@brief Some amplitudes are calculated incorrectly in some schemes (like box
       diagrams in CDR). For handling this one can overwrite used scheme for
       some topologies.
@param diagrams A set of diagrams.
@param scheme A default setting for regularization scheme.
@returns A set of settings for FormCalc`Dimension.
@todo Unify with getMomSettings.";
getRegularizationSettings::errOverlap = "
Topology rules in `.`settings`.`regularization overlap.";
getRegularizationSettings[
   diagrams:`type`diagramSet,
   globalScheme:DimensionalReduction|DimensionalRegularization] :=
Module[{
      scheme = Switch[globalScheme, DimensionalReduction, 4, DimensionalRegularization, D],
      replacements,
      f = (getAmplitudeNumbers[diagrams, First@#] /. x:_Integer :> Last@#) &
   },
   If[`settings`regularization === {},
      Array[scheme&, getClassAmount@diagrams],
      replacements = Transpose[f /@ `settings`regularization];
      Flatten[Switch[ Count[First/@#,True],
         0, Array[scheme&, Length[False /. #]],
         1, True /. #,
         _, Utils`AssertOrQuit[False, getRegularizationSettings::errOverlap]
         ] &/@ replacements
      ]
   ]
];
getRegularizationSettings // Utils`MakeUnknownInputDefinition;
getRegularizationSettings ~ SetAttributes ~ {Protected, Locked};

getMomSettings::usage = "
@brief Uses settings to eliminale specific momenta in specific topologies.
@param diagrams A set of topologies with class insertions.
@returns A List of option values for FormCalc`MomElim for every generic
         amplitude.";
getMomSettings::errOverlap = "
Topology rules in `.`settings`.`momenta overlap.";
getMomSettings[diagrams:`type`diagramSet] :=
Module[{
      replacements,
      f = (getAmplitudeNumbers[diagrams, First@#] /. x:_Integer :> Last@#) &
   },
   If[`settings`momenta === {},
      Array[Automatic&, getClassAmount@diagrams],
      replacements = Transpose[f /@ `settings`momenta];
      Flatten[Switch[ Count[First/@#,True],
         0, Array[Automatic&, Length[False /. #]],
         1, True /. #,
         _, Utils`AssertOrQuit[False, getMomSettings::errOverlap]
         ] &/@ replacements
      ]
   ]
];
getMomSettings // Utils`MakeUnknownInputDefinition;
getMomSettings ~ SetAttributes ~ {Protected,Locked};

deleteClasses[amplitudes:`type`amplitudeSet,topoAmpList:`type`pickTopoAmp,classesToSave:`type`saveAmpClass] :=
Module[{i,numbersOfAmplitudes,numAmp,result = amplitudes},
   numbersOfAmplitudes = Cases[topoAmpList, Rule[True, {e:__}] :> e];
   Do[
      numAmp = Part[numbersOfAmplitudes,i];
      result[[numAmp,4,2]] = result[[numAmp,4,2]][[numAmp/.classesToSave]];
   ,{i,Length@numbersOfAmplitudes}];
   result
];
deleteClasses[diagrams:`type`diagramSet,topoAmpList:`type`pickTopoAmp,classesToSave:`type`saveAmpClass] :=
Module[{i,currentClasses,result = diagrams},
   Do[
      If[topoAmpList[[i,1]]===True,
         currentClasses = topoAmpList[[i,2]]/.classesToSave;
         currentClasses = Array[Rule[{#,2},result[[i,2,#,2]][[Part[currentClasses,#]]]]&,Length@currentClasses];
         result[[i,2]] = ReplacePart[result[[i,2]],currentClasses];
      ];
   ,{i,Length@topoAmpList}];
   result
];
deleteClasses // Utils`MakeUnknownInputDefinition;
deleteClasses ~ SetAttributes ~ {Protected,Locked};

modify::usage = "
@brief Changes amplitudes and diagrams according to excudeProcess list.
@param diagrams A set of diagrams.
@param amplitudes A set of amplitudes.
@param keepProcesses A set of names which specify the process to keep.
@returns A modified set of diagrams and amplitudes.";
modify[diagrams:`type`diagramSet, keepProcesses:`type`keepProcesses] :=
Module[{
      d = diagrams
   },
   Do[
      d = applyAction[d, ac];,
      {ac, getActions[keepProcesses, `settings`diagrams@diagrams]}
   ];
   d
];
modify[
   {diagrams:`type`diagramSet, amplitudes:`type`amplitudeSet},
   keepProcesses:`type`keepProcesses
] :=
Module[{
      d = diagrams, a = removeColours@amplitudes
   },
   Do[
      {d, a} = applyAction[{d, a}, ac];,
      {ac, getActions[keepProcesses, `settings`amplitudes]}
   ];
   {d, a}
];
modify // Utils`MakeUnknownInputDefinition;
modify ~ SetAttributes ~ {Protected,Locked};

removeColours[i:`type`diagramSet|`type`amplitudeSet] :=
   Delete[i, Position[i, FeynArts`Index[Global`Colour, _Integer]]];
removeColours // Utils`MakeUnknownInputDefinition;
removeColours ~ SetAttributes ~ {Protected, Locked};

getAmplitudeNumbers::usage = "
@brief Gives numbers of amplitudes, accepted by a criterion on topology.
@param diagrams A set of diagrams.
@param <one argument function> critFunction Function for topology selection. If
       critFunction[<topology>] gives True, then topology is accepted.
@returns {<Rule>} List of rules of the form <boolean>->{<integer>..}. LHS
         stands for the topology, RHS gives numbers of classes (and the numbers
         of amplitudes the same time).";
getAmplitudeNumbers[
   diagrams:`type`diagramSet,
   critFunction_
] :=
Module[
   {
      topologies = List@@First/@diagrams,
      genNums = Length/@(List@@Last/@diagrams),
      numRegions,takeOrNot
   },
   numRegions = Array[Range[Plus@@genNums[[1;;#-1]]+1,Plus@@genNums[[1;;#]]]&,Length@genNums];
   takeOrNot = Array[TrueQ@critFunction@Part[topologies,#]&,Length@topologies];
   MapThread[#1->#2&,{takeOrNot,numRegions}]
];
getAmplitudeNumbers // Utils`MakeUnknownInputDefinition;
getAmplitudeNumbers ~ SetAttributes ~ {Protected, Locked};

removeTopologiesWithoutInsertions[diagrams:`type`nullableDiagramSet] :=
   diagrams /. (FeynArts`Topology[_][__]->FeynArts`Insertions[Generic][]):>(##&[]);
removeTopologiesWithoutInsertions // Utils`MakeUnknownInputDefinition;
removeTopologiesWithoutInsertions ~ SetAttributes ~ {Protected,Locked};

removeClassInsertionsBy[classInsertions:FeynArts`Insertions[FeynArts`Classes][__],pattern___] :=
Module[{i,classList},
   classList = Cases[classInsertions,Except[FeynArts`FeynmanGraph[_Integer,FeynArts`Classes==_Integer][___,Sequence@@{pattern},___]]];
   If[classList=!={},
      classList=Table[classList[[i]]/.Equal[FeynArts`Classes,x_Integer]:>FeynArts`Classes==i,{i,Length@classList}]
   ];
   Head[classInsertions]@@classList
];
removeClassInsertionsBy // Utils`MakeUnknownInputDefinition;
removeClassInsertionsBy ~ SetAttributes ~ {Protected,Locked};

removeGenericInsertionsBy[genericInsertions:FeynArts`Insertions[Generic][__],pattern___] :=
Module[{i,genericList},
   genericList = Rule[#[[1]],removeClassInsertionsBy[#[[2]],pattern]] &/@ genericInsertions;
   genericList = genericList /. Rule[FeynArts`FeynmanGraph[_Integer,Generic==_Integer][__],FeynArts`Insertions[FeynArts`Classes][]] :> (##&[]);
   If[genericList=!=FeynArts`Insertions[Generic][],
      genericList = Table[genericList[[i]]/.Equal[Generic,x_Integer]:>Generic==i,{i,Length@genericList}]
   ];
   Head[genericInsertions]@@genericList
];
removeGenericInsertionsBy // Utils`MakeUnknownInputDefinition;
removeGenericInsertionsBy ~ SetAttributes ~ {Protected,Locked};

printDiagramsInfo[
   diagrams:`type`diagramSet,
   where_String:" "
] :=
Module[{
      nGeneric = Length@Cases[diagrams,Generic==_Integer:>1,Infinity,Heads -> True],
      nClasses = getClassAmount@diagrams
   },
   Print[where,"in total: ",nGeneric," Generic, ",nClasses," Classes insertions"];
];

getClassAmount[set:`type`diagramSet] :=
   Length@Cases[set, FeynArts`Classes==_Integer:>1, Infinity, Heads -> True];
getClassAmount // Utils`MakeUnknownInputDefinition;
getClassAmount ~ SetAttributes ~ {Protected, Locked};

debugMakePictures[
   diagrams:`type`diagramSet,
   name_String:"classes"
] :=
Module[
   {
      directory = FileNameJoin[Most[FileNameSplit@@FeynArts`$Model]]
   },
   DeleteFile[FileNames[FileNameJoin@{directory, name<>"*"}]];
   Export[FileNameJoin@{directory,name<>".png"},FeynArts`Paint[diagrams,
      FeynArts`PaintLevel->{FeynArts`Classes},
      FeynArts`SheetHeader->name,
      FeynArts`Numbering->FeynArts`Simple]];
];

getFieldInsertions::usage = "
@brief Applies FindGenericInsertions[] to a set of diagrams or one.
@param set A set of diagrams.
@param diag A single diagram.
@param numQ Responsible for the type of output field names.
@returns For a single diagram returns List (for a given topology) of List
         (for all generic fields) of List (for all class fields) of rules
         {{{x->y,..},..},..}. For a set of diagrams, this construct is further
         transformed.";
getFieldInsertions[set:`type`diagramSet] :=
   Map[Last, #, {3}] &@ Flatten[ getFieldInsertions /@ (List @@ set), 1];

getFieldInsertions[diag:`type`diagram, numQ:True|False:False] :=
   FindGenericInsertions[#, numQ] &/@ Apply[List, getInsertions@diag, {0, 1}];

getFieldInsertions // Utils`MakeUnknownInputDefinition;
getFieldInsertions ~ SetAttributes ~ {Protected, Locked};

FindGenericInsertions::usage=
"@brief generic FeynmanGraph has rules Field[num]->particleType,
        class FeynmanGraph has rules Field[num]->particleClass.
        This function gives pairs particleType[gen,num]->particleClass, avoiding
        Field[_] mediator (if keepFieldNum==True then Field[_]->particleClass
        is given).
@param 1st argument is of the form
       {FeynmanGraph[__][__],Insertions[Classes][__]}.
@param 2nd argument changes the type of output field names
       True gives Field[_] names, False gives particleClass names.
@returns list (sorted; for all generic fields) of list (for all class fields)
         of rules {{x->y,..},..}.
@note this function is called by GenericInsertionsForDiagram[].
@note this function doesn't look at external particles.
@note all indices in rhs. of rules are removed.";
FindGenericInsertions[{graphGen_,insertCl_}, keepFieldNum_]:=
Module[
   {
      toGenericIndexConventionRules = Cases[graphGen,
         Rule[FeynArts`Field[index_Integer],type_Symbol] :>
         Rule[FeynArts`Field@index, type[FeynArts`Index[Generic,index]]]
      ],
      fieldsGen, genericInsertions
   },
   fieldsGen = toGenericIndexConventionRules[[All,1]];
   genericInsertions = Cases[#,
      Rule[genericField_,classesField_] /; MemberQ[fieldsGen, genericField] :>
      Rule[genericField, StripParticleIndices@classesField]] &/@ insertCl;
   SortBy[#,First]&/@ If[keepFieldNum,
      List @@ genericInsertions,
      List @@ genericInsertions /. toGenericIndexConventionRules
   ]
];
FindGenericInsertions // Utils`MakeUnknownInputDefinition;
FindGenericInsertions ~ SetAttributes ~ {Protected, Locked};

StripParticleIndices::usage="
@brief Removes particle indices from a given (possibley generic) field.
@param field the given field.
@returns The given field with all indices removed.";
StripParticleIndices[Times[-1,field_]] :=
   Times[-1, StripParticleIndices[field]];
StripParticleIndices[genericType_[classIndex_, ___]] :=
   genericType[classIndex];
StripParticleIndices // Utils`MakeUnknownInputDefinition;
StripParticleIndices ~ SetAttributes ~ {Protected, Locked};

getColourFactors::usage = "
@brief Creates colour factors for a given diagram.
@param ds A diagram set.
@param diagram A diagram to work with.
@returns List (for a given topology) of lists (for all generic fields) of
         colour factors.
@note During generation of genericDiagram at 1-loop level the ii-type loop
      propagators have the largest number because of FeynArts.
@note In seqProp numbers of the first vertices inside propagators are sorted
      by FeynArts.
@note External fields always come at first places in adjacency matrix.
@note This function doesn't know anything about CXXDiagrams`.` context.";
getColourFactors[ds:`type`diagramSet] :=
   Flatten[getColourFactors /@ (List @@ ds), 1] //. getFieldRules[];
getColourFactors[
   diagram:(_[_][seqProp__]->_[_][_[__][rulesFields__]->_,___])] :=
Module[
   {
      propPatt,adjacencyMatrix,externalRules,genericDiagram,genericInsertions
   },
   propPatt[i_, j_, f_] := _[_][_[_][i], _[_][j], f];

   adjacencyMatrix = Module[
      {adjs = Tally[{seqProp}/.propPatt[i_,j_,_]:>{{i,j},{j,i}}] },
      Normal@SparseArray@Flatten[{#[[1,1]]->#[[2]],#[[1,2]]->#[[2]]} &/@ adjs]];

   externalRules = Cases[{rulesFields}, HoldPattern[_[_]->_Symbol[__]]];

   genericDiagram = Module[
      {fld = Flatten[{seqProp}/.propPatt[i_,j_,f_]:>{{j,i,-f},{i,j,f}}, 1] },
      GatherBy[SortBy[fld,First],First] /. {_Integer, _Integer, f_} :> f
      ] /. Join[ {#} -> # &/@ externalRules[[All, 1]]];

   genericInsertions = getFieldInsertions[diagram, True];

   Map[CXXDiagrams`ColourFactorForIndexedDiagramFromGraph[
      CXXDiagrams`IndexDiagramFromGraph[
         genericDiagram /. externalRules /. #, adjacencyMatrix],
      adjacencyMatrix] &,
      genericInsertions,
      {2}]
];
getColourFactors // Utils`MakeUnknownInputDefinition;
getColourFactors ~ SetAttributes ~ {Protected, Locked};

getFermionOrder::usage = "
@brief Returns the order of fermions for FormCalc`FermionOrder option. Default
       is a reversed one. Can be overwritten by `settings`order for specific
       process.
@param expression A set of amplitudes or diagrams.
@note The order is cashed.
@returns A list of integers, representing an order of fermions.";
Module[{
      result
   },
   getFermionOrder[expression:`type`amplitudeSet|`type`diagramSet] :=
   If[Head@result === Symbol,
      If[# === {},
         Reverse@Range[Plus@@Length/@getProcess@expression],
         #
      ] &@ `settings`order,
      result
   ];
];
getFermionOrder // Utils`MakeUnknownInputDefinition;
getFermionOrder ~ SetAttributes ~ {Protected, Locked};

Options[calculateAmplitudes] = {
   Regularize -> DimensionalReduction,
   ZeroExternalMomenta -> True,
   OnShellFlag -> False
};
calculateAmplitudes::usage = "
@brief Applies FormCalc` routines to amplitude set, then simplifies the
       result, according to options.
@param diagrams A set of diagrams.
@param amplitudes A modified (without colour indices) set of amplitudes.
@returns The main part of NPF object, containing: generic amplitudes,
         class specific insertions, subexpressions.";
calculateAmplitudes[
   {diagrams:`type`diagramSet, amplitudes:`type`amplitudeSet},
   OptionsPattern[]
   ] :=
Module[{
      proc = getProcess@amplitudes,
      genericInsertions = getFieldInsertions@diagrams,

      combinatorialFactors = CombinatorialFactorsForClasses /@ List@@amplitudes,
      ampsGen = FeynArts`PickLevel[Generic][amplitudes],
      numExtParticles,
      feynAmps, generic, chains, abbr, subs,
      zeroedRules
   },
   numExtParticles = Plus@@Length/@proc;

   If[OptionValue@ZeroExternalMomenta === True,
      ampsGen = FormCalc`OffShell[ampsGen, Sequence@@Array[#->0&, numExtParticles]]
   ];

   feynAmps = mapThread[
      FormCalc`CalcFeynAmp[Head[ampsGen][#1],
         FormCalc`Dimension -> #2,
         FormCalc`OnShell -> OptionValue@OnShellFlag,
         FormCalc`FermionChains -> FormCalc`Chiral,
         FormCalc`FermionOrder -> getFermionOrder@diagrams,
         FormCalc`Invariants -> False,
         FormCalc`MomElim -> #3
      ]&,
      {
         ampsGen,
         getRegularizationSettings[#, OptionValue@Regularize],
         getMomSettings@#
      } &@ diagrams,
      "Amplitude calculation"
   ] //. FormCalc`GenericList[];
   generic = MapThread[getGenericSum, {feynAmps, getSumSettings@diagrams}];

   abbr = FormCalc`Abbr[] //. FormCalc`GenericList[];
   subs = FormCalc`Subexpr[] //. FormCalc`GenericList[] //. abbr;

   {chains, abbr} = {#, Complement[abbr, #]} &@ getChainRules@abbr;
   chains = simplifyChains@chains;
   chains = modifyChains[chains, diagrams, OptionValue@ZeroExternalMomenta];
   {generic, chains} = makeChainsUnique@{generic /. abbr, chains};
   chains = identifySpinors[chains, amplitudes];


   `set`zeroMassRules@{amplitudes, feynAmps};

   {generic, chains, subs} = makeMassesZero[
      {generic, chains, subs},
      diagrams,
      OptionValue@ZeroExternalMomenta
   ];

   FCAmplitudesToFSConvention[
      {
         generic,
         genericInsertions,
         combinatorialFactors,
         getColourFactors@diagrams
      },
      chains,
      subs
   ] /. getExternalMomentumRules[OptionValue@ZeroExternalMomenta, amplitudes]
];
calculatedAmplitudes // Utils`MakeUnknownInputDefinition;
calculatedAmplitudes ~ SetAttributes ~ {Protected, Locked};

Module[{rules},

`set`zeroMassRules::usage = "
@brief For a given sets of FeynArts` amd FormCalc` amplitudes creates rules to
       nullify masses of external particles.
@param fa A set of FeynArts` amplitudes.
@param fc A set of FormCalc` amplitudes.
@returns Null.
@note Both of sets are required, because, unfortunately, FormCalc` introduces
      new abbreviations, which mix with FeynArts` ones.
@note Amplitudes are taken, because they do not have colour structures already.
@note Explicit names for masses are expected only for external particles.";
`set`zeroMassRules[{fa:`type`amplitudeSet, fc:`type`fc`amplitudeSet}] :=
   (
      rules = RuleDelayed[#, 0] &/@ Riffle[`get`masses@fa, `get`masses@fc]);
`set`zeroMassRules // Utils`MakeUnknownInputDefinition;
`set`zeroMassRules ~ SetAttributes ~ {Protected, Locked};

`get`zeroMassRules::errNotSet = "
Call `.`set`.`zeroMassRules to set up rules first.";
`get`zeroMassRules::usage = "
@brief Returns a set of rules to nullify masses of external particles.
@return A list of rules to nullify masses of external particles.
@note Rules of external particle #i are under numbers (2*#i) and (2*#i-1).";
`get`zeroMassRules[] := (
   Utils`AssertOrQuit[Head@rules =!= Symbol, `get`zeroMassRules::errNotSet];
   rules
);
`get`zeroMassRules // Utils`MakeUnknownInputDefinition;
`get`zeroMassRules ~ SetAttributes ~ {Protected, Locked};

];

makeMassesZero::usage = "
@brief Sets the masses of external particles to zero everywhere, except loop
       integrals, applies subexpressions.
@param generic An expression to modify.
@param chains A lis with fermionic chains.
@param subs A list of subexpressions.
@param diagrams A set of diagrams.
@returns A list with modified expression, chains and empty non-applied subexpressions.";
makeMassesZero[{generic_, chains_, subs_}, diagrams:`type`diagramSet, ExceptLoops] :=
Module[{
      funcs = `get`masslessSettings@diagrams,
      names = ToExpression/@Names@RegularExpression@"LoopTools`[ABCD]\\d+i*",
      pattern, uniqueIntegrals, hideInt, showInt, rules,
      new = generic //. subs
   },
   pattern = Alternatives @@ ( #[__] &/@ names );
   uniqueIntegrals = DeleteDuplicates@Cases[new, pattern, Infinity];
   hideInt = Rule[#, Unique@"loopIntegral"] &/@ uniqueIntegrals;
   showInt = hideInt /. Rule[x_, y_] -> Rule[y, x];

   rules = foreach[Composition[Sequence@@funcs[[#1]]]@`get`zeroMassRules[]&, new];

   {
      foreach[#2 //. rules[[#1]] /. showInt&, new /. hideInt /. FormCalc`Pair[_,_] -> 0],
      setZeroExternalMomentaInChains@chains /. `get`zeroMassRules[],
      {}
   }
];
makeMassesZero[{generic_, chains_, subs_}, diagrams:`type`diagramSet, True] :=
Module[{
      zeroedRules = Cases[subs, Rule[_, pair:FormCalc`Pair[_, _]] :> (pair->0)]
   },
   {new, zeroedRules} = ZeroRules[subs, zeroedRules];
   {
      generic /. zeroedRules,
      setZeroExternalMomentaInChains@chains,
      new
   }

];
makeMassesZero[{expr_, chains_, subs_}, diagrams:`type`diagramSet, _] :=
   {expr, chains, subs};
makeMassesZero // Utils`MakeUnknownInputDefinition;
makeMassesZero ~ SetAttributes ~ {Protected, Locked};

foreach::usage = "
@brief Applies a two-argument function on every element in the list. The first
       argument is substituted by the number of the element in the list, while
       the second one is the element itself.
@param f A two-argument function to apply on serial number and the element
       itself.
@param list A list of elements.
@returns A list of modified elements";
Module[{
      i = 0
   },
   foreach[f_, list:{e_, rest___}] := {f[++i, e], Sequence@@foreach[f, {rest}]};
   foreach[f_, list:{}] := (i = 0; {});
   foreach // Utils`MakeUnknownInputDefinition;
   foreach ~ SetAttributes ~ {Protected, Locked};
];

mapThread::usage = "
@brief Maps a function onto multiple sets of equal length, accompanying it by
       printing a progress bar.
@param func A function to apply to set of data.
@param exprs A list of listable sets with data.
@param text A string to be printed.
@todo Add check for equality of length for exprs.";
mapThread[func_, exprs:{__}, text:_String:""] :=
Module[{
      sr, print, percent, init, end, bar, def = 70, dots,
      tot = Length@First@exprs, result
   },
   `time`set[];
   subWrite["\n"<>text<>" ...\n"];

   sr[str:_String, num:_Integer] := StringJoin@@Array[str&, num];

   print = (
      percent = #/tot;
      init = "["<>ToString@now<>"/"<>ToString@tot<>"] [";
      end = "] "<>ToString@Floor[100*percent]<>"%";
      bar = def - StringLength[init<>end];
      dots = Floor[bar*percent];
      subWrite@StringJoin[init, sr[".", dots], sr[" ", bar-dots],end,"\r"];
   )&;

   result = Table[(print@now; func@@(#[[now]]&/@ exprs)), {now, tot}];

   subWrite@"\033[K\033[A";
   subWrite[text<>" ... done in "<>`time`get[]<>" seconds.\n"];
   result
];
mapThread // Utils`MakeUnknownInputDefinition;
mapThread ~ SetAttributes ~ {Protected, Locked};

CombinatorialFactorsForClasses::usage="
@brief Takes generic amplitude and finds numerical combinatirical factors
       which arise at class level.
@returns list of combinatorical factors for a given generic amplitude
@param FeynArts`.`FeynAmp[__]";
CombinatorialFactorsForClasses[
   FeynArts`FeynAmp[_,_,_,rules_->_[_][classReplacements__]]
]:=
   {classReplacements}[[ All,#[[1,1]] ]] /.
      {
         FeynArts`IndexDelta[___] -> 1,
         FeynArts`SumOver[__] -> 1
      } &@
   Position[rules, FeynArts`RelativeCF];
CombinatorialFactorsForClasses // Utils`MakeUnknownInputDefinition;
CombinatorialFactorsForClasses ~ SetAttributes ~ {Locked,Protected};

getGenericFields::usage = "
@brief Generates a list of unique sorted generic fields in expression.
@param expr An expression, where to search.
@returns A list of unique sorted generic fields.";
getGenericFields[expr:_] :=
   Sort@DeleteDuplicates[Cases[expr, `type`FAfieldGeneric, Infinity]];
getGenericFields // Utils`MakeUnknownInputDefinition;
getGenericFields ~ SetAttributes ~ {Protected, Locked};

getGenericSum::usage= "
@brief Converts FormCalc`Amp into NPointFunctions`GenericSum object using
       restriction rules for generic fields.
@param amplitude FormCalc`Amp expression.
@param sumRules A set of rules, restricting the summation.
@returns A NPointFunctions`GenericSum object.";
getGenericSum[
   amplitude:`type`fc`amplitude,
   sumRules:{Rule[_Integer, _]...}] :=
Module[{
      sort = getGenericFields@amplitude,
      rules = Append[sumRules, _Integer -> False]
   },
   GenericSum[
      List@@amplitude,
      sort /. f_[_[_,i_]] :> {f@GenericIndex@i, i /. rules}
   ]
];
getGenericSum // Utils`MakeUnknownInputDefinition;
getGenericSum ~ SetAttributes ~ {Protected, Locked};

ZeroRules::usage=
"@brief Given a set of rules that map to zero and a set that does
not map to zero, apply the zero rules to the non-zero ones
recursively until the non-zero rules do not change anymore.
@param nonzeroRules the list of nonzero rules
@param zeroRules the list of zero rules
@returns a list of rules that map the same expressions as the initial rules.
The return value is of the form {{Rule[_,_]...},{Rule[_,0]...}}";
ZeroRules[nonzeroRules:{Rule[_,_]...}, zeroRules:{Rule[_,0]...}] :=
Module[{newNonzero, newZeroRules},
   newNonzero = Thread[
      Rule[nonzeroRules[[All,1]],nonzeroRules[[All,2]] /. zeroRules]];

   If[newNonzero === nonzeroRules, Return[{nonzeroRules, zeroRules}]];

   newZeroRules = Cases[newNonzero,HoldPattern[_->0]];
   newNonzero = Complement[newNonzero, newZeroRules];

   ZeroRules[newNonzero, Join[zeroRules,newZeroRules]]
];
ZeroRules // Utils`MakeUnknownInputDefinition;
ZeroRules ~ SetAttributes ~ {Protected, Locked};

FCAmplitudesToFSConvention::usage=
"@brief Tranlate a list of FormCalc amplitudes and their abbreviations and
subexpressions into FlexibleSUSY language.
@param amplitudes the given list of amplitudes
@param abbreviations list of abbreviations
@param aubexpressions list of subexpressions
@returns a list of the form
`{fsAmplitudes, Join[fsAbbreviations,fsSubexpressions]}`
where all FlexibleSUSY conventions have been applied.";
FCAmplitudesToFSConvention[amplitudes_, abbreviations_, subexpressions_] :=
Module[{fsAmplitudes, fsAbbreviations, fsSubexpressions},
   fsAmplitudes = amplitudes //. getAmplitudeRules[];
   fsAbbreviations = abbreviations //. getSubexpressionRules[] //. {FormCalc`DiracChain->NPointFunctions`internal`dc,FormCalc`Spinor->SARAH`DiracSpinor,FormCalc`Lor->SARAH`Lorentz};
   fsSubexpressions = subexpressions //. getSubexpressionRules[];
   {fsAmplitudes, Join[fsAbbreviations,fsSubexpressions]}
];
FCAmplitudesToFSConvention // Utils`MakeUnknownInputDefinition;
FCAmplitudesToFSConvention ~ SetAttributes ~ {Protected, Locked};

End[];
EndPackage[];
