(* ::Package:: *)

(* :Copyright:

   ====================================================================
   This file is part of FlexibleSUSY.

   FlexibleSUSY is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published
   by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   FlexibleSUSY is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with FlexibleSUSY.  If not, see
   <http://www.gnu.org/licenses/>.
   ====================================================================

*)

(* There is a problem with Global`args which comes from mathematica paclets.*)
Quiet[Needs["FeynArts`"],{FeynArts`args::shdw}];
(* Change this to 2 to see more output (if 1 then less). *)
FeynArts`$FAVerbose = 0;

Needs["FormCalc`"];
(* Change this to 1,2 or 3 to see more output. *)
FormCalc`$FCVerbose = 0;

(* Next Format makes some pattern generate mistakes. *)
Format[FormCalc`DiracChain[FormCalc`Private`s1_FormCalc`Spinor,FormCalc`Private`om_,FormCalc`Private`g___,FormCalc`Private`s2_FormCalc`Spinor]] =.;
Needs["Utils`"];

BeginPackage["NPointFunctions`"];

{SetInitialValues,NPointFunctionFAFC}

Off[General::shdw]
{
   LorentzIndex,GenericSum,GenericIndex,
   GenericS,GenericF,GenericV,GenericU,
   LoopLevel,Regularize,ZeroExternalMomenta,OnShellFlag,KeepProcesses,


   DimensionalReduction,DimensionalRegularization,OperatorsOnly,
   (*for further details inspect topologyReplacements*)
   Irreducible,Triangles,FourFermionScalarPenguins,
   FourFermionMassiveVectorPenguins,FourFermionFlavourChangingBoxes
} ~ SetAttributes ~ {Locked,Protected};
On[General::shdw]

Begin["`internal`"];

Get@FileNameJoin@{DirectoryName@FindFile@$Input, "time.m"};

`type`vertex = FeynArts`Vertex[_Integer][_Integer];
`type`vertex ~ SetAttributes ~ {Protected, Locked};

`type`propagator = FeynArts`Propagator[ FeynArts`External|FeynArts`Incoming|FeynArts`Outgoing|FeynArts`Internal|FeynArts`Loop[_Integer] ][`type`vertex,`type`vertex,Repeated[FeynArts`Field[_Integer],{0,1}]];
`type`propagator ~ SetAttributes ~ {Protected, Locked};

`type`topology = FeynArts`Topology[_Integer][`type`propagator..];
`type`topology ~ SetAttributes ~ {Protected, Locked};

Get@FileNameJoin@{DirectoryName@FindFile@$Input, "topologies.m"};

`type`diagram = Rule[`type`topology,FeynArts`Insertions[Generic][__]];

getInsertions[obj:`type`diagram] := obj[[2]];
getInsertions // Utils`MakeUnknownInputDefinition;
getInsertions ~ SetAttributes ~ {Protected, Locked};

`type`diagramSet = FeynArts`TopologyList[_][`type`diagram..];
`type`nullableDiagramSet = FeynArts`TopologyList[_][Rule[`type`topology,FeynArts`Insertions[Generic][___]]...];

`type`indexCol = FeynArts`Index[Global`Colour,_Integer];
`type`indexGlu = FeynArts`Index[Global`Gluon,_Integer];
`type`indexGeneric = FeynArts`Index[Generic, _Integer];

indexGeneric[index:_Integer] :=
   FeynArts`Index[Generic, index];
indexGeneric // Utils`MakeUnknownInputDefinition;
indexGeneric ~ SetAttributes ~ {Protected,Locked};

`type`fieldFA = FeynArts`S|FeynArts`F|FeynArts`V|FeynArts`U;

(*sec 6.1 of manual*)
`type`amplitude = FeynArts`FeynAmp[
   FeynArts`GraphID[FeynArts`Topology==_Integer,Generic==_Integer],(*name of the amplitude*)
   Integral[FeynArts`FourMomentum[FeynArts`Internal,_Integer]],(*momentum of integration*)
   _,(*generic analytic expression of the amplitude*)
   {__}->FeynArts`Insertions[FeynArts`Classes][{__}..](*replacement rules to obtain the class level*)
];

`type`FAfieldGeneric = `type`fieldFA[`type`indexGeneric];

getProcess[diagrams:`type`diagramSet] := Cases[Head@diagrams, (FeynArts`Process->x_) :> x][[1]];
getProcess // Utils`MakeUnknownInputDefinition;
getProcess ~ SetAttributes ~ {Protected,Locked};

getField[diagrams:`type`diagramSet,number:_Integer] :=
   Cases[diagrams[[1,2,1,2,1]],Rule[FeynArts`Field@number,x_] :> x][[1]] /;
   0<number<=Plus@@(Length/@getProcess@diagrams);
getField // Utils`MakeUnknownInputDefinition;
getField ~ SetAttributes ~ {Protected,Locked};

`type`amplitudeSet = FeynArts`FeynAmpList[__][`type`amplitude..];

`type`pickTopoAmp = {Rule[True | False,{__Integer}]..};
`type`saveAmpClass = {Rule[_Integer,{__Integer} | All]..};

particleNamesFile = "";
substitutionsFile = "";
particleNamespaceFile = "";

subexpressionToFSRules::usage=
"A set of rules that aid translation between FeynArts and FlexibleSUSY language.
They should be applied to subexpressions generated by FeynArts.";
subexpressionToFSRules = {};

fieldNameToFSRules::usage=
"A set of rules for @todo";
fieldNameToFSRules = {};

amplitudeToFSRules::usage=
"A set of rules for @todo";
amplitudeToFSRules= {};

Protect[particleNamesFile,substitutionsFile,particleNamespaceFile,
   subexpressionToFSRules,fieldNameToFSRules,amplitudeToFSRules
];

SetInitialValues::usage=
"@brief Set the FeynArts and FormCalc paths, creates required directories.
@param FCDirS the directory designated for FormCalc output
@param FAModelS the name of the FeynArts model file
@param particleNamesFileS the name of the SARAH-generated particle names file
@param substitutionsFileS the name of the SARAH-generated substitutions file
@param particleNamespaceFileS the name of the particle namespace file
@note Allowed to be called only once";
SetInitialValues::errOnce=
"Paths for FeynArts and FormCalc have been defined already.";
SetInitialValues[FCDir_String, FAModel_String,
   particleNamesFileS_String, substitutionsFileS_String,
   particleNamespaceFileS_String] :=
Module[{},
   If[!DirectoryQ@FCDir, CreateDirectory@FCDir];
   SetDirectory@FCDir;

   FeynArts`InitializeModel@FAModel;
   SetOptions[FeynArts`InsertFields,
      FeynArts`Model -> FAModel,
      FeynArts`InsertionLevel -> FeynArts`Classes
   ];

   (*Which index types do we load with the model?*)
   `type`indexGen = FeynArts`Index[Alternatives@@Cases[MakeBoxes@Definition@FeynArts`IndexRange,RowBox@{"Index","[",name:Except["Colour"|"Gluon"],"]"}:>ToExpression["Global`"<>name],Infinity],_Integer];

   (* Define type of masses *)
   genericMass::usage="
   @note In FeynArts 3.11 the pattern for a generic mass was changed and now
         contains Loop and Internal as well.";
   With[{new=Repeated[Alternatives[FeynArts`Loop, FeynArts`Internal], {0, 1}]},
      `type`genericMass =
         FeynArts`Mass[`type`fieldFA[`type`indexGeneric], new];
      genericMass[field:`type`fieldFA, index:_Integer] :=
         FeynArts`Mass[field@indexGeneric@index, new];
      genericMass[field:`type`fieldFA] :=
         FeynArts`Mass[field[`type`indexGeneric], new];
      genericMass // Utils`MakeUnknownInputDefinition;
      genericMass ~ SetAttributes ~ {Protected,Locked};
   ];

   `type`specificMass =
      FeynArts`Mass[`type`fieldFA[_Integer, {Alternatives[`type`indexCol, `type`indexGlu, `type`indexGen]..}]];

   {particleNamesFile,substitutionsFile,particleNamespaceFile}~ClearAttributes~{Protected};
   particleNamesFile = particleNamesFileS;
   substitutionsFile = substitutionsFileS;
   particleNamespaceFile = particleNamespaceFileS;
   {particleNamesFile,substitutionsFile,particleNamespaceFile}~SetAttributes~{Protected, Locked};

   SetFSConventionRules[];
] /; Utils`AssertOrQuit[
   And@@(TrueQ[#=={Protected}] &/@ Attributes@{particleNamesFile,substitutionsFile,particleNamespaceFile}),
   SetInitialValues::errOnce];
SetInitialValues // Utils`MakeUnknownInputDefinition;
SetInitialValues ~ SetAttributes ~ {Protected,Locked};

`fa`metric::usage = "
@brief Is used to shortly represent a Pattern for a FeynArts metric tensor.
@param i1 A Symbol for the first entry.
@param i2 A Symbol for the second entry.
@returns A Pattern for a FeynArts metric tensor.
@note Because of Mathematica warning the definition should be done quietly.";
Quiet[
   `fa`metric[i1:_Symbol, i2:_Symbol] :=
   Global`MetricTensor[FeynArts`KI1[i1:_Integer], FeynArts`KI1[i2:_Integer]],
   RuleDelayed::rhs
];
`fa`metric // Utils`MakeUnknownInputDefinition;
`fa`metric ~ SetAttributes ~ {Protected, Locked};

`fa`momdiff::usage = "
@brief Is used to shortly represent a Pattern for a FeynArts momentum
       difference between the first and the second entries.
@param i1-i2 Symbols, representing the difference.
@param i3 A Symbol for the component index.
@returns A Pattern for a FeynArts momentum difference.
@note Because of Mathematica warning the definition should be done quietly.
@note There is a change in notation since FormCalc 9.7.";
Quiet[
   If[FormCalc`$FormCalc < 9.7,
      `fa`momdiff[(i1:_Symbol)-(i2:_Symbol), Repeated[_, {0, 1}]] :=
         FeynArts`Mom[i1:_Integer] - FeynArts`Mom[i2:_Integer],

      (* Else *)
      `fa`momdiff[(i1:_Symbol)-(i2:_Symbol)] :=
         Global`FourVector[
            FeynArts`Mom[i1:_Integer] - FeynArts`Mom[i2:_Integer],
            FeynArts`KI1[3]
         ];

      `fa`momdiff[(i1:_Symbol)-(i2:_Symbol), i3:_Symbol] :=
         Global`FourVector[
            FeynArts`Mom[i1:_Integer] - FeynArts`Mom[i2:_Integer],
            FeynArts`KI1[i3:_Integer]
         ]
   ],
   RuleDelayed::rhs
];
`fa`momdiff // Utils`MakeUnknownInputDefinition;
`fa`momdiff ~ SetAttributes ~ {Protected, Locked};

`fa`pl::usage = "
@brief Represents left-handed projector: P_L.";
`fa`pr::usage = "
@brief Represents right-handed projector: P_R.";
{`fa`pl, `fa`pr} = Alternatives[
   FeynArts`NonCommutative@Global`ChiralityProjector@#,

   FeynArts`NonCommutative[
      Global`DiracMatrix@FeynArts`KI1@3,
      Global`ChiralityProjector@#
   ]
] &/@ {-1, 1};
{`fa`pl, `fa`pr} ~ SetAttributes ~ {Protected, Locked};

`sarah`metric::usage = "
@brief Is used to shortly represent SARAH metric tensor.
@param fields A List for the set of fields.
@param i1 An Integer for the first index.
@param i2 An Integer for the second index.
@returns SARAH metric tensor.
@todo One can be more specific about fields.";
`sarah`metric[fields:{__}, i1:_Integer, i2:_Integer] := SARAH`g[
   LorentzIndex[ fields[[i1]] ],
   LorentzIndex[ fields[[i2]] ]
];
`sarah`metric // Utils`MakeUnknownInputDefinition;
`sarah`metric ~ SetAttributes ~ {Protected, Locked};

`sarah`momdiff::usage = "
@brief Is used to shortly represent a SARAH momentum difference between the first
       and the second entries, while the third one representing the open index.
       If the third index is omitted, then a different form is used.
@param fields A List for the set of fields.
@param i1 An Integer for the first index.
@param i2 An Integer for the second index.
@param i3 An Integer for the third index.
@returns A SARAH momentum difference expression.";
`sarah`momdiff[fields:{__}, i1:_Integer, i2:_Integer] :=
   SARAH`Mom@Part[fields, i1] - SARAH`Mom@Part[fields, i2];
`sarah`momdiff[fields:{__}, i1:_Integer, i2:_Integer, i3:_Integer] :=
   SARAH`Mom[Part[fields, i1], LorentzIndex@Part[fields, i3]] -
   SARAH`Mom[Part[fields, i2], LorentzIndex@Part[fields, i3]]
`sarah`momdiff // Utils`MakeUnknownInputDefinition;
`sarah`momdiff ~ SetAttributes ~ {Protected, Locked};

SetFSConventionRules::usage="
@brief Set the translation rules from FeynArts/FormCalc to FlexibleSUSY
       language.";
SetFSConventionRules[] :=
Module[
   {
      pairSumIndex=Unique@"SARAH`lt",
      fieldNames,indexRules,massRules,couplingRules,generalFCRules,
      sumOverRules
   },
   fieldNames =
   Flatten[
      StringCases[
         Utils`ReadLinesInFile@particleNamesFile,
         x__ ~~ ": " ~~ y:"S"|"V"|"U"|"F" ~~ "[" ~~ int__ ~~ "]" ~~ ___ :> {x,y,int}],
      1] /.
      Apply[Rule, {#[[1]], #[[2]] <> #[[1]]} &/@ Get@particleNamespaceFile, 2];
   massRules = Append[Flatten[Module[
      {P="SARAH`Mass@"<>#,MassP=StringReplace[#,__~~"`"->"Global`Mass"]},
      {
         ToExpression[MassP <> "@indices_:>" <> P <>
         "@{Symbol[\"SARAH`gt\"<>StringTake[SymbolName@indices,-1]]}"],
         ToExpression[MassP <> "@indices__:>" <> P <> "@{indices}"],
         ToExpression[MassP <> "->" <> P]
      }
      ] &/@ fieldNames[[All, 1]] ],
      FeynArts`Mass[field_, _ : Null] :> SARAH`Mass[field]
   ];
   couplingRules = With[{f=FeynArts`G[_][0][fields__], s=SARAH`Cp[fields]},
      {
         f@1 :> s@1,

         f@`fa`pl :> s@SARAH`PL,

         f@`fa`pr :> s@SARAH`PR,

         f@`fa`metric[i1, i2] :> s@`sarah`metric[{fields}, i1, i2],

         f@`fa`momdiff[i1-i2] :> s@`sarah`momdiff[{fields}, i1, i2],

         f[`fa`momdiff[i2-i1, i3]*`fa`metric[i1, i2] +
            `fa`momdiff[i1-i3, i2]*`fa`metric[i1, i3] +
            `fa`momdiff[i3-i2, i1]*`fa`metric[i2, i3]
         ] :>
         s[
            `sarah`momdiff[{fields}, i2, i1, i3] * `sarah`metric[{fields}, i1, i2],
            `sarah`momdiff[{fields}, i1, i3, i2] * `sarah`metric[{fields}, i1, i3],
            `sarah`momdiff[{fields}, i3, i2, i1] * `sarah`metric[{fields}, i2, i3]
         ]
      }
   ];

   (* @note Sec 4.4 of FormCalc manual *)
   generalFCRules =
   {
      FormCalc`Finite -> 1,
      FormCalc`Den[a_,b_] :> 1/(a-b),
      FormCalc`Pair[a_,b_] :> SARAH`sum[
         pairSumIndex,1,4,
         SARAH`g[pairSumIndex,pairSumIndex]*Append[a,pairSumIndex]*Append[b,pairSumIndex]],
      fieldType_?(FAFieldQ)[FeynArts`Index[Generic,number_Integer]] :> fieldType@GenericIndex@number,
      FormCalc`k[i_Integer,indexInPair___] :> SARAH`Mom[i,indexInPair]
   };

   (* @note Rules, specific to SARAH generated FeynArts model files.*)
   indexRules =
   {
      index:`type`indexGen :> Symbol["SARAH`gt" <> ToString@Last@index],
      index:`type`indexCol :> Symbol["SARAH`ct" <> ToString@Last@index],
      index:`type`indexGlu :> (Print["Warning: check indexRules of internal.m"];Symbol["SARAH`ct" <> ToString@Last@index])
   };

   sumOverRules =
   {
      FeynArts`SumOver[_,_,FeynArts`External] :> Sequence[],
      Times[expr_,FeynArts`SumOver[index_,max_Integer]] :>
         SARAH`sum[index,1,max,expr],
      Times[expr_,FeynArts`SumOver[index_,{min_Integer,max_Integer}]] :>
         SARAH`sum[index,min,max,expr],
      SARAH`sum[index_,_Integer,max_Integer,FeynArts`SumOver[_,max2_Integer]] :>            (* @todo check these weird convention rules *)
         SARAH`sum[index,1,max,max2],                                                       (* *)
      SARAH`sum[index_,_Integer,max_Integer,FeynArts`SumOver[_,{min2_Integer,max2_Integer}]](* *)
    :> SARAH`sum[index,1,max,max2-min2]                                                     (* *)
};

   Unprotect@fieldNameToFSRules;
   fieldNameToFSRules = Join[
      Map[ToExpression,fieldNames,2] /. {name_,type_,number_}:>Rule[type@number,name],
      Map[ToExpression,fieldNames,2] /. {name_,type_,number_}:>RuleDelayed[type[number,{indices__}],name@{indices}],
      Map[ToExpression,fieldNames,2] /.
      {
         {name_,type:FeynArts`S|FeynArts`V,_}:>RuleDelayed[Times[-1,field:name],Susyno`LieGroups`conj@name],
         {name_,type:FeynArts`U|FeynArts`F,_}:>RuleDelayed[Times[-1,field:name],SARAH`bar@name]
      },
      Map[ToExpression,fieldNames,2] /.
      {
         {name_,type:FeynArts`S|FeynArts`V,_}:>RuleDelayed[Times[-1,field:name@{indices__}],Susyno`LieGroups`conj@name@{indices}],
         {name_,type:FeynArts`U|FeynArts`F,_}:>RuleDelayed[Times[-1,field:name@{indices__}],SARAH`bar@name@{indices}]
      },
      indexRules,
      {FeynArts`S->GenericS,FeynArts`F->GenericF,FeynArts`V->GenericV,FeynArts`U->GenericU},
      {
         Times[-1,field:_GenericS|_GenericV]:>Susyno`LieGroups`conj@field,
         Times[-1,field:_GenericF|_GenericU]:>SARAH`bar@field
      }
   ];
   Protect@fieldNameToFSRules;

   Unprotect@subexpressionToFSRules;
   subexpressionToFSRules = Join[
      massRules,
      fieldNameToFSRules,
      couplingRules,
      generalFCRules
   ];
   Protect@subexpressionToFSRules;

   Unprotect@amplitudeToFSRules;
   amplitudeToFSRules = Join[
      subexpressionToFSRules,
      sumOverRules,
      {FeynArts`IndexSum -> Sum}
   ];
   Protect@amplitudeToFSRules;
];
SetFSConventionRules // Utils`MakeUnknownInputDefinition;
SetFSConventionRules ~ SetAttributes ~ {Protected,Locked};

Options[NPointFunctionFAFC]={
   LoopLevel -> 1,
   Regularize -> DimensionalReduction,
   ZeroExternalMomenta -> True,
   OnShellFlag -> False,
   KeepProcesses -> {}
};
NPointFunctionFAFC::usage=
"@todo";
NPointFunctionFAFC[inFields_, outFields_, OptionsPattern[]] :=
Module[
   {
      settingsForGenericSums,settingsForMomElim,
      topologies, diagrams, amplitudes, genericInsertions, colourFactors,
      fsFields, fsInFields, fsOutFields, externalMomentumRules, nPointFunction
   },
   topologies = FeynArts`CreateTopologies[
      OptionValue@LoopLevel,
      Length@inFields -> Length@outFields,
      FeynArts`ExcludeTopologies -> getExcludedTopologies@OptionValue@KeepProcesses
   ];
   If[List@@topologies === {},Return@`subkernel`error@`subkernel`message::errNoTopologies];

   diagrams = FeynArts`InsertFields[topologies,inFields->outFields];
   If[List@@diagrams === {},Return@`subkernel`error@`subkernel`message::errNoDiagrams];

   diagrams = getModifiedDiagrams[diagrams,OptionValue@KeepProcesses];
   If[List@@diagrams === {},Return@`subkernel`error@`subkernel`message::errNoDiagrams];

   amplitudes = FeynArts`CreateFeynAmp@diagrams;
   amplitudes = Delete[amplitudes,Position[amplitudes,FeynArts`Index[Global`Colour,_Integer]]];(* @note Remove colour indices following assumption 1. *)
   {diagrams,amplitudes} = getModifiedDA[{diagrams,amplitudes},OptionValue@KeepProcesses];

   settingsForGenericSums = getRestrictionsOnGenericSumsByTopology@diagrams;
   settingsForMomElim = getMomElimForAmplitudesByTopology@diagrams;

   genericInsertions = getFieldInsertions@diagrams;

   colourFactors = Flatten[
      ColourFactorForDiagram /@ (List @@ diagrams), 1] //.
      fieldNameToFSRules;

   fsInFields = Head[amplitudes][[1,2,1,All,1]] //. fieldNameToFSRules;
   fsOutFields = Head[amplitudes][[1,2,2,All,1]] //. fieldNameToFSRules;

   fsFields = Join[fsInFields,fsOutFields];
   externalMomentumRules = Switch[OptionValue@ZeroExternalMomenta,
      True, {SARAH`Mom[_Integer,_] :> 0},
      False|OperatorsOnly, {SARAH`Mom[i_Integer, lorIndex_] :> SARAH`Mom[fsFields[[i]], lorIndex]}];

   nPointFunction = {
      {fsInFields, fsOutFields},
      Insert[
         CalculateAmplitudes[amplitudes,settingsForMomElim,settingsForGenericSums,genericInsertions,
            OptionValue@Regularize,
            OptionValue@ZeroExternalMomenta,
            OptionValue@OnShellFlag
         ] /. externalMomentumRules,
         colourFactors,
         {1, -1}]
   }
];

getRestrictionsOnGenericSumsByTopology::usage="
@brief Some topologies can lead to physically incorrect summation on C++ level.
       This function provides required information in order to prevent this.
@todo
";
getRestrictionsOnGenericSumsByTopology[diagrams:`type`diagramSet] :=
Module[
   {
     processParticles = Delete[#,Position[#,FeynArts`Index[Global`Colour,_Integer]]] &/@ Flatten[List@@(getProcess@diagrams)],
     newDiagrams = diagrams
   },
   newDiagrams = If[`topologyQ`self1pinguinT@First@#,
      (* Skip sum if FeynArts`Field@6 is the same as external particle 1 *)
      First@# -> Table[{6 -> Or[ processParticles[[1]],-processParticles[[1]] ]},{Length@Last@#}],
      #] &/@ diagrams;

   newDiagrams = If[`topologyQ`self3pinguinT@First@#,
      (* Skip sum if FeynArts`Field@6 is the same as external particle 3 *)
      First@# -> Table[{6 -> Or[ processParticles[[3]],-processParticles[[3]] ]},{Length@Last@#}],
      #] &/@ newDiagrams;

   (*No more rules*)
   newDiagrams = If[MatchQ[#,Rule[`type`topology,{__}]],
      #,
      (* Empty rules to skip *)
      First@#->Table[{},{Length@Last@#}]
      ] &/@ newDiagrams;
   (* Simpler external form. *)
   newDiagrams = Last /@ newDiagrams;
   newDiagrams = Flatten[List@@newDiagrams,1];
   If[MatchQ[newDiagrams,{{Rule[_Integer,_]...}..}],newDiagrams,Print@"@todo FAILED";Quit[1]]
];
getRestrictionsOnGenericSumsByTopology // Utils`MakeUnknownInputDefinition;
getRestrictionsOnGenericSumsByTopology ~ SetAttributes ~ {Protected,Locked};

`restrictions`momenta =
{
   {
      `topologyQ`pinguinT->2,
      `topologyQ`boxS->2,
      `topologyQ`boxT->2,
      `topologyQ`boxU->2
   },
   Default->Automatic
};

getMomElimForAmplitudesByTopology::usage=
"@brief Uses internally defined replacement list funMomRules for definition of
        momenta to eliminate in specific topologies.
@param <FeynArts`TopologyList> diagrams Set of topologies with class insertions.
@returns {_Integer... | Automatic...} List of option values for FormCalc`MomElim
         for every generic amplitude.";
getMomElimForAmplitudesByTopology::errOverlap=
"Some topology rules inside funMomRules overlap. Criteria should be defined in a
way, which gives unique distinction of topology.";
getMomElimForAmplitudesByTopology[
   diagrams:`type`diagramSet
] :=
Module[
   {
      replacements
   },
   replacements = (getTopologyAmplitudeRulesByTopologyCriterion[diagrams,First@#]/.x_Integer:>Last@#) &/@ `restrictions`momenta[[1]];
   replacements = Transpose@replacements;
   replacements = Switch[ Count[First/@#,True],
      0,First@#,
      1,#~Extract~Position[#,True][[1,1]],
      _,Utils`AssertOrQuit[False,getMomElimForAmplitudesByTopology::errOverlap]
      ] &/@ replacements;
   replacements = If[First@#===False,#/.x_Integer:>`restrictions`momenta[[2,2]],#] &/@ replacements;
   Flatten[Last/@replacements]
];
getMomElimForAmplitudesByTopology // Utils`MakeUnknownInputDefinition;
getMomElimForAmplitudesByTopology ~ SetAttributes ~ {Protected,Locked};

getModifiedDA::usage =
"@brief Changes amplitudes and diagrams according to excudeProcess list.
@param {<TopologyList>,<FeynAmpList>} set of topology-insertion and
amplitude-insertion rules to modify.
@param <List> set of names which specify the process to consider.
@returns {<TopologyList>,<FeynAmpList>} modified set, which specifies process.";
getModifiedDA[{diagrams:`type`diagramSet,amplitudes:`type`amplitudeSet},excludeProcesses_] := getModifiedDA[{diagrams,amplitudes},{excludeProcesses}];
getModifiedDA[
   {
      diagrams:`type`diagramSet,
      amplitudes:`type`amplitudeSet
   },
   excludeProcesses:{___}
] :=
Module[
   {
      i,numAmp,daPairs,numbersOfAmplitudes,massesOfVector,currentAmplitude,massPosition,
      rulesForClassesToSave, newDiagrams = diagrams, newAmplitudes = amplitudes
   },
   If[MemberQ[excludeProcesses,FourFermionMassiveVectorPenguins],
      Print@"t-pinguins: tree-like massless vector bosons were removed";
      (* Step 1: Get positions of topologies and amplitudes to change. *)
      daPairs = getTopologyAmplitudeRulesByTopologyCriterion[newDiagrams,`topologyQ`pinguinT];
      numbersOfAmplitudes = Flatten@Cases[daPairs,Rule[True,nums_]:>nums];
      (* Step 2: Get positions of classes to save. {<amplitude>->{classes to save}..}*)
      rulesForClassesToSave=Reap[
         Do[
            numAmp = Part[numbersOfAmplitudes,i];
            currentAmplitude = newAmplitudes[[numAmp]];
            massPosition = Position[currentAmplitude[[4,1]],genericMass[FeynArts`V, 5]];
            If[massPosition=!={},
               massesOfVector = (And@@(#=!=0&/@#)&@Extract[#,massPosition]) &/@ currentAmplitude[[4,2]];
               Sow[numbersOfAmplitudes[[i]]->Array[If[massesOfVector[[#]],#,(##&)[]]&,Length@massesOfVector]];,
               Sow[numbersOfAmplitudes[[i]]->All];
            ];
         ,{i,Length@numbersOfAmplitudes}]
      ][[2,1]];
      newAmplitudes = deleteClasses[newAmplitudes,daPairs,rulesForClassesToSave];
      newDiagrams = deleteClasses[newDiagrams,daPairs,rulesForClassesToSave];
      printDiagramsInfo@newDiagrams;
   ];
   If[MemberQ[excludeProcesses,FourFermionFlavourChangingBoxes],
      Print@"boxes: massless vector bosons were removed";
      (* Step 1: Get positions of topologies and amplitudes to change. *)
      daPairs = getTopologyAmplitudeRulesByTopologyCriterion[newDiagrams,`topologyQ`box];
      numbersOfAmplitudes = Flatten@Cases[daPairs,Rule[True,nums_]:>nums];
      (* Step 2: Get positions of classes to save. {<amplitude>->{classes to save}..}*)
      rulesForClassesToSave=Reap[
         Do[
            numAmp = numbersOfAmplitudes[[i]];
            currentAmplitude = newAmplitudes[[numAmp]];
            massPosition = Position[currentAmplitude[[4,1]],genericMass@FeynArts`V];
            If[massPosition=!={},
               massesOfVector = (And@@(#=!=0&/@#)&@Extract[#,massPosition]) &/@ currentAmplitude[[4,2]];
               Sow[numbersOfAmplitudes[[i]]->Array[If[massesOfVector[[#]],#,(##&)[]]&,Length@massesOfVector]];,
               Sow[numbersOfAmplitudes[[i]]->All];
            ];
         ,{i,Length@numbersOfAmplitudes}]
      ][[2,1]];
      newAmplitudes = deleteClasses[newAmplitudes,daPairs,rulesForClassesToSave];
      newDiagrams = deleteClasses[newDiagrams,daPairs,rulesForClassesToSave];
      printDiagramsInfo@newDiagrams;
   ];
   {newDiagrams,newAmplitudes}
];
getModifiedDA // Utils`MakeUnknownInputDefinition;
getModifiedDA ~ SetAttributes ~ {Protected,Locked};

deleteClasses[amplitudes:`type`amplitudeSet,topoAmpList:`type`pickTopoAmp,classesToSave:`type`saveAmpClass] :=
Module[{i,numbersOfAmplitudes,numAmp,result = amplitudes},
   numbersOfAmplitudes = Flatten@Cases[topoAmpList,Rule[True,nums_]:>nums];
   Do[
      numAmp = Part[numbersOfAmplitudes,i];
      result[[numAmp,4,2]] = result[[numAmp,4,2]][[numAmp/.classesToSave]];
   ,{i,Length@numbersOfAmplitudes}];
   result
];
deleteClasses[diagrams:`type`diagramSet,topoAmpList:`type`pickTopoAmp,classesToSave:`type`saveAmpClass] :=
Module[{i,currentClasses,result = diagrams},
   Do[
      If[topoAmpList[[i,1]]===True,
         currentClasses = topoAmpList[[i,2]]/.classesToSave;
         currentClasses = Array[Rule[{#,2},result[[i,2,#,2]][[Part[currentClasses,#]]]]&,Length@currentClasses];
         result[[i,2]] = ReplacePart[result[[i,2]],currentClasses];
      ];
   ,{i,Length@topoAmpList}];
   result
];
deleteClasses // Utils`MakeUnknownInputDefinition;
deleteClasses ~ SetAttributes ~ {Protected,Locked};

getTopologyAmplitudeRulesByTopologyCriterion::usage=
"@brief Gives numbers of amplitudes which are accepted by a criterion on topology.
@param <TopologyList> diagrams Set of diagrams to select from.
@param <one argument function> critFunction Function for topology selection. If
critFunction[<topology>] gives True, then topology is accepted.
@returns {<Rule>} List of rules of the form <boolean>->{<integer>..}. LHS
stands for the topology, RHS gives numbers of classes (and the numbers of
amplitudes the same time).";
getTopologyAmplitudeRulesByTopologyCriterion::errResult=
"Output
`1`
does not match desired pattern.

Input values
`2`
`3`";
getTopologyAmplitudeRulesByTopologyCriterion[
   diagrams:`type`diagramSet,
   critFunction_
] :=
Module[
   {
      topologies = List@@First/@diagrams,
      genNums = Length/@(List@@Last/@diagrams),
      numRegions,takeOrNot,res
   },
   numRegions = Array[Range[Plus@@genNums[[1;;#-1]]+1,Plus@@genNums[[1;;#]]]&,Length@genNums];
   takeOrNot = Array[TrueQ@critFunction@Part[topologies,#]&,Length@topologies];
   res = MapThread[#1->#2&,{takeOrNot,numRegions}];
   If[MatchQ[res, {Rule[_?(# === True || # === False &), {__Integer}] ..}],
      res,
      Utils`AssertOrQuit[False,getTopologyAmplitudeRulesByTopologyCriterion::errResult,res,Unevaluated@diagrams,Unevaluated@critFunction];
   ]
];
getTopologyAmplitudeRulesByTopologyCriterion // Utils`MakeUnknownInputDefinition;
getTopologyAmplitudeRulesByTopologyCriterion ~ SetAttributes ~ {Protected,Locked};

getModifiedDiagrams::usage =
"@brief Modifies diagrams according to excudeProcess list.
@param <TopologyList> set of topology-insertion rules to modify.
@param <List> set of names which specify the process to consider.
@returns <TopologyList> modified set of diagrams.";
getModifiedDiagrams[
   inserted:`type`diagramSet,
   excludeProcesses_
] :=
getModifiedDiagrams[inserted,{excludeProcesses}];
getModifiedDiagrams[
   inserted:`type`diagramSet,
   excludeProcesses:{___}] :=
Module[
   {
      newInserted = inserted,leptonPattern
   },
   If[Not[MemberQ[excludeProcesses,FourFermionScalarPenguins]&&
          MemberQ[excludeProcesses,FourFermionMassiveVectorPenguins]],
      If[MemberQ[excludeProcesses,FourFermionScalarPenguins],
         newInserted = If[`topologyQ`pinguinT[#[[1]]],
            #[[1]]->FeynArts`DiagramSelect[#[[2]],FreeQ[#,FeynArts`Field@5->FeynArts`V]&],
            #] &/@ newInserted;
         newInserted = removeTopologiesWithoutInsertions@newInserted;
         Print@"t-penguins: tree-like vector bosons were removed";
         printDiagramsInfo@newInserted;
      ];
      If[MemberQ[excludeProcesses,FourFermionMassiveVectorPenguins],
         newInserted = If[`topologyQ`pinguinT[#[[1]]],
            #[[1]]->FeynArts`DiagramSelect[#[[2]],FreeQ[#,FeynArts`Field@5->FeynArts`S]&],
            #] &/@ newInserted;
         newInserted = removeTopologiesWithoutInsertions@newInserted;
         Print@"t-penguins: tree-like scalar bosons were removed";
         printDiagramsInfo@newInserted;
      ];
   ];
   If[Or@@(MemberQ[excludeProcesses,#]&/@{FourFermionScalarPenguins,FourFermionMassiveVectorPenguins}),
         leptonPattern = getField[newInserted,1]/.index:`type`indexGen:>Blank[];
         newInserted = If[`topologyQ`self1pinguinT[#[[1]]],
            #[[1]]->removeGenericInsertionsBy[#[[2]],FeynArts`Field[7|8]->leptonPattern],
            #] &/@ newInserted;
         newInserted = removeTopologiesWithoutInsertions@newInserted;
         leptonPattern = getField[newInserted,3]/.index:`type`indexGen:>Blank[];
         newInserted = If[`topologyQ`self3pinguinT[#[[1]]],
            #[[1]]->removeGenericInsertionsBy[#[[2]],FeynArts`Field[7|8]->leptonPattern],
            #] &/@ newInserted;
         newInserted = removeTopologiesWithoutInsertions@newInserted;
         Print@"t-penguins: external leptons in sed-like processes were removed";
         printDiagramsInfo@newInserted;

         leptonPattern = getField[newInserted,1]/.index:`type`indexGen:>Blank[];
         newInserted = If[`topologyQ`trianglepinguinT[#[[1]]],
            #[[1]]->removeGenericInsertionsBy[#[[2]],FeynArts`Field[6|7]->leptonPattern],
            #] &/@ newInserted;
         newInserted = removeTopologiesWithoutInsertions@newInserted;
         Print@"t-penguins: external leptons in triangle loop were removed";
         printDiagramsInfo@newInserted;
   ];
   If[MemberQ[excludeProcesses,FourFermionFlavourChangingBoxes],
         leptonPattern = getField[newInserted,1]/.index:`type`indexGen:>Blank[];
         newInserted = If[`topologyQ`boxS[#[[1]]],
            #[[1]]->removeGenericInsertionsBy[#[[2]],FeynArts`Field[6]->leptonPattern],
            #] &/@ newInserted;
         newInserted = removeTopologiesWithoutInsertions@newInserted;
         Print["s-boxes: loops with initial lepton are removed"];
         printDiagramsInfo@newInserted;
   ];
   If[MemberQ[excludeProcesses,FourFermionFlavourChangingBoxes],

         newInserted = If[`topologyQ`boxT[#[[1]]],
            Print["Warning: t-boxes are non-zero: @todo implement rules"];#,
            #] &/@ newInserted;

         leptonPattern = getField[newInserted,1]/.index:`type`indexGen:>Blank[];
         newInserted = If[`topologyQ`boxU[#[[1]]],
            #[[1]]->removeGenericInsertionsBy[#[[2]],FeynArts`Field[5]->leptonPattern],
            #] &/@ newInserted;
         newInserted = removeTopologiesWithoutInsertions@newInserted;
         Print["u-boxes: loops with initial lepton were deleted"];
         printDiagramsInfo@newInserted;
   ];
   newInserted
];
getModifiedDiagrams // Utils`MakeUnknownInputDefinition;
getModifiedDiagrams ~ SetAttributes ~ {Protected,Locked};

removeTopologiesWithoutInsertions[diagrams:`type`nullableDiagramSet] :=
   diagrams /. (FeynArts`Topology[_][__]->FeynArts`Insertions[Generic][]):>(##&[]);
removeTopologiesWithoutInsertions // Utils`MakeUnknownInputDefinition;
removeTopologiesWithoutInsertions ~ SetAttributes ~ {Protected,Locked};

removeClassInsertionsBy[classInsertions:FeynArts`Insertions[FeynArts`Classes][__],pattern___] :=
Module[{i,classList},
   classList = Cases[classInsertions,Except[FeynArts`FeynmanGraph[_Integer,FeynArts`Classes==_Integer][___,Sequence@@{pattern},___]]];
   If[classList=!={},
      classList=Table[classList[[i]]/.Equal[FeynArts`Classes,x_Integer]:>FeynArts`Classes==i,{i,Length@classList}]
   ];
   Head[classInsertions]@@classList
];
removeClassInsertionsBy // Utils`MakeUnknownInputDefinition;
removeClassInsertionsBy ~ SetAttributes ~ {Protected,Locked};

removeGenericInsertionsBy[genericInsertions:FeynArts`Insertions[Generic][__],pattern___] :=
Module[{i,genericList},
   genericList = Rule[#[[1]],removeClassInsertionsBy[#[[2]],pattern]] &/@ genericInsertions;
   genericList = genericList /. Rule[FeynArts`FeynmanGraph[_Integer,Generic==_Integer][__],FeynArts`Insertions[FeynArts`Classes][]] :> (##&[]);
   If[genericList=!=FeynArts`Insertions[Generic][],
      genericList = Table[genericList[[i]]/.Equal[Generic,x_Integer]:>Generic==i,{i,Length@genericList}]
   ];
   Head[genericInsertions]@@genericList
];
removeGenericInsertionsBy // Utils`MakeUnknownInputDefinition;
removeGenericInsertionsBy ~ SetAttributes ~ {Protected,Locked};

printDiagramsInfo[
   diagrams:`type`diagramSet,
   where_String:" "
] :=
Module[
   {
      nGeneric = Length@Cases[diagrams,Generic==_Integer:>1,Infinity,Heads -> True],
      nClasses = Length@Cases[diagrams,FeynArts`Classes==_Integer:>1,Infinity,Heads -> True]
   },
   Print[where,"in total: ",nGeneric," Generic, ",nClasses," Classes insertions"];
];
printAmplitudesInfo[
   amplitudes:FeynArts`FeynAmpList[__][FeynArts`FeynAmp[__,{__}->FeynArts`Insertions[FeynArts`Classes][{__}..]]..],
   where_String:"new"
] :=
Module[
   {
      nGeneric = Length@amplitudes,
      nClasses = Plus@@(Length[#[[4,2]]]&/@amplitudes)
   },
   Print[where,": in total: ",nGeneric," Generic, ",nClasses," Classes amplitudes"];
];

debugMakePictures[
   diagrams:`type`diagramSet,
   name_String:"classes"
] :=
Module[
   {
      directory = FileNameJoin[Most[FileNameSplit@@FeynArts`$Model]]
   },
   DeleteFile[FileNames[FileNameJoin@{directory, name<>"*"}]];
   Export[FileNameJoin@{directory,name<>".png"},FeynArts`Paint[diagrams,
      FeynArts`PaintLevel->{FeynArts`Classes},
      FeynArts`SheetHeader->name,
      FeynArts`Numbering->FeynArts`Simple]];
];

getFieldInsertions::usage="
@brief Applies FindGenericInsertions[] to a set of diagrams or one.
@param set A set of diagrams.
@param diag A single diagram.
@param numQ Responsible for the type of output field names.
@returns For a single diagram returns List (for a given topology) of List
         (for all generic fields) of List (for all class fields) of rules
         {{{x->y,..},..},..}. For a set of diagrams, this construct is further
         transformed.";

getFieldInsertions[set:`type`diagramSet] :=
   Map[Last, #, {3}] &@ Flatten[ getFieldInsertions /@ (List @@ set), 1];

getFieldInsertions[diag:`type`diagram, numQ:True|False:False] :=
   FindGenericInsertions[#, numQ] &/@ Apply[List, getInsertions@diag, {0, 1}];

getFieldInsertions // Utils`MakeUnknownInputDefinition;
getFieldInsertions ~ SetAttributes ~ {Protected, Locked};

FindGenericInsertions::usage=
"@brief generic FeynmanGraph has rules Field[num]->particleType,
        class FeynmanGraph has rules Field[num]->particleClass.
        This function gives pairs particleType[gen,num]->particleClass, avoiding
        Field[_] mediator (if keepFieldNum==True then Field[_]->particleClass
        is given).
@param 1st argument is of the form
       {FeynmanGraph[__][__],Insertions[Classes][__]}.
@param 2nd argument changes the type of output field names
       True gives Field[_] names, False gives particleClass names.
@returns list (sorted; for all generic fields) of list (for all class fields)
         of rules {{x->y,..},..}.
@note this function is called by GenericInsertionsForDiagram[].
@note this function doesn't look at external particles.
@note all indices in rhs. of rules are removed.";
FindGenericInsertions[{graphGen_,insertCl_}, keepFieldNum_]:=
Module[
   {
      toGenericIndexConventionRules = Cases[graphGen,
         Rule[FeynArts`Field[index_Integer],type_Symbol] :>
         Rule[FeynArts`Field@index, type[FeynArts`Index[Generic,index]]]
      ],
      fieldsGen, genericInsertions
   },
   fieldsGen = toGenericIndexConventionRules[[All,1]];
   genericInsertions = Cases[#,
      Rule[genericField_,classesField_] /; MemberQ[fieldsGen, genericField] :>
      Rule[genericField, StripParticleIndices@classesField]] &/@ insertCl;
   SortBy[#,First]&/@ If[keepFieldNum,
      List @@ genericInsertions,
      List @@ genericInsertions /. toGenericIndexConventionRules
   ]
];

StripParticleIndices::usage="
@brief Removes particle indices from a given (possibley generic) field.
@param field the given field.
@returns The given field with all indices removed.";
StripParticleIndices[Times[-1,field_]] :=
   Times[-1, StripParticleIndices[field]];
StripParticleIndices[genericType_[classIndex_, ___]] :=
   genericType[classIndex];

ColourFactorForDiagram::usage="
@brief Creates colour factors for a given diagram.
@param diagram (Topology[_]->Insertions[Generic][__]) rule.
@returns List (for a given topology) of lists (for all generic fields) of
         (potentially) colour factors.
@note During generation of genericDiagram at 1-loop level the ii-type loop
      propagators have the largest number because of FeynArts.
@note In seqProp numbers of the first vertices inside propagators are sorted
      by FeynArts.
@note External fields always come at first places in adjacency matrix.
@note This function doesn't know anything about CXXDiagrams`.` context.";
ColourFactorForDiagram[
   diagram:(_[_][seqProp__]->_[_][_[__][rulesFields__]->_,___])] :=
Module[
   {
      propPatt,adjacencyMatrix,externalRules,genericDiagram,genericInsertions
   },
   propPatt[i_, j_, f_] := _[_][_[_][i], _[_][j], f];

   adjacencyMatrix = Module[
      {adjs = Tally[{seqProp}/.propPatt[i_,j_,_]:>{{i,j},{j,i}}] },
      Normal@SparseArray@Flatten[{#[[1,1]]->#[[2]],#[[1,2]]->#[[2]]} &/@ adjs]];

   externalRules = Cases[{rulesFields}, HoldPattern[_[_]->_Symbol[__]]];

   genericDiagram = Module[
      {fld = Flatten[{seqProp}/.propPatt[i_,j_,f_]:>{{j,i,-f},{i,j,f}}, 1] },
      GatherBy[SortBy[fld,First],First] /. {_Integer, _Integer, f_} :> f
      ] /. Join[ {#} -> # &/@ externalRules[[All, 1]]];

   genericInsertions = getFieldInsertions[diagram, True];

   Map[CXXDiagrams`ColourFactorForIndexedDiagramFromGraph[
      CXXDiagrams`IndexDiagramFromGraph[
         genericDiagram /. externalRules /. #, adjacencyMatrix],
      adjacencyMatrix] &,
      genericInsertions,
      {2}]
];

CalculateAmplitudes::usage=
"@brief Calculate a given set of amplitudes.
@param amps A set of amplitudes without colour indices generated by
       FeynArts`.`CreateFeynAmp[].
@param settingsForMomElim Sets up the MomElim option.
@param @todo.
@param genericInsertions the list of generic insertions for the amplitudes
@param regularizationScheme the regularization scheme for the calculation
@param zeroExternalMomenta A setting for handling of external momenta.
@returns a list of the format {fsAmplitudes, subexpressions} where
         fsAmplitudes denote the calculated amplitudes and subexpressions denote
         the subexpressions used to simplify the expressions";
CalculateAmplitudes[
   amps:FeynArts`FeynAmpList[___,FeynArts`Process->proc_,___][feynAmps:_[__]..],
   settingsForMomElim_List,
   settingsForGenericSums:{{Rule[_Integer,_]...}..},
   genericInsertions_List,
   regularizationScheme_,
   zeroExternalMomenta_,
   onShellFlag_] :=
Module[
   {
      combinatorialFactors = CombinatorialFactorsForClasses /@ {feynAmps},
      ampsGen = FeynArts`PickLevel[Generic][amps],
      numExtParticles = Plus@@Length/@proc,
      calculatedAmplitudes,abbreviations,subexpressions,
      zeroedRules
   },
   If[zeroExternalMomenta === True,
      (* Relations Mom[i]^2 = 0 are true now. *)
      ampsGen = FormCalc`OffShell[ampsGen, Sequence@@Array[#->0&, numExtParticles]]
   ];

   subWrite["\nAmplitude calculation started ...\n"];
   `time`set[];
   calculatedAmplitudes = applyAndPrint[
      FormCalc`CalcFeynAmp[Head[ampsGen][#1],
         FormCalc`Dimension -> Switch[regularizationScheme,
            DimensionalReduction, 4,
            DimensionalRegularization, D],
         FormCalc`OnShell -> onShellFlag,
         FormCalc`FermionChains -> FormCalc`Chiral,
         FormCalc`FermionOrder -> Switch[numExtParticles,4,{4,2,3,1},2,{2,1},_,None],
         FormCalc`Invariants -> False,
         FormCalc`MomElim -> #2]&,
      {ampsGen,settingsForMomElim}] //. FormCalc`GenericList[];
   subWrite["Amplitude calculation started ... done in "<>`time`get[]<>" seconds.\n"];

   calculatedAmplitudes = ToGenericSum ~ MapThread ~ {calculatedAmplitudes,settingsForGenericSums};

   abbreviations = FormCalc`Abbr[] //. FormCalc`GenericList[] /. ch:FormCalc`DiracChain[__]:>simplifySimpleChain[ch,numExtParticles];

   If[zeroExternalMomenta === OperatorsOnly,
      abbreviations = Expand@abbreviations /. ch:FormCalc`DiracChain[x__]*FormCalc`DiracChain[y__] :> setChainWithMomentaToZero@ch
   ];

   {calculatedAmplitudes,abbreviations} = makeChainsUnique[calculatedAmplitudes,abbreviations];

   abbreviations = identifySpinors[abbreviations,ampsGen];
   subexpressions = FormCalc`Subexpr[] //. FormCalc`GenericList[];

   If[zeroExternalMomenta,
      abbreviations = setZeroExternalMomentaInChains@abbreviations;
      zeroedRules = Cases[FormCalc`Abbr[],
         Rule[_,pair:FormCalc`Pair[FormCalc`k[_], FormCalc`k[_]]]
         :> (pair->0)];
      {abbreviations, zeroedRules} = ZeroRules[abbreviations, zeroedRules];
      {subexpressions, zeroedRules} = ZeroRules[subexpressions, zeroedRules];
      calculatedAmplitudes = calculatedAmplitudes /. zeroedRules;];

   FCAmplitudesToFSConvention[
      {calculatedAmplitudes, genericInsertions, combinatorialFactors},
      abbreviations, subexpressions]
];

getChainsRule::usage="
@brief Finds a subset of rules inside a List, which represent Dirac chains. It
       is possible, because the naming convention for this abbreviation is fixed
       and it is given by encoded regular expression.
@param rules A List of rules.
@return List of rules.";
getChainsRule[rules:{Rule[_Symbol, _]..}] :=
   Cases[rules,chain:Rule[_?(StringMatchQ[ToString@#,RegularExpression@"[F][1-9][\\d]*"]&),_]:>chain];
getChainsRule // Utils`MakeUnknownInputDefinition;
getChainsRule ~ SetAttributes ~ {Protected,Locked};

makeChainsUnique::usage="
@brief After manual simplification of dirac chains one can get duplicates.
       This is not a desired thing, so they have to be removed. After this,
       unique chains acquire unique names in appropriate context.
@param calculatedAmplitudes A set of calculated amplitudes, no specific structure
       required.
@param rules A List of rules with abbreviations.
@returns {calculatedAmplitudes, rules} with appropriate changes.";
makeChainsUnique[calculatedAmplitudes_, rules:{}] := {calculatedAmplitudes, {}};
makeChainsUnique[calculatedAmplitudes_, rules:{Rule[_Symbol, _]..}] :=
Module[
   {
      chainRules, otherRules, zeroChainRules, uniqueChains, rulesForAmplitudes
   },
   chainRules = getChainsRule@rules;
   otherRules = rules ~ Complement ~ chainRules;

   zeroChainRules = Cases[chainRules, chain:Rule[_,0]:>chain];
   chainRules = chainRules ~ Complement ~ zeroChainRules;

   uniqueChains = DeleteDuplicates@Cases[chainRules, FormCalc`DiracChain[x__]*FormCalc`DiracChain[y__], Infinity];

   If[uniqueChains === {},uniqueChains = DeleteDuplicates@Cases[chainRules, FormCalc`DiracChain[__], Infinity]];

   uniqueChains = MapThread[
      Rule[Symbol["NPointFunctions`internal`dc"<>#1], #2]&,
      {ToString/@Range@Length@#, #}
   ] &@ uniqueChains;

   rulesForAmplitudes = Rule[FormCalc`Mat@First@#,Last@#] &/@
      (chainRules/.(uniqueChains/.Rule[x_,y_]:>Rule[y,NPointFunctions`internal`mat@x]));

   {calculatedAmplitudes /.zeroChainRules /.rulesForAmplitudes, Join[uniqueChains,otherRules]}
];
makeChainsUnique // Utils`MakeUnknownInputDefinition;
makeChainsUnique ~ SetAttributes ~ {Protected,Locked};

NPointFunctions`internal`mat::usage = "
@brief Serves as a wrapper for Dirac chain abbreviations inside amplidudes.";
NPointFunctions`internal`mat[0] = 0;

(*@Todo think how to implement this in an elegant way.*)
simplifySimpleChain[chain_FormCalc`DiracChain,numExtParticles_Integer] :=
Module[
   {
      ch=FormCalc`DiracChain,spinor,flip,k=FormCalc`k,result
   },
   spinor[mom_:_,mass_:_,type_:1|-1] := FormCalc`Spinor[k[mom],mass,type];
   flip@7 = 6;
   flip@6 = 7;
   result = If[numExtParticles === 4,
      chain //.
      {
         ch[s1:spinor[3],proj:6|7,k@2,s2:spinor[1]] :> ch[s1,proj,k@1,s2]+ch[s1,proj,k@4,s2]-ch[s1,proj,k@3,s2],
         ch[s1:spinor[3],proj:-6|-7,k@1,k@4,s2:spinor[1,mass_]] :> FormCalc`Pair[k@4,k@1]*ch[s1,-proj,s2]-Last[s2]*mass*ch[s1,-proj,k@4,s2],
         ch[s1:spinor[4,mass_],proj:-6|-7,k@1,k@4,s2:spinor[2]] :> FormCalc`Pair[k@4,k@1]*ch[s1,-proj,s2]-Last[s1]*mass*ch[s1,flip[-proj],k@1,s2]
      },
      chain
      ];
   result //.
   {
         ch[s1:spinor[],proj:6|7,k[number_],s2:spinor[number_,mass_]] :> Last[s2]*mass*ch[s1,proj,s2],
         ch[s1:spinor[number_,mass_],proj:6|7,k[number_],s2:spinor[]] :> Last[s2]*mass*ch[s1,flip@proj,s2]
   }
];

(*@Todo think how to implement this in an elegant way.*)
setChainWithMomentaToZero[Times[chain1_FormCalc`DiracChain, chain2_FormCalc`DiracChain]] :=
Module[
   {
      ch=FormCalc`DiracChain,spinor,flip,k=FormCalc`k,l=FormCalc`Lor
   },
   spinor[mom_:_,mass_:_,type_:1|-1] := FormCalc`Spinor[k[mom],mass,type];
   flip@7 = 6;
   flip@6 = 7;
   chain1*chain2 /.
   {
      ch[spinor[3],6|7,k@4,spinor[1]] -> 0,
      ch[spinor[4],6|7,k@1,spinor[2]] -> 0,
      ch[spinor[3],6|7,l@1,spinor[1]]*ch[spinor[4],-6|-7,k@1,l@1,spinor[2]] -> 0,
      ch[spinor[3],-6|-7,k@4,l@1,spinor[1]]*ch[spinor[4],6|7,l@1,spinor[2]] -> 0,
      ch[spinor[3],-6|-7,k@4,l@1,spinor[1]]*ch[spinor[4],-6|-7,k@1,l@1,spinor[2]] -> 0,
      ch[spinor[3],-6|-7,k@4,l@1,l@2,spinor[1]]*ch[spinor[4],-6|-7,k@1,l@1,l@2,spinor[2]] -> 0,

      ch[spinor[3],-6|-7,k@1,k@4,l@1,spinor[1]]*ch[spinor[4],6|7,l@1,spinor[2]] -> 0,
      ch[spinor[3],6|7,l@1,spinor[1]]*ch[spinor[4],-6|-7,k@1,k@4,l@1,spinor[2]] -> 0
   }
];

setZeroExternalMomentaInChains::usage = "
@brief Sets FormCalc`k[i] to zero inside fermioinic chains.
@param abbreviations list of rules.
@returns Changed list of rules.";
setZeroExternalMomentaInChains[abbreviations:{Rule[_,_]...}] :=
Module[
   {
      replaceMomenta,temp,setZeroChainToZero
   },
   replaceMomenta[expr_] := expr/.FormCalc`k[_Integer]:>0;
   temp = abbreviations/.chain:FormCalc`DiracChain[__] :> replaceMomenta@chain;
   setZeroChainToZero[FormCalc`DiracChain[__,0,__]] := 0;
   setZeroChainToZero[chain:FormCalc`DiracChain[__]] := chain;
   temp/.chain:FormCalc`DiracChain[__] :> setZeroChainToZero@chain
];
setZeroExternalMomentaInChains // Utils`MakeUnknownInputDefinition;
setZeroExternalMomentaInChains ~ SetAttributes ~ {Protected,Locked};

identifySpinors::usage =
"@brief Inserts the names of fermionic fields inside FormCalc`DicaChain structures.
@param inp List of abbreviations to modify | FormCalc`DiracChain chain to modify.
@param ampsGen FeynArts`FeynAmpList with information of process
@returns DiracChain with inserted fermion names | Expression with new DiracChains.
@note DiracChains live only inside FormCalc`Abbr.
@note Should NOT be used for Automatic FormCalc`FermionOrder.";
identifySpinors[
   inp:{Rule[_,_]...},
   ampsGen:FeynArts`FeynAmpList[
      ___,
      (FeynArts`Process->Rule[{{__}..},{{__}..}]),
      ___,
      FeynArts`AmplitudeLevel->{Generic},
      ___][___]] :=
inp/.ch:FormCalc`DiracChain[__]:>identifySpinors[ch,ampsGen];
identifySpinors[
   FormCalc`DiracChain[
      FormCalc`Spinor[FormCalc`k[fermion1_Integer],mass1_,1|-1],
      seqOfElems___,
      FormCalc`Spinor[FormCalc`k[fermion2_Integer],mass2_,1|-1]],
   FeynArts`FeynAmpList[
      ___,
      process:(FeynArts`Process->Rule[{{__}..},{{__}..}]),
      ___,
      FeynArts`AmplitudeLevel->{Generic},
      ___][___]
] :=
Module[
   {
      identificationRules = getFieldPositionRules@process
   },
   FormCalc`DiracChain[
   FormCalc`Spinor[fermion1/.identificationRules,FormCalc`k[fermion1],mass1],
   seqOfElems,
   FormCalc`Spinor[fermion2/.identificationRules,FormCalc`k[fermion2],mass2]]
];
identifySpinors // Utils`MakeUnknownInputDefinition;
identifySpinors ~ SetAttributes ~ {Protected,Locked};

getFieldPositionRules::usage =
"@brief Gives rules of the form number_of_input_field->name_of_fermion.
@param FeynArts`Process->Rule[_,_].
@returns Rules of the form number_of_input_field->name_of_fermion.";
getFieldPositionRules[
   FeynArts`Process->Rule[in:{{__}..},out:{{__}..}]
] :=
MapThread[Rule,{Range@Length@#,#//.fieldNameToFSRules}] & [Part[in,All,1]~Join~Part[out,All,1]];
getFieldPositionRules // Utils`MakeUnknownInputDefinition;
getFieldPositionRules ~ SetAttributes ~ {Protected,Locked};

getNumberOfChains::usage =
"@brief Is used to calculate number of opened fermion chains.
@param FeynArts`FeynAmpList[..][..]
@returns Number of opened fermion chains.";
getNumberOfChains::errNumberOfFermions =
"During evaluation unexpected value of fermions `1` was calculated.";
getNumberOfChains::errUnknownInput =
"Input should be
getNumberOfExternalFermions@@{ FeynArts`FeynAmpList[___][___] }
and not
getNumberOfExternalFermions@@`1`";
getNumberOfChains[
   FeynArts`FeynAmpList[
      ___,
      FeynArts`Process->Rule[in:{{__}..},out:{{__}..}],
      ___,
      FeynArts`AmplitudeLevel->{Generic},
      ___][___]
] :=
Module[{numberOfChains = 0},
   Cases[Join[in[[All,1]],out[[All,1]]],FeynArts`F[__]|-FeynArts`F[__]:>numberOfChains++,{1}];
   numberOfChains /= 2;
   If[IntegerQ@numberOfChains && numberOfChains >= 0,
      numberOfChains,
      Utils`AssertOrQuit[False,getNumberOfChains::errNumberOfFermions,numberOfChains]
   ]
];
getNumberOfChains[x___] :=
Utils`AssertOrQuit[False,getNumberOfChains::errUnknownInput,{x}]
SetAttributes[getNumberOfChains,{Protected,Locked}];

applyAndPrint[func_,{expr_,opts_List},defLength_Integer:70] :=
Module[
   {
      now,
      totL = Length@expr,
      write,
      percent,
      numOfEq,
      restL,
      result
   },
   restL=defLength-2*IntegerLength@totL-11;
   result=Reap[
      Do[
      percent = now/totL;
      numOfEq = If[#<0,0,#]&[ Floor[percent*restL]-1 ];
      subWrite@StringJoin[
         "[",StringJoin@@Array[" "&,IntegerLength@totL-IntegerLength@now],ToString@now,"/",ToString@totL,"]"," ",
         "[",StringJoin@@Array["="&,numOfEq],">",StringJoin@@Array[" "&,restL-numOfEq-1],"] ",ToString@Floor[100*percent],"%\r"];
      Sow@func[ expr[[now]], opts[[now]] ];,
      {now,totL}]
   ][[2,1]];
   subWrite@"\033[K\033[A";
   result
];

CombinatorialFactorsForClasses::usage="
@brief Takes generic amplitude and finds numerical combinatirical factors
       which arise at class level.
@returns list of combinatorical factors for a given generic amplitude
@param FeynArts`.`FeynAmp[__]";
CombinatorialFactorsForClasses[
   FeynArts`FeynAmp[_,_,_,rules_->_[_][classReplacements__]]
]:=
   {classReplacements}[[ All,#[[1,1]] ]] /.
      {
         FeynArts`IndexDelta[___] -> 1,
         FeynArts`SumOver[__] -> 1
      } &@
   Position[rules, FeynArts`RelativeCF];
CombinatorialFactorsForClasses // Utils`MakeUnknownInputDefinition;
CombinatorialFactorsForClasses ~ SetAttributes ~ {Locked,Protected};

ToGenericSum::usage=
"@todo
@brief Given a generic amplitude, determine the generic fields over which it
needs to be summed and return a corresponding GenericSum[] object.
@param FormCalc`Amp[_->_][amp_] the given generic amplitude
@returns {S|F|V|U|T[GenericIndex[number of index]]...}.";
ToGenericSum[FormCalc`Amp[_->_][amp_],genericSumRestictions:{Rule[_Integer,_]...}] :=
Module[
   {
      sortSumFields = Sort@DeleteDuplicates[Cases[amp,`type`FAfieldGeneric,Infinity]],
      replSumFields
   },
   replSumFields = sortSumFields /. f_[_[_,i_]]:>{f@GenericIndex@i,Replace[i,genericSumRestictions~Join~{_Integer->False}]};
   GenericSum[{amp}, replSumFields]
];
SetAttributes[ToGenericSum,{Protected,Locked}];

FAFieldQ::usage=
"@brief Checks whether symbol belongs to FeynArts` field names or not.
@param Symbol to check.
@returns True if symbol belongs to FeynArts` field names, False otherwise.";
FAFieldQ = MatchQ[#,`type`fieldFA]&;
SetAttributes[FAFieldQ,{Protected,Locked}];

ZeroRules::usage=
"@brief Given a set of rules that map to zero and a set that does
not map to zero, apply the zero rules to the non-zero ones
recursively until the non-zero rules do not change anymore.
@param nonzeroRules the list of nonzero rules
@param zeroRules the list of zero rules
@returns a list of rules that map the same expressions as the initial rules.
The return value is of the form {{Rule[_,_]...},{Rule[_,0]...}}";
ZeroRules[nonzeroRules:{Rule[_,_]...}, zeroRules:{Rule[_,0]...}] :=
Module[{newNonzero, newZeroRules},
   newNonzero = Thread[
      Rule[nonzeroRules[[All,1]],nonzeroRules[[All,2]] /. zeroRules]];

   If[newNonzero === nonzeroRules, Return[{nonzeroRules, zeroRules}]];

   newZeroRules = Cases[newNonzero,HoldPattern[_->0]];
   newNonzero = Complement[newNonzero, newZeroRules];

   ZeroRules[newNonzero, Join[zeroRules,newZeroRules]]
];

FCAmplitudesToFSConvention::usage=
"@brief Tranlate a list of FormCalc amplitudes and their abbreviations and
subexpressions into FlexibleSUSY language.
@param amplitudes the given list of amplitudes
@param abbreviations list of abbreviations
@param aubexpressions list of subexpressions
@returns a list of the form
`{fsAmplitudes, Join[fsAbbreviations,fsSubexpressions]}`
where all FlexibleSUSY conventions have been applied.";
FCAmplitudesToFSConvention[amplitudes_, abbreviations_, subexpressions_] :=
Module[{fsAmplitudes, fsAbbreviations, fsSubexpressions},
   fsAmplitudes = amplitudes //. amplitudeToFSRules;
   fsAbbreviations = abbreviations //. subexpressionToFSRules //. {FormCalc`DiracChain->NPointFunctions`internal`dc,FormCalc`Spinor->SARAH`DiracSpinor,FormCalc`Lor->SARAH`Lorentz};
   fsSubexpressions = subexpressions //. subexpressionToFSRules;
   {fsAmplitudes, Join[fsAbbreviations,fsSubexpressions]}
];

SetAttributes[
   {
   NPointFunctionFAFC,
   FindGenericInsertions,StripParticleIndices,
   ColourFactorForDiagram,
   ZeroRules,FCAmplitudesToFSConvention
   },
   {Protected, Locked}];

End[];
EndPackage[];
