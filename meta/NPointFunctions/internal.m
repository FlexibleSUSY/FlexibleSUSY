(* ::Package:: *)

(* :Copyright:

   ====================================================================
   This file is part of FlexibleSUSY.

   FlexibleSUSY is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published
   by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   FlexibleSUSY is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with FlexibleSUSY.  If not, see
   <http://www.gnu.org/licenses/>.
   ====================================================================

*)

(* There is a problem with Global`args which comes from mathematica paclets.*)
Quiet[Needs["FeynArts`"],{FeynArts`args::shdw}];
(* Change this to 2 to see more output (if 1 then less). *)
FeynArts`$FAVerbose = 0;

Needs["FormCalc`"];
(* Change this to 1,2 or 3 to see more output. *)
FormCalc`$FCVerbose = 0;

(* Next Format makes some pattern generate mistakes. *)
Format[FormCalc`DiracChain[FormCalc`Private`s1_FormCalc`Spinor,FormCalc`Private`om_,FormCalc`Private`g___,FormCalc`Private`s2_FormCalc`Spinor]] =.;
Needs["Utils`"];

BeginPackage["NPointFunctions`"];

{SetInitialValues,NPointFunctionFAFC}

Off[General::shdw]
{
   LorentzIndex,GenericSum,GenericIndex,
   GenericS,GenericF,GenericV,GenericU,
   LoopLevel,Regularize,ZeroExternalMomenta,OnShellFlag,KeepProcesses,


   DimensionalReduction,DimensionalRegularization,OperatorsOnly,ExceptLoops,
   (*for further details inspect topologyReplacements*)
   Irreducible,Triangles,FourFermionScalarPenguins,
   FourFermionMassiveVectorPenguins,FourFermionFlavourChangingBoxes
} ~ SetAttributes ~ {Locked,Protected};
On[General::shdw]

Begin["`internal`"];

`settings`topologyReplacements::usage = "
@brief A set of rules for exclude topologies routines used inside
       FeynArts`CreateTopologies.";

`settings`diagrams::usage = "
@brief A function, which becomes a set of settings, after acting on set of
       diagrams, generated by FeynArts`InsertFields. Allows to remove/simplify
       this set. The structure is the following: `List' of `Rule's, each of them
       is a `keepProcesses' element on lhs, and the `List' of two elements on
       the rhs. The first one represents the set of actions, which should be
       performed in the case, when `keepProcesses' contains lhs element, while
       the second one - the set of actions for the absence of the lhs element.
       Each of these elements has four entries: 1) a topologyQ function, 2) a
       two-argument function, which acts on generic level of insertions and
       the expression, which is used for the selection criteria, 3) a selection
       criteria, appropriate for the used two-argument function, 4) a `String'
       message to be printed after the application of the rule.
@param ds A set of diagrams, generated by FeynArts`InsertFields.
@returns A set of settings.";

`settings`diagrams::usage = "
@brief A set of settings used for modifications of diagrams and amplitudes after
       the usage of FeynArts`CreateFeynAmp. Allows to remove/simplify this set.
       Was created for modification of class insertions.
       The structure is the following: `List' of `Rule's, each of them
       is a `keepProcesses' element on lhs, and the `List' of two elements on
       the rhs. The first one represents the set of actions, which should be
       performed in the case, when `keepProcesses' contains lhs element, having
       in mind 'keep if the action is true'. The second one - the set of actions
       for the absence of the lhs element.
       Each of these elements has three entries: 1) a topologyQ function, 2) a
       list of three elements: some class variable, two-argument function, entry
       to compare with, 3) a `String' message to be printed after the rule is
       applied.";

`directory`internal::usage = "
@brief A `String' variable, containing the directory name of `internal.m' file.";
`directory`internal = DirectoryName@FindFile@$Input;
`directory`internal ~ SetAttributes ~ {Protected, Locked};

`type`keepProcesses = {__Symbol};
`type`keepProcesses ~ SetAttributes ~ {Protected, Locked};

`process`directory::usage = "
@brief A structure of the pattern {Rule[{__Symbol}, _String]..}, which connects
       the name of symbols, used for the calculation of some process, with the
       name of directory/file, where process specific information is stored.";
`settings`file = {
   {
      FourFermionScalarPenguins,
      FourFermionMassiveVectorPenguins,
      FourFermionFlavourChangingBoxes
   } -> #@"LToLConversion"
} &@ ( FileNameJoin@{`directory`internal, #, "settings.m"}& );
`settings`file ~ SetAttributes ~ {Protected, Locked};

Get@FileNameJoin@{`directory`internal, "time.m"};

`type`vertex = FeynArts`Vertex[_Integer][_Integer];
`type`vertex ~ SetAttributes ~ {Protected, Locked};

`type`propagator = FeynArts`Propagator[ FeynArts`External|FeynArts`Incoming|FeynArts`Outgoing|FeynArts`Internal|FeynArts`Loop[_Integer] ][`type`vertex,`type`vertex,Repeated[FeynArts`Field[_Integer],{0,1}]];
`type`propagator ~ SetAttributes ~ {Protected, Locked};

`type`topology = FeynArts`Topology[_Integer][`type`propagator..];
`type`topology ~ SetAttributes ~ {Protected, Locked};

Get@FileNameJoin@{`directory`internal, "topologies.m"};

`type`diagram = Rule[`type`topology,FeynArts`Insertions[Generic][__]];

getTopology[d:`type`diagram] := First@d;
getTopology // Utils`MakeUnknownInputDefinition;
getTopology ~ SetAttributes ~ {Protected, Locked};

getInsertions[d:`type`diagram] := Last@d;
getInsertions // Utils`MakeUnknownInputDefinition;
getInsertions ~ SetAttributes ~ {Protected, Locked};

`type`diagramSet = FeynArts`TopologyList[_][`type`diagram..];
`type`nullableDiagramSet = FeynArts`TopologyList[_][Rule[`type`topology,FeynArts`Insertions[Generic][___]]...];

`type`amplitude = FeynArts`FeynAmp[
   FeynArts`GraphID[FeynArts`Topology==_Integer,Generic==_Integer],
   Integral[FeynArts`FourMomentum[FeynArts`Internal,_Integer]],
   _,
   {__}->FeynArts`Insertions[FeynArts`Classes][{__}..]
];
`type`amplitudeSet = FeynArts`FeynAmpList[__][`type`amplitude..];

`type`indexCol = FeynArts`Index[Global`Colour,_Integer];
`type`indexGlu = FeynArts`Index[Global`Gluon,_Integer];
`type`indexGeneric = FeynArts`Index[Generic, _Integer];

indexGeneric[index:_Integer] :=
   FeynArts`Index[Generic, index];
indexGeneric // Utils`MakeUnknownInputDefinition;
indexGeneric ~ SetAttributes ~ {Protected,Locked};

`type`fa`field = FeynArts`S|FeynArts`F|FeynArts`V|FeynArts`U;

getClassVariables[amp:`type`amplitude] :=
   amp[[4, 1]];
getClassVariables // Utils`MakeUnknownInputDefinition;
getClassVariables ~ SetAttributes ~ {Protected, Locked};

getClassInsertions[amp:`type`amplitude] :=
   amp[[4, 2]];
getClassInsertions // Utils`MakeUnknownInputDefinition;
getClassInsertions ~ SetAttributes ~ {Protected, Locked};

getClassRules[amp:`type`amplitude] :=
   Thread[getClassVariables@amp -> Transpose[List@@getClassInsertions@amp]];
getClassRules // Utils`MakeUnknownInputDefinition;
getClassRules ~ SetAttributes ~ {Protected, Locked};

getTruePositions::usage = "
@brief Converts a list with a boolean variables to the list of positions for
       all `True' entries.
@param list A `List' of booleans.
@returns A list of integers (of an empty one)."
getTruePositions[list:{(True|False)...}] :=
   Flatten@Position[list, True];
getTruePositions // Utils`MakeUnknownInputDefinition;
getTruePositions ~ SetAttributes ~ {Protected, Locked};

`type`FAfieldGeneric = `type`fa`field[`type`indexGeneric];

getProcess[expression:`type`diagramSet|`type`amplitudeSet] :=
   Cases[Head@expression, (FeynArts`Process -> e:_) :> e][[1]];
getProcess // Utils`MakeUnknownInputDefinition;
getProcess ~ SetAttributes ~ {Protected,Locked};

getField[set:`type`diagramSet, number:_Integer] :=
   Flatten[List @@ getProcess[set], 1][[number]] /;
   0<number<=Plus@@(Length/@getProcess@set);
getField[set:`type`amplitudeSet, In] :=
   First /@ getProcess[set][[1]];
getField[set:`type`amplitudeSet, Out] :=
   First /@ getProcess[set][[2]];
getField[set:`type`amplitudeSet, All] :=
   First /@ Flatten[List @@ getProcess[set], 1];
getField // Utils`MakeUnknownInputDefinition;
getField ~ SetAttributes ~ {Protected, Locked};

`type`pickTopoAmp = {Rule[True | False,{__Integer}]..};
`type`saveAmpClass = {Rule[_Integer,{__Integer} | All]..};

`type`fc`particle = `type`fa`field[_Integer, Repeated[{_Symbol}, {0, 1}]];
`type`fc`mass = _Symbol|_Symbol@_Symbol;
`type`fc`external = {`type`fc`particle, FormCalc`k@_Integer, `type`fc`mass, {}};
`type`fc`process = {`type`fc`external..} -> {`type`fc`external..};
`type`fc`amplitude = FormCalc`Amp[`type`fc`process][_];

particleNamesFile = "";
particleNamesFile // Protect;

substitutionsFile = "";
substitutionsFile // Protect;

particleNamespaceFile = "";
particleNamespaceFile // Protect;

`rules`subexpressions::usage = "
@brief Translation rules for subexpressions from FeynArts/FormCalc to
       FlexibleSUSY language.";
`rules`subexpressions = {};
`rules`subexpressions // Protect;

`rules`fieldNames::usage = "
@brief Translation rules for fields from FeynArts/FormCalc to FlexibleSUSY
       language.";
`rules`fieldNames = {};
`rules`fieldNames // Protect;

`rules`amplitudes::usage = "
@brief Translation rules for amplitudes from FeynArts/FormCalc to FlexibleSUSY
       language.";
`rules`amplitudes= {};
`rules`amplitudes // Protect;

Get@FileNameJoin@{`directory`internal, "chains.m"};

SetInitialValues::usage= "
@brief Set the FeynArts and FormCalc paths, creates required directories.
@param FCDirS the directory designated for FormCalc output
@param FAModelS the name of the FeynArts model file
@param particleNamesFileS the name of the SARAH-generated particle names file
@param substitutionsFileS the name of the SARAH-generated substitutions file
@param particleNamespaceFileS the name of the particle namespace file
@note Allowed to be called only once";
SetInitialValues::errOnce=
"Paths for FeynArts and FormCalc have been defined already.";
SetInitialValues[FCDir_String, FAModel_String,
   particleNamesFileS_String, substitutionsFileS_String,
   particleNamespaceFileS_String] :=
Module[{},
   If[!DirectoryQ@FCDir, CreateDirectory@FCDir];
   SetDirectory@FCDir;

   FeynArts`InitializeModel@FAModel;
   SetOptions[FeynArts`InsertFields,
      FeynArts`Model -> FAModel,
      FeynArts`InsertionLevel -> FeynArts`Classes
   ];

   (*Which index types do we load with the model?*)
   `type`indexGen = FeynArts`Index[Alternatives@@Cases[MakeBoxes@Definition@FeynArts`IndexRange,RowBox@{"Index","[",name:Except["Colour"|"Gluon"],"]"}:>ToExpression["Global`"<>name],Infinity],_Integer];

   (* Define type of masses *)
   genericMass::usage="
   @note In FeynArts 3.11 the pattern for a generic mass was changed and now
         contains Loop and Internal as well.";
   With[{new=Repeated[Alternatives[FeynArts`Loop, FeynArts`Internal], {0, 1}]},
      `type`genericMass =
         FeynArts`Mass[`type`fa`field[`type`indexGeneric], new];
      genericMass[field:`type`fa`field, index:_Integer] :=
         FeynArts`Mass[field@indexGeneric@index, new];
      genericMass[field:`type`fa`field] :=
         FeynArts`Mass[field[`type`indexGeneric], new];
      genericMass // Utils`MakeUnknownInputDefinition;
      genericMass ~ SetAttributes ~ {Protected,Locked};
   ];

   `type`specificMass =
      FeynArts`Mass[`type`fa`field[_Integer, {Alternatives[`type`indexCol, `type`indexGlu, `type`indexGen]..}]];

   {particleNamesFile,substitutionsFile,particleNamespaceFile}~ClearAttributes~{Protected};
   particleNamesFile = particleNamesFileS;
   substitutionsFile = substitutionsFileS;
   particleNamespaceFile = particleNamespaceFileS;
   {particleNamesFile,substitutionsFile,particleNamespaceFile}~SetAttributes~{Protected, Locked};

   SetFSConventionRules[];
] /; Utils`AssertOrQuit[
   And@@(TrueQ[#=={Protected}] &/@ Attributes@{particleNamesFile,substitutionsFile,particleNamespaceFile}),
   SetInitialValues::errOnce];
SetInitialValues // Utils`MakeUnknownInputDefinition;
SetInitialValues ~ SetAttributes ~ {Protected,Locked};

`fa`metric::usage = "
@brief Is used to shortly represent a Pattern for a FeynArts metric tensor.
@param i1 A Symbol for the first entry.
@param i2 A Symbol for the second entry.
@returns A Pattern for a FeynArts metric tensor.
@note Because of Mathematica warning the definition should be done quietly.";
Quiet[
   `fa`metric[i1:_Symbol, i2:_Symbol] :=
   Global`MetricTensor[FeynArts`KI1[i1:_Integer], FeynArts`KI1[i2:_Integer]],
   RuleDelayed::rhs
];
`fa`metric // Utils`MakeUnknownInputDefinition;
`fa`metric ~ SetAttributes ~ {Protected, Locked};

`fa`momdiff::usage = "
@brief Is used to shortly represent a Pattern for a FeynArts momentum
       difference between the first and the second entries.
@param i1-i2 Symbols, representing the difference.
@param i3 A Symbol for the component index.
@returns A Pattern for a FeynArts momentum difference.
@note Because of Mathematica warning the definition should be done quietly.
@note There is a change in notation since FormCalc 9.7.";
Quiet[
   If[FormCalc`$FormCalc < 9.7,
      `fa`momdiff[(i1:_Symbol)-(i2:_Symbol), Repeated[_, {0, 1}]] :=
         FeynArts`Mom[i1:_Integer] - FeynArts`Mom[i2:_Integer],

      (* Else *)
      `fa`momdiff[(i1:_Symbol)-(i2:_Symbol)] :=
         Global`FourVector[
            FeynArts`Mom[i1:_Integer] - FeynArts`Mom[i2:_Integer],
            FeynArts`KI1[3]
         ];

      `fa`momdiff[(i1:_Symbol)-(i2:_Symbol), i3:_Symbol] :=
         Global`FourVector[
            FeynArts`Mom[i1:_Integer] - FeynArts`Mom[i2:_Integer],
            FeynArts`KI1[i3:_Integer]
         ]
   ],
   RuleDelayed::rhs
];
`fa`momdiff // Utils`MakeUnknownInputDefinition;
`fa`momdiff ~ SetAttributes ~ {Protected, Locked};

`fa`pl::usage = "
@brief Represents left-handed projector: P_L.";
`fa`pr::usage = "
@brief Represents right-handed projector: P_R.";
{`fa`pl, `fa`pr} = Alternatives[
   FeynArts`NonCommutative@Global`ChiralityProjector@#,

   FeynArts`NonCommutative[
      Global`DiracMatrix@FeynArts`KI1@3,
      Global`ChiralityProjector@#
   ]
] &/@ {-1, 1};
{`fa`pl, `fa`pr} ~ SetAttributes ~ {Protected, Locked};

`sarah`metric::usage = "
@brief Is used to shortly represent SARAH metric tensor.
@param fields A List for the set of fields.
@param i1 An Integer for the first index.
@param i2 An Integer for the second index.
@returns SARAH metric tensor.
@todo One can be more specific about fields.";
`sarah`metric[fields:{__}, i1:_Integer, i2:_Integer] := SARAH`g[
   LorentzIndex[ fields[[i1]] ],
   LorentzIndex[ fields[[i2]] ]
];
`sarah`metric // Utils`MakeUnknownInputDefinition;
`sarah`metric ~ SetAttributes ~ {Protected, Locked};

`sarah`momdiff::usage = "
@brief Is used to shortly represent a SARAH momentum difference between the first
       and the second entries, while the third one representing the open index.
       If the third index is omitted, then a different form is used.
@param fields A List for the set of fields.
@param i1 An Integer for the first index.
@param i2 An Integer for the second index.
@param i3 An Integer for the third index.
@returns A SARAH momentum difference expression.";
`sarah`momdiff[fields:{__}, i1:_Integer, i2:_Integer] :=
   SARAH`Mom@Part[fields, i1] - SARAH`Mom@Part[fields, i2];
`sarah`momdiff[fields:{__}, i1:_Integer, i2:_Integer, i3:_Integer] :=
   SARAH`Mom[Part[fields, i1], LorentzIndex@Part[fields, i3]] -
   SARAH`Mom[Part[fields, i2], LorentzIndex@Part[fields, i3]]
`sarah`momdiff // Utils`MakeUnknownInputDefinition;
`sarah`momdiff ~ SetAttributes ~ {Protected, Locked};

getFieldNames::usage = "
@brief Loads and connects particle definitions for SARAH` and FeynArts`.
@param fnames Name of file with information about SARAH` and FeynArts` names.
@param fnamespaces Name of file with information about contexts of SARAH`
       particles.
@returns List of Lists, each contains four String entries:
         1) SARAH` context of particle;
         2) SARAH` name of particle;
         3) FeynArts` type of particle;
         4) FeynArts` integer number of particle.";
getFieldNames[fnames:_String, fnamespaces:_String] :=
Module[
   {
      regex = "(\\w+): ([SFVU])\\[(\\d+)\\]",
      lines = Utils`ReadLinesInFile@fnames,
      namespaceRules = Rule[First@#, Sequence[Last@#, First@#]] &/@ Get@fnamespaces,
      names
   },
      names = StringCases[lines, RegularExpression@regex :> {"$1","$2","$3"}] ~ Flatten ~ 1;
      names /. namespaceRules
];
getFieldNames // Utils`MakeUnknownInputDefinition;
getFieldNames ~ SetAttributes ~ {Protected, Locked};

getMassRules::usage = "
@brief Generates mass replacement rules for a given set of particles.
@param fieldNames Set of field names.
@returns A List of replacements rules for masses.";
getMassRules[fieldNames:{{_, _, _, _}..}] :=
Module[
   {
      faMasses = Symbol["Mass" <> #[[2]]] &/@ fieldNames,
      sarahNames = Symbol[#[[1]] <> #[[2]]] &/@ fieldNames,
      massRules
   },
   massRules = MapThread[
      {
         #1[index_] :> SARAH`Mass@#2@{Symbol["SARAH`gt" <> StringTake[SymbolName@index, -1]]},
         #1[indices__] :> SARAH`Mass@#2@indices,
         #1 :> SARAH`Mass@#2
      } &,
      {faMasses, sarahNames}
   ];
   Append[Flatten@massRules,
      FeynArts`Mass[field_, _ : Null] :> SARAH`Mass[field]
   ]
];
getMassRules // Utils`MakeUnknownInputDefinition;
getMassRules ~ SetAttributes ~ {Protected, Locked};

getFieldRules::usage = "
@brief Generates field replacement rules for a given set of particles.
@param fieldNames Set of field names.
@returns A List of replacements rules for fields.";
getFieldRules[fieldNames:{{_, _, _, _}..}] :=
Module[
   {
      fullNames = Map[ToExpression, {#[[1]] <> #[[2]], #[[3]], #[[4]]} &/@ fieldNames, 2]
   },
   Join[
      # /. {name_,type_,number_}:>Rule[type@number,name],
      # /. {name_,type_,number_}:>RuleDelayed[type[number,{indices__}],name@{indices}],
      # /.
      {
         {name_,type:FeynArts`S|FeynArts`V,_}:>RuleDelayed[Times[-1,field:name],Susyno`LieGroups`conj@name],
         {name_,type:FeynArts`U|FeynArts`F,_}:>RuleDelayed[Times[-1,field:name],SARAH`bar@name]
      },
      # /.
      {
         {name_,type:FeynArts`S|FeynArts`V,_}:>RuleDelayed[Times[-1,field:name@{indices__}],Susyno`LieGroups`conj@name@{indices}],
         {name_,type:FeynArts`U|FeynArts`F,_}:>RuleDelayed[Times[-1,field:name@{indices__}],SARAH`bar@name@{indices}]
      },
      {
         index:`type`indexGen :> Symbol["SARAH`gt" <> ToString@Last@index],
         index:`type`indexCol :> Symbol["SARAH`ct" <> ToString@Last@index],
         index:`type`indexGlu :> (Print["Warning: check indexRules of internal.m"];Symbol["SARAH`ct" <> ToString@Last@index])
      },
      {FeynArts`S->GenericS,FeynArts`F->GenericF,FeynArts`V->GenericV,FeynArts`U->GenericU},
      {
         Times[-1,field:_GenericS|_GenericV]:>Susyno`LieGroups`conj@field,
         Times[-1,field:_GenericF|_GenericU]:>SARAH`bar@field
      }
   ] &@ fullNames
];
getFieldRules // Utils`MakeUnknownInputDefinition;
getFieldRules ~ SetAttributes ~ {Protected, Locked};

getExternalMomentumRules[option:True|False|OperatorsOnly|ExceptLoops,
   amplitudes:`type`amplitudeSet] :=
Module[{
      fsFields
   },
   Switch[option,
      True,
         {SARAH`Mom[_Integer,_] :> 0},
      False|OperatorsOnly|ExceptLoops,
         (
            fsFields = getField[amplitudes, All] //. `rules`fieldNames;
            {SARAH`Mom[i_Integer, lorIndex_] :> SARAH`Mom[fsFields[[i]], lorIndex]}
         )
   ]
];
getExternalMomentumRules // Utils`MakeUnknownInputDefinition;
getExternalMomentumRules ~ SetAttributes ~ {Protected,Locked};

`rules`sum::usage = "
@brief Sum translation rules from FeynArts/FormCalc to FlexibleSUSY language.";
`rules`sum = {
   FeynArts`SumOver[_,_,FeynArts`External] :> Sequence[],
   Times[expr:_, FeynArts`SumOver[index:_Symbol, max:_Integer]] :>
      SARAH`sum[index, 1, max, expr],
   Times[expr:_, FeynArts`SumOver[index:_Symbol, {min:_Integer, max:_Integer}]] :>
      SARAH`sum[index, min, max, expr],
   SARAH`sum[i:_Symbol, _Integer, max:_Integer, FeynArts`SumOver[_Symbol, max2:_Integer]] :>
      SARAH`sum[i, 1, max, max2],
   SARAH`sum[i:_Symbol, _Integer, max:_Integer, FeynArts`SumOver[_, {min2:_Integer, max2:_Integer}]] :>
      SARAH`sum[i, 1, max, max2-min2]
};
`rules`sum ~ SetAttributes ~ {Protected, Locked};

FAFieldQ::usage = "
@brief Checks whether symbol belongs to FeynArts` field names or not.
@param Symbol to check.
@returns True if symbol belongs to FeynArts` field names, False otherwise.";
FAFieldQ = MatchQ[#,`type`fa`field]&;
FAFieldQ ~ SetAttributes ~ {Protected, Locked};

`rules`general::usage = "
@brief General translation rules from FeynArts/FormCalc to FlexibleSUSY
       language.
@note See sec. 4.4. of FormCalc manual for details.";
`rules`general = {
   FormCalc`Finite -> 1,
   FormCalc`Den[a:_,b:_] :> 1/(a-b),
   FormCalc`Pair[a:_,b:_] :> SARAH`sum[#, 1, 4, SARAH`g[#, #]*Append[a, #]*Append[b, #]],
   (f:_)?(FAFieldQ)[FeynArts`Index[Generic, i:_Integer]] :> f@GenericIndex@i,
   FormCalc`k[i:_Integer, pairIndex:___] :> SARAH`Mom[i, pairIndex]
} &@ Unique@"SARAH`lt";
`rules`general ~ SetAttributes ~ {Protected, Locked};

SetFSConventionRules::usage="
@brief Set the translation rules from FeynArts/FormCalc to FlexibleSUSY
       language.";
SetFSConventionRules[] :=
Module[
   {
      pairSumIndex=Unique@"SARAH`lt",
      fieldNames = getFieldNames[particleNamesFile, particleNamespaceFile],
      couplingRules
   },
   couplingRules = With[{f=FeynArts`G[_][0][fields__], s=SARAH`Cp[fields]},
      {
         f@1 :> s@1,

         f@`fa`pl :> s@SARAH`PL,

         f@`fa`pr :> s@SARAH`PR,

         f@`fa`metric[i1, i2] :> s@`sarah`metric[{fields}, i1, i2],

         f@`fa`momdiff[i1-i2] :> s@`sarah`momdiff[{fields}, i1, i2],

         f[`fa`momdiff[i2-i1, i3]*`fa`metric[i1, i2] +
            `fa`momdiff[i1-i3, i2]*`fa`metric[i1, i3] +
            `fa`momdiff[i3-i2, i1]*`fa`metric[i2, i3]
         ] :>
         s[
            `sarah`momdiff[{fields}, i2, i1, i3] * `sarah`metric[{fields}, i1, i2],
            `sarah`momdiff[{fields}, i1, i3, i2] * `sarah`metric[{fields}, i1, i3],
            `sarah`momdiff[{fields}, i3, i2, i1] * `sarah`metric[{fields}, i2, i3]
         ]
      }
   ];

   Unprotect@`rules`fieldNames;
   `rules`fieldNames = getFieldRules@fieldNames;
   Protect@`rules`fieldNames;

   Unprotect@`rules`subexpressions;
   `rules`subexpressions = Join[
      getMassRules@fieldNames,
      `rules`fieldNames,
      couplingRules,
      `rules`general
   ];
   Protect@`rules`subexpressions;

   Unprotect@`rules`amplitudes;
   `rules`amplitudes = Join[
      `rules`subexpressions,
      `rules`sum,
      {FeynArts`IndexSum -> Sum}
   ];
   Protect@`rules`amplitudes;
];
SetFSConventionRules // Utils`MakeUnknownInputDefinition;
SetFSConventionRules ~ SetAttributes ~ {Protected,Locked};

expandRules::usage = "
@brief Expands a set of compact rules into the full one.
@param rules A set of compact rules to expand.
@returns A set of rules.";
expandRules[rules:{Rule[{__Symbol}, _]..}] :=
   rules /. Rule[e:_, s:_] :> Sequence @@ (Rule[#, s] &/@ e);
expandRules // Utils`MakeUnknownInputDefinition;
expandRules ~ SetAttributes ~ {Protected, Locked};

getSettings::usage = "
@brief Loads the file with process-specific settings. If there is no process
       file to load, defines default settins.
@param keepProcesses A set of process names to keep.
@returns Null.
@todo Check which settings exist and apply defauld definitions for non-existing
      ones.";
getSettings[keepProcesses:`type`keepProcesses] :=
Module[{
      rules = expandRules@`settings`file,
      file
   },
   file = DeleteDuplicates[keepProcesses /. rules];

   BeginPackage["NPointFunctions`"];
   Begin["`internal`"];

   If[MatchQ[file, {_String}],
      Get@Part[file, 1];,
      `settings`topologyReplacements = {};
      `settings`diagrams[`type`diagramSet] := {};
      `settings`amplitudes = {};
      `settings`sum[`type`diagramSet] := {};
      `settings`massless[`type`diagramSet] := {};
      `settings`momenta = {};
      `settings`regularization = {};
      `settings`order = {};
      `settings`chains = {};
   ];

   `settings`topologyReplacements ~ SetAttributes ~ {Protected, Locked};
   `settings`diagrams ~ SetAttributes ~ {Protected, Locked};
   `settings`amplitudes ~ SetAttributes ~ {Protected, Locked};
   `settings`sum ~ SetAttributes ~ {Protected, Locked};
   `settings`massless ~ SetAttributes ~ {Protected, Locked};
   `settings`momenta ~ SetAttributes ~ {Protected, Locked};
   `settings`regularization ~ SetAttributes ~ {Protected, Locked};
   `settings`order ~ SetAttributes ~ {Protected, Locked};
   `settings`chains ~ SetAttributes ~ {Protected, Locked};

   End[];
   EndPackage[];
];
getSettings // Utils`MakeUnknownInputDefinition;
getSettings ~ SetAttributes ~ {Protected, Locked};

Options[NPointFunctionFAFC]={
   LoopLevel -> 1,
   Regularize -> DimensionalReduction,
   ZeroExternalMomenta -> True,
   OnShellFlag -> False,
   KeepProcesses -> {}
};
NPointFunctionFAFC::usage = "
@brief Applies FeynArts` routines for a given process, preparing it for
       FormCalc`.
@returns A structure, representing NPF object.
@todo If topologies are not generated, then check and return";
NPointFunctionFAFC[inFields_, outFields_, OptionsPattern[]] :=
Module[{
      topologies, diagrams, amplitudes
   },
   getSettings@OptionValue@KeepProcesses;

   topologies = FeynArts`CreateTopologies[
      OptionValue@LoopLevel,
      Length@inFields -> Length@outFields,
      FeynArts`ExcludeTopologies -> getExcludeTopologies@OptionValue@KeepProcesses
   ];
   diagrams = FeynArts`InsertFields[topologies, inFields -> outFields];
   diagrams = modify[diagrams, OptionValue@KeepProcesses];

   amplitudes = FeynArts`CreateFeynAmp@diagrams;
   {diagrams, amplitudes} = modify[{diagrams, amplitudes}, OptionValue@KeepProcesses];

   {
      {getField[amplitudes, In], getField[amplitudes, Out]} //. `rules`fieldNames,
      calculateAmplitudes[
            {diagrams, amplitudes},
            OptionValue@Regularize,
            OptionValue@ZeroExternalMomenta,
            OptionValue@OnShellFlag
      ]
   }
];

getSumSettings::usage = "
@brief Some topologies can lead to physically incorrect summation on C++ level.
       This function provides required information in order to prevent this.
@param diagrams A set of diagrams.
@returns A set of restrictions on generic sums.";
getSumSettings[diagrams:`type`diagramSet] :=
Module[{
     replacements = {},
     actions = `settings`sum@diagrams, res
   },
   Do[AppendTo[replacements, applyAction[diagrams, ac]];, {ac, actions}];
   res = List@@(diagrams /. replacements);
   res = If[MatchQ[#, `type`diagram], Table[{},{Length@getInsertions@#}], First[#]] &/@ res;
   Flatten[res, 1]
];
getSumSettings // Utils`MakeUnknownInputDefinition;
getSumSettings ~ SetAttributes ~ {Protected,Locked};

getMasslessSettings::usage = "
@brief Some topologies can lead to physically incorrect simplifications.
       This function provides required information in order to prevent this.
@param diagrams A set of diagrams.
@returns A set of rules for amplitudes.";
getMasslessSettings[diagrams:`type`diagramSet] :=
Module[{
     replacements = {},
     actions = `settings`massless@diagrams, res
   },
   Do[AppendTo[replacements, applyAction[diagrams, ac]];, {ac, actions}];
   res = List@@(diagrams /. replacements);
   res = If[MatchQ[#, `type`diagram], Table["dummy",{Length@getInsertions@#}], First[#]] &/@ res;
   Flatten[res, 1]
];
getMasslessSettings // Utils`MakeUnknownInputDefinition;
getMasslessSettings ~ SetAttributes ~ {Protected,Locked};

getRegularizationSettings::usage = "
@brief Some amplitudes are calculated incorrectly in some schemes (like box
       diagrams in CDR). For handling this one can overwrite used scheme for
       some topologies.
@param diagrams A set of diagrams.
@param scheme A default setting for regularization scheme.
@returns A set of settings for FormCalc`Dimension.";
getRegularizationSettings::errOverlap = "
Topology rules in `.`settings`.`regularization overlap.";
getRegularizationSettings[
   diagrams:`type`diagramSet,
   globalScheme:DimensionalReduction|DimensionalRegularization] :=
Module[{
      scheme = Switch[globalScheme, DimensionalReduction, 4, DimensionalRegularization, D],
      replacements,
      f = (getAmplitudeRules[diagrams, First@#] /. x:_Integer :> Last@#) &
   },
   replacements = Transpose[f /@ `settings`regularization];
   Flatten[Switch[ Count[First/@#,True],
      0, Array[scheme&, Length[False /. #]],
      1, True /. #,
      _, Utils`AssertOrQuit[False, getRegularizationSettings::errOverlap]
      ] &/@ replacements]
];
getRegularizationSettings // Utils`MakeUnknownInputDefinition;
getRegularizationSettings ~ SetAttributes ~ {Protected, Locked};

getMomSettings::usage = "
@brief Uses settings to eliminale specific momenta in specific topologies.
@param diagrams A set of topologies with class insertions.
@returns A List of option values for FormCalc`MomElim for every generic
         amplitude.";
getMomSettings::errOverlap = "
Topology rules in `.`settings`.`momenta overlap.";
getMomSettings[diagrams:`type`diagramSet] :=
Module[{
      replacements,
      f = (getAmplitudeRules[diagrams, First@#] /. x:_Integer :> Last@#) &
   },
   replacements = Transpose[f /@ `settings`momenta];
   Flatten[Switch[ Count[First/@#,True],
      0, Array[Automatic&, Length[False /. #]],
      1, True /. #,
      _, Utils`AssertOrQuit[False, getMomSettings::errOverlap]
      ] &/@ replacements]
];
getMomSettings // Utils`MakeUnknownInputDefinition;
getMomSettings ~ SetAttributes ~ {Protected,Locked};

getActions[keepProcesses:`type`keepProcesses, settings:{}] := {};
getActions[keepProcesses:`type`keepProcesses, settings:{Rule[_,{{___},{___}}]..}] :=
Module[{
      positiveRules = settings /. Rule[s:_, {p:_, _}] :> Rule[s, p],
      negativeRules = settings /. Rule[s:_, {_, n:_}] :> Rule[s, n],
      discardProcesses = Complement[settings[[All, 1]], keepProcesses],
      actions
   },
   actions = DeleteDuplicates@Join[
      DeleteDuplicates@Flatten[keepProcesses /. positiveRules, 1],
      DeleteDuplicates@Flatten[discardProcesses /. negativeRules, 1]
   ]
];
getActions // Utils`MakeUnknownInputDefinition;
getActions ~ SetAttributes ~ {Protected,Locked};

applyAction[
   {diagrams:`type`diagramSet, amplitudes:`type`amplitudeSet},
   {topologyQ:_, {name:_, function:_, value:_}, text:_String}
] :=
Module[
   {
      daPairs = getAmplitudeRules[diagrams, topologyQ],
      amplitudeNumbers, saveClassRules, viPairs, insertions, res
   },
   amplitudeNumbers = Cases[daPairs, Rule[True, {e:__}] :> e];
   saveClassRules = Table[
      viPairs = getClassRules@amplitudes[[i]];
      insertions = Cases[viPairs, (name -> {e:__}) :> e, Infinity ];
      i -> getTruePositions[function[#, value] &/@ insertions] /. {} -> All,
      {i, amplitudeNumbers}
   ];
   res = {
      deleteClasses[diagrams, daPairs, saveClassRules],
      deleteClasses[amplitudes, daPairs, saveClassRules]
   };
   Print@text;
   printDiagramsInfo@res[[1]];
   res
];
applyAction[
   diagrams:`type`diagramSet,
   {topologyQ:_, function:_, crit:_, text:_String}
] :=
Module[{
      d = diagrams
   },
   d = If[topologyQ@#[[1]], Part[#,1] -> function[Part[#,2], crit], #] &/@ d;
   d = removeTopologiesWithoutInsertions@d;
   Print@text;
   printDiagramsInfo@d;
   d
];
applyAction[
   diagrams:`type`diagramSet,
   {text:_String, topologyQ:_, {n:_Integer, f:_}}
] :=
Module[{
   },
   Do[
      If[topologyQ@getTopology@d,
         Print@text;
         Return[
            getTopology@d -> Table[{n -> Or[f, -f]}, {Length@getInsertions@d}]
         ]
      ];,
      {d, List@@diagrams}
   ]
];
applyAction[
   diagrams:`type`diagramSet,
   {text:_String, Rule[topologyQ:_, {t:`type`fa`field, n:_Integer}]}
] :=
Module[{
   },
   Do[
      If[topologyQ@getTopology@d,
         Print@text;
         Return[
            getTopology@d -> Table[genericMass[t, n], {Length@getInsertions@d}]
         ]
      ];,
      {d, List@@diagrams}
   ]
];
applyAction // Utils`MakeUnknownInputDefinition;
applyAction ~ SetAttributes ~ {Protected, Locked};

deleteClasses[amplitudes:`type`amplitudeSet,topoAmpList:`type`pickTopoAmp,classesToSave:`type`saveAmpClass] :=
Module[{i,numbersOfAmplitudes,numAmp,result = amplitudes},
   numbersOfAmplitudes = Cases[topoAmpList, Rule[True, {e:__}] :> e];
   Do[
      numAmp = Part[numbersOfAmplitudes,i];
      result[[numAmp,4,2]] = result[[numAmp,4,2]][[numAmp/.classesToSave]];
   ,{i,Length@numbersOfAmplitudes}];
   result
];
deleteClasses[diagrams:`type`diagramSet,topoAmpList:`type`pickTopoAmp,classesToSave:`type`saveAmpClass] :=
Module[{i,currentClasses,result = diagrams},
   Do[
      If[topoAmpList[[i,1]]===True,
         currentClasses = topoAmpList[[i,2]]/.classesToSave;
         currentClasses = Array[Rule[{#,2},result[[i,2,#,2]][[Part[currentClasses,#]]]]&,Length@currentClasses];
         result[[i,2]] = ReplacePart[result[[i,2]],currentClasses];
      ];
   ,{i,Length@topoAmpList}];
   result
];
deleteClasses // Utils`MakeUnknownInputDefinition;
deleteClasses ~ SetAttributes ~ {Protected,Locked};

modify::usage = "
@brief Changes amplitudes and diagrams according to excudeProcess list.
@param diagrams A set of diagrams.
@param amplitudes A set of amplitudes.
@param keepProcesses A set of names which specify the process to keep.
@returns A modified set of diagrams and amplitudes.";
modify[diagrams:`type`diagramSet, keepProcesses:`type`keepProcesses] :=
Module[{
      d = diagrams
   },
   Do[
      d = applyAction[d, ac];,
      {ac, getActions[keepProcesses, `settings`diagrams@diagrams]}
   ];
   d
];
modify[
   {diagrams:`type`diagramSet, amplitudes:`type`amplitudeSet},
   keepProcesses:`type`keepProcesses
] :=
Module[{
      d = diagrams, a = removeColours@amplitudes
   },
   Do[
      {d, a} = applyAction[{d, a}, ac];,
      {ac, getActions[keepProcesses, `settings`amplitudes]}
   ];
   {d, a}
];
modify // Utils`MakeUnknownInputDefinition;
modify ~ SetAttributes ~ {Protected,Locked};

removeColours[i:`type`diagramSet|`type`amplitudeSet] :=
   Delete[i, Position[i, FeynArts`Index[Global`Colour, _Integer]]];
removeColours // Utils`MakeUnknownInputDefinition;
removeColours ~ SetAttributes ~ {Protected, Locked};

getAmplitudeRules::usage = "
@brief Gives numbers of amplitudes, accepted by a criterion on topology.
@param diagrams A set of diagrams.
@param <one argument function> critFunction Function for topology selection. If
       critFunction[<topology>] gives True, then topology is accepted.
@returns {<Rule>} List of rules of the form <boolean>->{<integer>..}. LHS
         stands for the topology, RHS gives numbers of classes (and the numbers
         of amplitudes the same time).";
getAmplitudeRules[
   diagrams:`type`diagramSet,
   critFunction_
] :=
Module[
   {
      topologies = List@@First/@diagrams,
      genNums = Length/@(List@@Last/@diagrams),
      numRegions,takeOrNot
   },
   numRegions = Array[Range[Plus@@genNums[[1;;#-1]]+1,Plus@@genNums[[1;;#]]]&,Length@genNums];
   takeOrNot = Array[TrueQ@critFunction@Part[topologies,#]&,Length@topologies];
   MapThread[#1->#2&,{takeOrNot,numRegions}]
];
getAmplitudeRules // Utils`MakeUnknownInputDefinition;
getAmplitudeRules ~ SetAttributes ~ {Protected, Locked};

removeTopologiesWithoutInsertions[diagrams:`type`nullableDiagramSet] :=
   diagrams /. (FeynArts`Topology[_][__]->FeynArts`Insertions[Generic][]):>(##&[]);
removeTopologiesWithoutInsertions // Utils`MakeUnknownInputDefinition;
removeTopologiesWithoutInsertions ~ SetAttributes ~ {Protected,Locked};

removeClassInsertionsBy[classInsertions:FeynArts`Insertions[FeynArts`Classes][__],pattern___] :=
Module[{i,classList},
   classList = Cases[classInsertions,Except[FeynArts`FeynmanGraph[_Integer,FeynArts`Classes==_Integer][___,Sequence@@{pattern},___]]];
   If[classList=!={},
      classList=Table[classList[[i]]/.Equal[FeynArts`Classes,x_Integer]:>FeynArts`Classes==i,{i,Length@classList}]
   ];
   Head[classInsertions]@@classList
];
removeClassInsertionsBy // Utils`MakeUnknownInputDefinition;
removeClassInsertionsBy ~ SetAttributes ~ {Protected,Locked};

removeGenericInsertionsBy[genericInsertions:FeynArts`Insertions[Generic][__],pattern___] :=
Module[{i,genericList},
   genericList = Rule[#[[1]],removeClassInsertionsBy[#[[2]],pattern]] &/@ genericInsertions;
   genericList = genericList /. Rule[FeynArts`FeynmanGraph[_Integer,Generic==_Integer][__],FeynArts`Insertions[FeynArts`Classes][]] :> (##&[]);
   If[genericList=!=FeynArts`Insertions[Generic][],
      genericList = Table[genericList[[i]]/.Equal[Generic,x_Integer]:>Generic==i,{i,Length@genericList}]
   ];
   Head[genericInsertions]@@genericList
];
removeGenericInsertionsBy // Utils`MakeUnknownInputDefinition;
removeGenericInsertionsBy ~ SetAttributes ~ {Protected,Locked};

printDiagramsInfo[
   diagrams:`type`diagramSet,
   where_String:" "
] :=
Module[
   {
      nGeneric = Length@Cases[diagrams,Generic==_Integer:>1,Infinity,Heads -> True],
      nClasses = Length@Cases[diagrams,FeynArts`Classes==_Integer:>1,Infinity,Heads -> True]
   },
   Print[where,"in total: ",nGeneric," Generic, ",nClasses," Classes insertions"];
];

debugMakePictures[
   diagrams:`type`diagramSet,
   name_String:"classes"
] :=
Module[
   {
      directory = FileNameJoin[Most[FileNameSplit@@FeynArts`$Model]]
   },
   DeleteFile[FileNames[FileNameJoin@{directory, name<>"*"}]];
   Export[FileNameJoin@{directory,name<>".png"},FeynArts`Paint[diagrams,
      FeynArts`PaintLevel->{FeynArts`Classes},
      FeynArts`SheetHeader->name,
      FeynArts`Numbering->FeynArts`Simple]];
];

getFieldInsertions::usage = "
@brief Applies FindGenericInsertions[] to a set of diagrams or one.
@param set A set of diagrams.
@param diag A single diagram.
@param numQ Responsible for the type of output field names.
@returns For a single diagram returns List (for a given topology) of List
         (for all generic fields) of List (for all class fields) of rules
         {{{x->y,..},..},..}. For a set of diagrams, this construct is further
         transformed.";
getFieldInsertions[set:`type`diagramSet] :=
   Map[Last, #, {3}] &@ Flatten[ getFieldInsertions /@ (List @@ set), 1];

getFieldInsertions[diag:`type`diagram, numQ:True|False:False] :=
   FindGenericInsertions[#, numQ] &/@ Apply[List, getInsertions@diag, {0, 1}];

getFieldInsertions // Utils`MakeUnknownInputDefinition;
getFieldInsertions ~ SetAttributes ~ {Protected, Locked};

FindGenericInsertions::usage=
"@brief generic FeynmanGraph has rules Field[num]->particleType,
        class FeynmanGraph has rules Field[num]->particleClass.
        This function gives pairs particleType[gen,num]->particleClass, avoiding
        Field[_] mediator (if keepFieldNum==True then Field[_]->particleClass
        is given).
@param 1st argument is of the form
       {FeynmanGraph[__][__],Insertions[Classes][__]}.
@param 2nd argument changes the type of output field names
       True gives Field[_] names, False gives particleClass names.
@returns list (sorted; for all generic fields) of list (for all class fields)
         of rules {{x->y,..},..}.
@note this function is called by GenericInsertionsForDiagram[].
@note this function doesn't look at external particles.
@note all indices in rhs. of rules are removed.";
FindGenericInsertions[{graphGen_,insertCl_}, keepFieldNum_]:=
Module[
   {
      toGenericIndexConventionRules = Cases[graphGen,
         Rule[FeynArts`Field[index_Integer],type_Symbol] :>
         Rule[FeynArts`Field@index, type[FeynArts`Index[Generic,index]]]
      ],
      fieldsGen, genericInsertions
   },
   fieldsGen = toGenericIndexConventionRules[[All,1]];
   genericInsertions = Cases[#,
      Rule[genericField_,classesField_] /; MemberQ[fieldsGen, genericField] :>
      Rule[genericField, StripParticleIndices@classesField]] &/@ insertCl;
   SortBy[#,First]&/@ If[keepFieldNum,
      List @@ genericInsertions,
      List @@ genericInsertions /. toGenericIndexConventionRules
   ]
];

StripParticleIndices::usage="
@brief Removes particle indices from a given (possibley generic) field.
@param field the given field.
@returns The given field with all indices removed.";
StripParticleIndices[Times[-1,field_]] :=
   Times[-1, StripParticleIndices[field]];
StripParticleIndices[genericType_[classIndex_, ___]] :=
   genericType[classIndex];

getColourFactors::usage = "
@brief Creates colour factors for a given diagram.
@param ds A diagram set.
@param diagram A diagram to work with.
@returns List (for a given topology) of lists (for all generic fields) of
         colour factors.
@note During generation of genericDiagram at 1-loop level the ii-type loop
      propagators have the largest number because of FeynArts.
@note In seqProp numbers of the first vertices inside propagators are sorted
      by FeynArts.
@note External fields always come at first places in adjacency matrix.
@note This function doesn't know anything about CXXDiagrams`.` context.";
getColourFactors[ds:`type`diagramSet] :=
   Flatten[getColourFactors /@ (List @@ ds), 1] //. `rules`fieldNames;
getColourFactors[
   diagram:(_[_][seqProp__]->_[_][_[__][rulesFields__]->_,___])] :=
Module[
   {
      propPatt,adjacencyMatrix,externalRules,genericDiagram,genericInsertions
   },
   propPatt[i_, j_, f_] := _[_][_[_][i], _[_][j], f];

   adjacencyMatrix = Module[
      {adjs = Tally[{seqProp}/.propPatt[i_,j_,_]:>{{i,j},{j,i}}] },
      Normal@SparseArray@Flatten[{#[[1,1]]->#[[2]],#[[1,2]]->#[[2]]} &/@ adjs]];

   externalRules = Cases[{rulesFields}, HoldPattern[_[_]->_Symbol[__]]];

   genericDiagram = Module[
      {fld = Flatten[{seqProp}/.propPatt[i_,j_,f_]:>{{j,i,-f},{i,j,f}}, 1] },
      GatherBy[SortBy[fld,First],First] /. {_Integer, _Integer, f_} :> f
      ] /. Join[ {#} -> # &/@ externalRules[[All, 1]]];

   genericInsertions = getFieldInsertions[diagram, True];

   Map[CXXDiagrams`ColourFactorForIndexedDiagramFromGraph[
      CXXDiagrams`IndexDiagramFromGraph[
         genericDiagram /. externalRules /. #, adjacencyMatrix],
      adjacencyMatrix] &,
      genericInsertions,
      {2}]
];
getColourFactors // Utils`MakeUnknownInputDefinition;
getColourFactors ~ SetAttributes ~ {Protected, Locked};

getFermionOrder::usage = "
@brief Returns the order of fermions for FormCalc`FermionOrder option. Default
       is a reversed one. Can be overwritten by `settings`order for specific
       process.
@param expression A set of amplitudes or diagrams.
@note The order is cashed.
@returns A list of integers, representing an order of fermions.";
Module[{
      result
   },
   getFermionOrder[expression:`type`amplitudeSet|`type`diagramSet] :=
   If[Head@result === Symbol,
      If[# === {},
         Reverse@Range[Plus@@Length/@getProcess@expression],
         #
      ] &@ `settings`order,
      result
   ];
];
getFermionOrder // Utils`MakeUnknownInputDefinition;
getFermionOrder ~ SetAttributes ~ {Protected, Locked};

calculateAmplitudes::usage = "
@brief Applies FormCalc` routines to amplitude set, then simplifies the
       result, according to options.
@param diagrams A set of diagrams.
@param amplitudes A modified (without colour indices) set of amplitudes.
@param regularizationScheme A regularization scheme for the calculation.
@param zeroExternalMomenta A setting for handling of external momenta.
@param onShellFlag A setting for handling squared momenta.
@returns The main part of NPF object, containing: generic amplitudes,
         class specific insertions, subexpressions.";
calculateAmplitudes[
   {diagrams:`type`diagramSet, amplitudes:`type`amplitudeSet},
   regularizationScheme_,
   zeroExternalMomenta_,
   onShellFlag_] :=
Module[{
      proc = getProcess@amplitudes,
      masslessSettings = getMasslessSettings@diagrams,
      genericInsertions = getFieldInsertions@diagrams,

      combinatorialFactors = CombinatorialFactorsForClasses /@ List@@amplitudes,
      ampsGen = FeynArts`PickLevel[Generic][amplitudes],
      numExtParticles,
      feynAmps, generic, abbreviations,subexpressions,
      zeroedRules
   },
   numExtParticles = Plus@@Length/@proc;

   If[zeroExternalMomenta === True,
      (* Relations Mom[i]^2 = 0 are true now. *)
      ampsGen = FormCalc`OffShell[ampsGen, Sequence@@Array[#->0&, numExtParticles]]
   ];

   feynAmps = mapThread[
      FormCalc`CalcFeynAmp[Head[ampsGen][#1],
         FormCalc`Dimension -> #2,
         FormCalc`OnShell -> onShellFlag,
         FormCalc`FermionChains -> FormCalc`Chiral,
         FormCalc`FermionOrder -> getFermionOrder@diagrams,
         FormCalc`Invariants -> False,
         FormCalc`MomElim -> #3
      ]&,
      {
         ampsGen,
         getRegularizationSettings[#, regularizationScheme],
         getMomSettings@#
      } &@ diagrams,
      "Amplitude calculation"
   ] //. FormCalc`GenericList[];

   generic = MapThread[getGenericSum, {feynAmps, getSumSettings@diagrams}];

   abbreviations = simplifyChains[FormCalc`Abbr[] //. FormCalc`GenericList[]];
   abbreviations = modifyChains[abbreviations, diagrams, zeroExternalMomenta];
   {generic, abbreviations} = makeChainsUnique@{generic, abbreviations};
   abbreviations = identifySpinors[abbreviations, amplitudes];

   subexpressions = FormCalc`Subexpr[] //. FormCalc`GenericList[];

   If[zeroExternalMomenta === ExceptLoops,
      `rules`setZeroMasses@proc;
      generic = makeMassesZero[generic, masslessSettings];
      abbreviations = setZeroExternalMomentaInChains@abbreviations;
      abbreviations = abbreviations /. FormCalc`Pair[_,_] -> 0;
      abbreviations = abbreviations /. `rules`zeroExternalMasses;
      subexpressions = {};
   ];

   If[zeroExternalMomenta,
      abbreviations = setZeroExternalMomentaInChains@abbreviations;
      zeroedRules = Cases[FormCalc`Abbr[],
         Rule[_,pair:FormCalc`Pair[FormCalc`k[_], FormCalc`k[_]]]
         :> (pair->0)];
      {abbreviations, zeroedRules} = ZeroRules[abbreviations, zeroedRules];
      {subexpressions, zeroedRules} = ZeroRules[subexpressions, zeroedRules];
      generic = generic /. zeroedRules;
   ];

   FCAmplitudesToFSConvention[
      {
         generic,
         genericInsertions,
         combinatorialFactors,
         getColourFactors@diagrams
      },
      abbreviations,
      subexpressions
   ] /. getExternalMomentumRules[zeroExternalMomenta, amplitudes]
];
calculatedAmplitudes // Utils`MakeUnknownInputDefinition;
calculatedAmplitudes ~ SetAttributes ~ {Protected, Locked};

`rules`zeroExternalMasses::usage = "
@brief A static-like variable, which stores the set of nullify rules for
       external particles.";
`rules`zeroExternalMasses = {};
`rules`zeroExternalMasses // Protect;

`rules`setZeroMasses::usage = "
@brief For a given type of a process creates a set of rules to nullify masses
       of external particles.
@param expt A representation of the process under interest.
@return None.
@note Explicit names are expected only for external particles.";
`rules`setZeroMasses[expr:Rule[{{_, _, _, _}..}, {{_, _, _, _}..}]] :=
Module[
   {
      particles = First /@ Flatten[List@@expr, 1],
      uniqueNames, particleRules, fcRules
   },
   uniqueNames = DeleteDuplicates[particles /. (x:_)[i:_Integer, ___] :> x@i];
   particleRules = FeynArts`M$ClassesDescription /. Equal -> Rule;
   fcRules = Flatten[{#[_] -> 0, # -> 0} &/@ (FeynArts`Mass /. (uniqueNames /. particleRules))];
   Unprotect@`rules`zeroExternalMasses;
   `rules`zeroExternalMasses = Join[(FeynArts`Mass[#] -> 0) &/@ particles, fcRules];
   Protect@`rules`zeroExternalMasses;
];
`rules`setZeroMasses // Utils`MakeUnknownInputDefinition;
`rules`setZeroMasses ~ SetAttributes ~ {Protected, Locked};

makeMassesZero::usage = "
@brief Sets the masses of external particles to zero everywhere, except loop
       integrals and denominators.
@param expr An expression to modify.
@param masslessSettings A set of settings for amplitudes.
@returns A modified expression.";
makeMassesZero[expr:_, masslessSettings:_] :=
Module[
   {
      names = ToExpression/@Names@RegularExpression@"LoopTools`[ABCD]\\d+i*",
      pattern, uniqueIntegrals, integralRules, integralBack, masslessRules,
      uniqueDenominators, denominatorRules, denominatorBack, newExpr
   },
   pattern = Alternatives @@ ( #[__] &/@ names );
   uniqueIntegrals = DeleteDuplicates@Cases[expr, pattern, Infinity];
   integralRules = Rule[#, Unique@"loopIntegral"] &/@ uniqueIntegrals;
   integralBack = integralRules /. Rule[x_, y_] -> Rule[y, x];

   uniqueDenominators = DeleteDuplicates@Cases[expr, FormCalc`Den[_, _], Infinity];
   denominatorRules = Rule[#, Unique@"loopDenominator"] &/@ uniqueDenominators;
   denominatorBack = denominatorRules /. Rule[x_, y_] -> Rule[y, x];

   masslessRules = Table[
      DeleteDuplicates@Cases[expr[[i]], e:masslessSettings[[i]]:>(e->0), Infinity],
      {i, Length@expr}
   ];
   masslessRules = If[#==={}, `rules`zeroExternalMasses, #] &/@ masslessRules;

   newExpr = (expr//.FormCalc`Subexpr[]//.FormCalc`GenericList[]) /. integralRules /. denominatorRules;

   Table[newExpr[[i]] /. masslessRules[[i]] /. integralBack /. denominatorBack /. masslessRules[[i]] , {i, Length@expr}]
];
makeMassesZero // Utils`MakeUnknownInputDefinition;
makeMassesZero ~ SetAttributes ~ {Protected, Locked};

foreach::usage = "
@brief Applies a two-argument function on every element in the list. The first
       argument is substituted by the number of the element in the list, while
       the second one is the element itself.
@param f A two-argument function to apply on serial number and the element itself.
@param list A list of elements.
@returns A list of modified elements";
Module[{
      i = 0
   },
   foreach[f_, list:{e_, rest___}] := Flatten@{f[++i, e], foreach[f, {rest}]};
   foreach[f_, list:{}] := (i = 0; {});
   foreach // Utils`MakeUnknownInputDefinition;
   foreach ~ SetAttributes ~ {Protected, Locked};
];

setZeroExternalMomentaInChains::usage = "
@brief Sets FormCalc`k[i] to zero inside fermioinic chains.
@param abbreviations list of rules.
@returns Changed list of rules.";
setZeroExternalMomentaInChains[abbreviations:{Rule[_,_]...}] :=
Module[
   {
      replaceMomenta,temp,setZeroChainToZero
   },
   replaceMomenta[expr_] := expr/.FormCalc`k[_Integer]:>0;
   temp = abbreviations/.chain:FormCalc`DiracChain[__] :> replaceMomenta@chain;
   setZeroChainToZero[FormCalc`DiracChain[__,0,__]] := 0;
   setZeroChainToZero[chain:FormCalc`DiracChain[__]] := chain;
   temp/.chain:FormCalc`DiracChain[__] :> setZeroChainToZero@chain
];
setZeroExternalMomentaInChains // Utils`MakeUnknownInputDefinition;
setZeroExternalMomentaInChains ~ SetAttributes ~ {Protected,Locked};

mapThread::usage = "
@brief Maps a function onto multiple sets of equal length, accompanying it by
       printing a progress bar.
@param func A function to apply to set of data.
@param exprs A list of listable sets with data.
@param text A string to be printed.
@todo Add check for equality of length for exprs.";
mapThread[func_, exprs:{__}, text:_String:""] :=
Module[{
      sr, print, percent, init, end, bar, def = 70, dots,
      tot = Length@First@exprs, result
   },
   `time`set[];
   subWrite["\n"<>text<>" ...\n"];

   sr[str:_String, num:_Integer] := StringJoin@@Array[str&, num];

   print = (
      percent = #/tot;
      init = "["<>ToString@now<>"/"<>ToString@tot<>"] [";
      end = "] "<>ToString@Floor[100*percent]<>"%";
      bar = def - StringLength[init<>end];
      dots = Floor[bar*percent];
      subWrite@StringJoin[init, sr[".", dots], sr[" ", bar-dots],end,"\r"];
   )&;

   result = Table[(print@now; func@@(#[[now]]&/@ exprs)), {now, tot}];

   subWrite@"\033[K\033[A";
   subWrite[text<>" ... done in "<>`time`get[]<>" seconds.\n"];
   result
];
mapThread // Utils`MakeUnknownInputDefinition;
mapThread ~ SetAttributes ~ {Protected, Locked};

CombinatorialFactorsForClasses::usage="
@brief Takes generic amplitude and finds numerical combinatirical factors
       which arise at class level.
@returns list of combinatorical factors for a given generic amplitude
@param FeynArts`.`FeynAmp[__]";
CombinatorialFactorsForClasses[
   FeynArts`FeynAmp[_,_,_,rules_->_[_][classReplacements__]]
]:=
   {classReplacements}[[ All,#[[1,1]] ]] /.
      {
         FeynArts`IndexDelta[___] -> 1,
         FeynArts`SumOver[__] -> 1
      } &@
   Position[rules, FeynArts`RelativeCF];
CombinatorialFactorsForClasses // Utils`MakeUnknownInputDefinition;
CombinatorialFactorsForClasses ~ SetAttributes ~ {Locked,Protected};

getGenericFields::usage = "
@brief Generates a list of unique sorted generic fields in expression.
@param expr An expression, where to search.
@returns A list of unique sorted generic fields.";
getGenericFields[expr:_] :=
   Sort@DeleteDuplicates[Cases[expr, `type`FAfieldGeneric, Infinity]];
getGenericFields // Utils`MakeUnknownInputDefinition;
getGenericFields ~ SetAttributes ~ {Protected, Locked};

getGenericSum::usage= "
@brief Converts FormCalc`Amp into NPointFunctions`GenericSum object using
       restriction rules for generic fields.
@param amplitude FormCalc`Amp expression.
@param sumRules A set of rules, restricting the summation.
@returns A NPointFunctions`GenericSum object.";
getGenericSum[
   amplitude:`type`fc`amplitude,
   sumRules:{Rule[_Integer, _]...}] :=
Module[{
      sort = getGenericFields@amplitude,
      rules = Append[sumRules, _Integer -> False]
   },
   GenericSum[
      List@@amplitude,
      sort /. f_[_[_,i_]] :> {f@GenericIndex@i, i /. rules}
   ]
];
getGenericSum // Utils`MakeUnknownInputDefinition;
getGenericSum ~ SetAttributes ~ {Protected, Locked};

ZeroRules::usage=
"@brief Given a set of rules that map to zero and a set that does
not map to zero, apply the zero rules to the non-zero ones
recursively until the non-zero rules do not change anymore.
@param nonzeroRules the list of nonzero rules
@param zeroRules the list of zero rules
@returns a list of rules that map the same expressions as the initial rules.
The return value is of the form {{Rule[_,_]...},{Rule[_,0]...}}";
ZeroRules[nonzeroRules:{Rule[_,_]...}, zeroRules:{Rule[_,0]...}] :=
Module[{newNonzero, newZeroRules},
   newNonzero = Thread[
      Rule[nonzeroRules[[All,1]],nonzeroRules[[All,2]] /. zeroRules]];

   If[newNonzero === nonzeroRules, Return[{nonzeroRules, zeroRules}]];

   newZeroRules = Cases[newNonzero,HoldPattern[_->0]];
   newNonzero = Complement[newNonzero, newZeroRules];

   ZeroRules[newNonzero, Join[zeroRules,newZeroRules]]
];

FCAmplitudesToFSConvention::usage=
"@brief Tranlate a list of FormCalc amplitudes and their abbreviations and
subexpressions into FlexibleSUSY language.
@param amplitudes the given list of amplitudes
@param abbreviations list of abbreviations
@param aubexpressions list of subexpressions
@returns a list of the form
`{fsAmplitudes, Join[fsAbbreviations,fsSubexpressions]}`
where all FlexibleSUSY conventions have been applied.";
FCAmplitudesToFSConvention[amplitudes_, abbreviations_, subexpressions_] :=
Module[{fsAmplitudes, fsAbbreviations, fsSubexpressions},
   fsAmplitudes = amplitudes //. `rules`amplitudes;
   fsAbbreviations = abbreviations //. `rules`subexpressions //. {FormCalc`DiracChain->NPointFunctions`internal`dc,FormCalc`Spinor->SARAH`DiracSpinor,FormCalc`Lor->SARAH`Lorentz};
   fsSubexpressions = subexpressions //. `rules`subexpressions;
   {fsAmplitudes, Join[fsAbbreviations,fsSubexpressions]}
];

SetAttributes[
   {
   NPointFunctionFAFC,
   FindGenericInsertions,StripParticleIndices,
   ZeroRules,FCAmplitudesToFSConvention
   },
   {Protected, Locked}];

End[];
EndPackage[];
