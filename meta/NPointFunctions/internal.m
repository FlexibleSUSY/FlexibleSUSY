(* :Copyright:

   ====================================================================
   This file is part of FlexibleSUSY.

   FlexibleSUSY is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published
   by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   FlexibleSUSY is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with FlexibleSUSY.  If not, see
   <http://www.gnu.org/licenses/>.
   ====================================================================

*)

BeginPackage["NPointFunctions`",{"FeynArts`","FormCalc`","Utils`"}];
FeynArts`$FAVerbose = 1;(* Change this to 2 to see more output (1 - less) *)
FormCalc`$FCVerbose = 0;(* Change this to 1,2 or 3 to see more output *)

{setInitialValues,NPointFunctionFAFC}

(* symbols that are not distributed from main kernel*)
SetAttributes[#,{Locked,Protected}]&@
{
   LorentzIndex,GenericSum,GenericIndex,
   GenericS,GenericF,GenericV,GenericU,GenericT,
   LoopLevel,Regularize,ZeroExternalMomenta,OnShellFlag,ExcludeProcesses
};
(* symbols that can be distributed from main kernel*)
If[Attributes[#]=!={Locked,Protected},SetAttributes[#,{Locked,Protected}]]&/@
{
   DimensionalReduction,DimensionalRegularization,
   (*for further details inspect topologyReplacements*)
   ExceptIrreducible,ExceptBoxes,ExceptTriangles,ExceptFourFermionScalarPenguins
};

Begin["`Private`"];
calledPreviouslysetInitialValues::usage=
"@brief is used to prohibid multiple calls of 
NPointFunctions`.`setInitialValues[].";
calledPreviouslysetInitialValues = False;

feynArtsDir = "";
formCalcDir = "";
feynArtsModel = "";
particleNamesFile = "";
substitutionsFile = "";
particleNamespaceFile = "";

subexpressionToFSRules::usage=
"A set of rules that aid translation between FeynArts and FlexibleSUSY language.
They should be applied to subexpressions generated by FeynArts.";
subexpressionToFSRules = {};

fieldNameToFSRules::usage=
"A set of rules for @todo";
fieldNameToFSRules = {};

amplitudeToFSRules::usage=
"A set of rules for @todo";
amplitudeToFSRules= {};

Protect[calledPreviouslysetInitialValues,feynArtsDir,formCalcDir,feynArtsModel,
   particleNamesFile,substitutionsFile,particleNamespaceFile,
   subexpressionToFSRules,fieldNameToFSRules,amplitudeToFSRules
];

setInitialValues::usage=
"@brief Set the FeynArts and FormCalc paths.
@param FADirS the directory designated for FeynArts output
@param FCDirS the directory designated for FormCalc output
@param FAModelS the name of the FeynArts model file
@param particleNamesFileS the name of the SARAH-generated particle names file
@param substitutionsFileS the name of the SARAH-generated substitutions file
@param particleNamespaceFileS the name of the particle namespace file
@note allowed to be called only once
@note effectively Private function";
setInitialValues::errOnce=
"NPointFunctions`.`setInitialValues[]: Multiple calls:
something tries to redefine paths for FeynArts and FormCalc";
setInitialValues[FADir_String, FCDir_String, FAModel_String,
   particleNamesFileS_String, substitutionsFileS_String,
   particleNamespaceFileS_String] :=
If[Utils`AssertOrQuit[!calledPreviouslysetInitialValues,setInitialValues::errOnce],
   ClearAttributes[
      {
         feynArtsDir,formCalcDir,feynArtsModel,
         particleNamesFile,substitutionsFile,particleNamespaceFile,
         calledPreviouslysetInitialValues
      },{Protected}];
   feynArtsDir = FADir;
   formCalcDir = FCDir;
   feynArtsModel = FAModel;
   particleNamesFile = particleNamesFileS;
   substitutionsFile = substitutionsFileS;
   particleNamespaceFile = particleNamespaceFileS;
   calledPreviouslysetInitialValues = True;
   SetAttributes[
      {
         feynArtsDir,formCalcDir,feynArtsModel,
         particleNamesFile,substitutionsFile,particleNamespaceFile,
         calledPreviouslysetInitialValues
      },{Protected, Locked}];
   SetFSConventionRules[];
];
SetAttributes[setInitialValues,{Protected,Locked}];

SetFSConventionRules::usage=
"@brief Set the translation rules from FeynArts/FormCalc to FlexibleSUSY 
language.";
SetFSConventionRules::errSARAH=
"It seems that SARAH`.` has changed conventions for
<ParticleNames>.dat file.";
SetFSConventionRules[] :=
Module[
   {
      fieldNames,indexRules,massRules,couplingRules,generalFCRules,
      diracChainRules,sumOverRules
   },

   fieldNames =
   Flatten[
      StringCases[
         Utils`ReadLinesInFile@particleNamesFile, 
         x__ ~~ ": " ~~ y__ ~~ "]" ~~ ___ :> {x,y}],
      1] /. 
      Apply[Rule, {#[[1]], #[[2]] <> #[[1]]} & /@ Get@particleNamespaceFile, 2];
   Utils`AssertWithMessage[Length@fieldNames > 0,
      SetFSConventionRules::errSARAH];
   massRules = Append[Flatten[Module[
      {P="SARAH`Mass@"<>#,MassP="Mass"<>ToString@Symbol@#},
      {
         ToExpression[MassP <> "@indices_:>" <> P <> 
         "@{Symbol[\"SARAH`gt\"<>StringTake[SymbolName@indices,-1]]}"],
         ToExpression[MassP <> "@indices__:>" <> P <> "@{indices}"],
         ToExpression[MassP <> "->" <> P]
      }
      ] &/@ fieldNames[[All, 1]] ],
      FeynArts`Mass[field_, _ : Null] :> SARAH`Mass[field]
   ];

   couplingRules =
   {
      FeynArts`G[_][0][fields__][1] :> 
      SARAH`Cp[fields][1],
         
      FeynArts`G[_][0][fields__][
         FeynArts`NonCommutative[
            Global`ChiralityProjector[-1]
         ]
      ] :>
      SARAH`Cp[fields][SARAH`PL],
      
      FeynArts`G[_][0][fields__][
         FeynArts`NonCommutative[
            Global`ChiralityProjector[1]
         ]
      ] :>
      SARAH`Cp[fields][SARAH`PR],
      
      FeynArts`G[_][0][fields__][
         FeynArts`NonCommutative[
            Global`DiracMatrix@FeynArts`KI1@3,
            Global`ChiralityProjector[-1]
         ]
      ] :>
      SARAH`Cp[fields][SARAH`PL],
      
      FeynArts`G[_][0][fields__][
         FeynArts`NonCommutative[
            Global`DiracMatrix@FeynArts`KI1@3,
            Global`ChiralityProjector[1]
         ]
      ] :>
      SARAH`Cp[fields][SARAH`PR],
      
      FeynArts`G[_][0][fields__][
         Global`MetricTensor[
            KI1[i1_Integer],
            KI1[i2_Integer]
         ]
      ] :>
      SARAH`Cp[fields][
         SARAH`g[
            LorentzIndex[ {fields}[[i1]] ],
            LorentzIndex[ {fields}[[i2]] ]
         ]
      ],
         
      FeynArts`G[_][0][fields__][
         FeynArts`Mom[ i1_Integer ] - FeynArts`Mom[ i2_Integer ]
      ] :>
      SARAH`Cp[fields][
         SARAH`Mom[ {fields}[[i1]] ] - SARAH`Mom[ {fields}[[i2]] ]
      ],
      
      (*Since FormCalc-9.7*)
      FeynArts`G[_][0][fields__][
         Global`FourVector[
            FeynArts`Mom[ i1_Integer ] - FeynArts`Mom[ i2_Integer ],
            FeynArts`KI1[3]
         ]
      ] :>
      SARAH`Cp[fields][
         SARAH`Mom[ {fields}[[i1]] ] - SARAH`Mom[ {fields}[[i2]] ]
      ],
      
      (*VVV couplings*)
      FeynArts`G[_][0][fields__][
         Global`FourVector[
            - FeynArts`Mom[i1_Integer] + FeynArts`Mom[i2_Integer],
            FeynArts`KI1[i3_Integer]
         ]*
         Global`MetricTensor[FeynArts`KI1[i1_Integer],FeynArts`KI1[i2_Integer]]+
         Global`FourVector[
            FeynArts`Mom[i1_Integer] - FeynArts`Mom[i3_Integer],
            FeynArts`KI1[i2_Integer]
         ]*
         Global`MetricTensor[FeynArts`KI1[i1_Integer],FeynArts`KI1[i3_Integer]]+
         Global`FourVector[
            -FeynArts`Mom[i2_Integer] + FeynArts`Mom[i3_Integer],
            FeynArts`KI1[i1_Integer]
         ]*
         Global`MetricTensor[FeynArts`KI1[i2_Integer],FeynArts`KI1[i3_Integer]]
      ] :>
      SARAH`Cp[fields][
         (SARAH`Mom[{fields}[[i2]], LorentzIndex[{fields}[[i3]]]] -
         SARAH`Mom[{fields}[[i1]], LorentzIndex[{fields}[[i3]]]]) *
         SARAH`g[LorentzIndex[ {fields}[[i1]] ],LorentzIndex[ {fields}[[i2]] ] ]
         ,
         (SARAH`Mom[{fields}[[i1]], LorentzIndex[{fields}[[i2]]]] - 
         SARAH`Mom[{fields}[[i3]], LorentzIndex[{fields}[[i2]]]]) *
         SARAH`g[LorentzIndex[ {fields}[[i1]] ],LorentzIndex[ {fields}[[i3]] ] ]
         , 
         (SARAH`Mom[{fields}[[i3]], LorentzIndex[{fields}[[i1]]]] -
         SARAH`Mom[{fields}[[i2]], LorentzIndex[{fields}[[i1]]]]) *
         SARAH`g[LorentzIndex[ {fields}[[i2]] ],LorentzIndex[ {fields}[[i3]] ] ]
      ]
   };

   generalFCRules =
   {                                                                            (* @unote sec 4.4 of FormCalc manual *)
      FormCalc`Finite -> 1,
      FormCalc`Den[a_,b_] :> 1/(a - b),
      FormCalc`Pair[a_,b_] :> Module[{uniqueSumIndex=Unique@"SARAH`lt"},
         SARAH`sum[uniqueSumIndex, 1, 4, SARAH`g[uniqueSumIndex, uniqueSumIndex] * 
            Append[a, uniqueSumIndex] * Append[b, uniqueSumIndex]]
      ],
      fieldType_?(FAFieldQ)[FeynArts`Index[Generic,number_Integer]
      ] :> fieldType@GenericIndex@number,
      FormCalc`k[i_Integer, index___] :> SARAH`Mom[i, index]                    (* @note rule for external momenta *)
   };

   indexRules =                                                                 (*These index rules are specific to SARAH generated FeynArts model files.*) 
   {                                                                            (*Are these index rules always injective?*)
      FeynArts`Index[generationName_, index_Integer] :> 
      Symbol["SARAH`gt" <> ToString@index] /;
         StringMatchQ[SymbolName@generationName, "I"~~___~~"Gen"],
      FeynArts`Index[Global`Colour, index_Integer] :>
      Symbol["SARAH`ct" <> ToString@index],
      FeynArts`Index[Global`Gluon, index_Integer] :>                            (* @todo Potentially dangerous stuff. Gluon goes from 1 to 8, not from 1 to 3 as Colour*)
      Symbol["SARAH`ct" <> ToString@index]                                      (* *)
   };
   
   sumOverRules =
   {
      FeynArts`SumOver[_,_,FeynArts`External] :> Sequence[],
      Times[expr_,FeynArts`SumOver[index_,max_Integer]] :> 
         SARAH`sum[index,1,max,expr],
      Times[expr_,FeynArts`SumOver[index_,{min_Integer,max_Integer}]] :> 
         SARAH`sum[index,min,max,expr],
      SARAH`sum[index_,_Integer,max_Integer,FeynArts`SumOver[_,max2_Integer]] :>            (* @todo check these weird convention rules *)
         SARAH`sum[index,1,max,max2],                                                       (* *)
      SARAH`sum[index_,_Integer,max_Integer,FeynArts`SumOver[_,{min2_Integer,max2_Integer}]](* *)
    :> SARAH`sum[index,1,max,max2-min2]                                                     (* *)
};

   Unprotect@fieldNameToFSRules;
   fieldNameToFSRules = Join[
      ToExpression[#[[2]] <> "]->" <> #[[1]]] &/@ 
         fieldNames,
      ToExpression[#[[2]] <> ",{indices___}]:>" <> #[[1]] <> "[{indices}]"] &/@ 
         fieldNames,
      {
         FeynArts`S -> GenericS, FeynArts`F -> GenericF, FeynArts`V -> GenericV,
         FeynArts`U -> GenericU, FeynArts`T -> GenericT
      },
      {
         Times[-1, field_GenericS | field_GenericV] :>
         Susyno`LieGroups`conj@field,
         Times[-1, field_GenericF | field_GenericU] :>
         SARAH`bar@field
      },
      (Times[-1, field: # | Blank@#] :> CXXDiagrams`LorentzConjugate@field) &/@ (* @todo for what is this? *)
         (ToExpression /@ fieldNames[[All,1]]),                                 (* *)
      indexRules
   ];
   Protect@fieldNameToFSRules;

   (*These symbols cause an overshadowing with Susyno`LieGroups @todo what is this*)
   diracChainRules = Symbol["F" <> ToString@#] :> Unique@"diracChain" &/@ 
      Range@Length@fieldNames;
   
   Unprotect@subexpressionToFSRules;
   subexpressionToFSRules = Join[
      massRules,
      fieldNameToFSRules,
      couplingRules,
      generalFCRules,
      diracChainRules
   ];
   Protect@subexpressionToFSRules;
   
   Unprotect@amplitudeToFSRules;
   amplitudeToFSRules = Join[
      subexpressionToFSRules,
      sumOverRules,
      {FeynArts`IndexSum -> Sum}
   ];
   Protect@amplitudeToFSRules;
];

Options[NPointFunctionFAFC]={
   LoopLevel -> 1,
   Regularize -> DimensionalReduction,
   ZeroExternalMomenta -> True,
   OnShellFlag -> False,
   ExcludeProcesses -> {}
};
NPointFunctionFAFC::usage=
"@note effectively Private function, see usage of NPointFunction[]";
NPointFunctionFAFC[inFields_,outFields_,OptionsPattern[]] :=
Module[
   {
      topologies, diagrams, amplitudes, genericInsertions, colourFactors, 
      fsFields, fsInFields, fsOutFields, externalMomentumRules, nPointFunction
   },

   If[!DirectoryQ@formCalcDir,CreateDirectory@formCalcDir];
   SetDirectory@formCalcDir;

   topologies = FeynArts`CreateTopologies[OptionValue@LoopLevel,
      Length@inFields -> Length@outFields,
      FeynArts`ExcludeTopologies -> getExcludedTopologies@OptionValue@ExcludeProcesses];
   
   diagrams = FeynArts`InsertFields[topologies,
      inFields -> outFields,
      FeynArts`InsertionLevel -> FeynArts`Classes,
      FeynArts`Model -> feynArtsModel];
   diagrams = getModifiedDiagrams[diagrams,OptionValue@ExcludeProcesses];
      
   DeleteFile[FileNames[FileNameJoin@{feynArtsDir, "out*"}]];
   Export[FileNameJoin@{feynArtsDir,"out.jpg"},FeynArts`Paint[diagrams,
      FeynArts`PaintLevel->{Generic},
      FeynArts`SheetHeader->"GenericSum",
      FeynArts`Numbering->FeynArts`Simple]];                                    (* @todo remove *)
      
   amplitudes = FeynArts`CreateFeynAmp@diagrams;

   amplitudes = Delete[amplitudes,
      Position[amplitudes,FeynArts`Index[Global`Colour,_Integer]]];             (*@unote Remove colour indices following assumption 1*)
   
   genericInsertions = Map[Last,#,{3}] &@ Flatten[                              (* Everything is sorted already, so we need only field-replacement names *)
      GenericInsertionsForDiagram /@ (List @@ diagrams), 1];
   colourFactors = Flatten[
      ColourFactorForDiagram /@ (List @@ diagrams), 1] //.
      fieldNameToFSRules;
   
   fsInFields = Head[amplitudes][[1,2,1,All,1]] //. fieldNameToFSRules;
   fsOutFields = Head[amplitudes][[1,2,2,All,1]] //. fieldNameToFSRules;

   fsFields = Join[fsInFields,fsOutFields];

   externalMomentumRules = {
      If[OptionValue@ZeroExternalMomenta,
         SARAH`Mom[_Integer,_] :> 0,
         SARAH`Mom[i_Integer, lorIndex_] :> SARAH`Mom[fsFields[[i]], lorIndex]]
   };
   nPointFunction = {
      {fsInFields, fsOutFields},
      Insert[
         CalculateAmplitudes[amplitudes,genericInsertions,
            OptionValue@Regularize,
            OptionValue@ZeroExternalMomenta,
            OptionValue@OnShellFlag
         ] /. externalMomentumRules,
         colourFactors,
         {1, -1}]
   }
];

topologyReplacements::usage =
"@brief List of topology replacement rules for a processes to hold.";
topologyReplacements =
{
   ExceptIrreducible -> (FreeQ[#,FeynArts`Internal]&),
   ExceptTriangles -> (FreeQ[FeynArts`ToTree@#,FeynArts`Centre@Except@3]&),
   ExceptBoxes -> (FreeQ[FeynArts`ToTree@#,FeynArts`Centre@Except@4]&),
   ExceptFourFermionScalarPenguins -> (amIPinguin@#&)
};
SetAttributes[topologyReplacements,{Protected,Locked}];

getExcludedTopologies::usage =
"@brief Joins names of processes to hold into one functions, creates unique 
name for it, then registers it for FeynArts` and returns the name.
@param <{Symbol...} | Symbol> name(s) of processes to hold.
@returns <Symbol> generated name of topologies to hold.";
getExcludedTopologies::errUnknownInput =
"Input should be
getExcludedTopologies@@{ <{Symbol...} | Symbol> }
and not
getExcludedTopologies@@`1`";
getExcludedTopologies[{}] :=
{};
getExcludedTopologies[{sym_Symbol}] :=
getExcludedTopologies@sym;
getExcludedTopologies[syms:{__Symbol}] :=
Module[{excludeTopologyName},
   FeynArts`$ExcludeTopologies[excludeTopologyName] =
      (Or @@ Through[(syms/.topologyReplacements)@#])&;
   excludeTopologyName];
getExcludedTopologies[sym_Symbol] :=
Module[{excludeTopologyName},
   FeynArts`$ExcludeTopologies[excludeTopologyName] = sym/.topologyReplacements;
   excludeTopologyName];
getExcludedTopologies[x___] :=
Utils`AssertOrQuit[False,getExcludedTopologies::errUnknownInput,{x}];
SetAttributes[getExcludedTopologies,{Protected,Locked}];

amIPinguin::usage =
"@brief If given topology is pinguin-like (mainly, for CLFV processes), then 
returns True, False otherwise.
@param <FeynArts`Topology[_][__]> topology to check.
@returns <boolean> If given topology is pinguin-like (mainly, for CLFV processes), then 
returns True, False otherwise.";
amIPinguin::errUnknownInput =
"Input should be
amIPinguin@@{ <FeynArts`.`Topology[_][__]> }
and not
amIPinguin@@`1`";
amIPinguin[topology:FeynArts`Topology[_][__]] :=
Module[
   {
      (*@note During creation of topologies we have External only.*)
      extType = FeynArts`External|FeynArts`Incoming|FeynArts`Outgoing,
      extFields
   },
   extFields = Cases[topology, _[extType][__]];
   If[UnsameQ[Length@extFields, 4],Return@False];
   If[! FreeQ[extFields, FeynArts`Vertex@4],Return@False];
   If[FreeQ[FeynArts`ToTree@topology,FeynArts`Centre@Except@3],Return@True];
   (*@note ,___ in the very end is for the stage when Field can appear.*)
   SameQ[Length@Cases[FeynArts`ToTree@topology,_[extType][_,FeynArts`Centre[2][_],___]],1]
];
amIPinguin[x___] :=
Utils`AssertOrQuit[False,amIPinguin::errUnknownInput,{x}];
SetAttributes[amIPinguin,{Protected,Locked}];

getModifiedDiagrams::usage = 
"@brief Excludes some field insertions according to excudeProcess list.
@param <TopologyList[_][__]> set of topology-insertion rules to modify.
@param <List> set of names which specify the process to consider.
@returns <TopologyList[_][__]> modified set of topologies.";
getModifiedDiagrams::errUnknownInput =
"Input should be
getModifiedDiagrams@@{ <TopologyList[_][__]>, <List> }
and not
getModifiedDiagrams@@`1`";
getModifiedDiagrams[
   inserted:FeynArts`TopologyList[_][Rule[FeynArts`Topology[_][__],FeynArts`Insertions[Generic][__]]..],
   excludeProcesses:{___}] :=
Module[
   {
   },
   If[MemberQ[excludeProcesses,ExceptFourFermionScalarPenguins],
      inserted = If[amIPinguin[#[[1]]],
         (*Delete vector fields on tree-level like propagator.*)
         #[[1]]->FeynArts`DiagramSelect[#[[2]],FreeQ[#,FeynArts`Field@5->FeynArts`V]&],
         (*Else do not touch.*)
         #]&/@ inserted;
      Print["penguins: stu propagation of vector bosons is excluded"];
   ];
   inserted
];
getModifiedDiagrams[x___] :=
Utils`AssertOrQuit[False,getModifiedDiagrams::errUnknownInput,{x}];
SetAttributes[getModifiedDiagrams,{Protected,Locked}];

GenericInsertionsForDiagram::usage=
"@brief applies FindGenericInsertions[] to a 
(Topology[_]->Insertions[Generic][__]) rule.
@returns list (for a given topology) of list (for all generic fields)
of list (for all class fields) of rules {{{x->y,..},..},..}
@param 1st argument is of the form Topology[_]->Insertions[Generic][__]
from FeynArts TopologyList[__][Topology[_]->Insertions[Generic][__],___]
@param 2nd argument changes the type of output field names
@note all indices in rhs. of rules are removed";
GenericInsertionsForDiagram[_->insertGen_, keepFieldNum_:False]:=
Map[FindGenericInsertions[#,keepFieldNum]&, Apply[List,insertGen,{0,1}]];

FindGenericInsertions::usage=
"@brief generic FeynmanGraph has rules Field[num]->particleType, 
class FeynmanGraph has rules Field[num]->particleClass. 
This function gives pairs particleType[gen,num]->particleClass, avoiding 
Field[_] mediator (if keepFieldNum==True then Field[_]->particleClass is given) 
@param 1st argument is of the form 
{FeynmanGraph[__][__],Insertions[Classes][__]}
@param 2nd argument changes the type of output field names
True gives Field[_] names, False gives particleClass names
@returns list (sorted; for all generic fields) of list (for all class fields) 
of rules {{x->y,..},..}
@note this function is called by GenericInsertionsForDiagram[]
@note this function doesn't look at external particles
@note all indices in rhs. of rules are removed";
FindGenericInsertions[{graphGen_,insertCl_}, keepFieldNum_]:=
Module[
   {
      toGenericIndexConventionRules = Cases[graphGen, 
         Rule[FeynArts`Field[index_Integer],type_Symbol] :>
         Rule[FeynArts`Field@index, type[FeynArts`Index[Generic,index]]]
      ], 
      fieldsGen, genericInsertions
   },
   fieldsGen = toGenericIndexConventionRules[[All,1]];
   genericInsertions = Cases[#, 
      Rule[genericField_,classesField_] /; MemberQ[fieldsGen, genericField] :>
      Rule[genericField, StripParticleIndices@classesField]] &/@ insertCl;
   SortBy[#,First]&/@ If[keepFieldNum,
      List @@ genericInsertions,
      List @@ genericInsertions /. toGenericIndexConventionRules
   ]
];

StripParticleIndices::usage=
"@brief Remove particle indices from a given (possibley generic) field
@param field the given field
@returns the given field with all indices removed";
StripParticleIndices[Times[-1,field_]] := 
   Times[-1, StripParticleIndices[field]];
StripParticleIndices[genericType_[classIndex_, ___]] := 
   genericType[classIndex];

ColourFactorForDiagram::usage=
"@brief acts on a (Topology[_]->Insertions[Generic][__]) rule.
creates adjacency matrix and field array for this topology and uses this
information for creation of colour factors for a given topology 
@param diagram (Topology[_]->Insertions[Generic][__]) rule
@returns list (for a given topology) of lists (for all generic fields) of 
(potentially) colour factors
@note during generation of genericDiagram at 1-loop level the ii-type loop
propagators have the largest number because of FeynArts
@note in seqProp numbers of the first vertices inside propagators are sorted
by FeynArts
@note external fields always come at first places in adjacency matrix
@note this function doesn't know anything about CXXDiagrams`.` context";
ColourFactorForDiagram[
   diagram:(_[_][seqProp__]->_[_][_[__][rulesFields__]->_,___])] :=
Module[
   {
      propPatt,adjacencyMatrix,externalRules,genericDiagram,genericInsertions
   },
   propPatt[i_, j_, f_] := _[_][_[_][i], _[_][j], f];
   
   adjacencyMatrix = Module[
      {adjs = Tally[{seqProp}/.propPatt[i_,j_,_]:>{{i,j},{j,i}}] },
      Normal@SparseArray@Flatten[{#[[1,1]]->#[[2]],#[[1,2]]->#[[2]]} &/@ adjs]];
      
   externalRules = Cases[{rulesFields}, HoldPattern[_[_]->_Symbol[__]]];
   
   genericDiagram = Module[
      {fld = Flatten[{seqProp}/.propPatt[i_,j_,f_]:>{{j,i,-f},{i,j,f}}, 1] },
      GatherBy[SortBy[fld,First],First] /. {_Integer, _Integer, f_} :> f
      ] /. Join[ {#} -> # &/@ externalRules[[All, 1]]];
      
   genericInsertions = GenericInsertionsForDiagram[diagram,True];
   
   Map[CXXDiagrams`ColourFactorForIndexedDiagramFromGraph[
      CXXDiagrams`IndexDiagramFromGraph[
         genericDiagram /. externalRules /. #, adjacencyMatrix],
      adjacencyMatrix] &,
      genericInsertions,
      {2}]
];

CalculateAmplitudes::usage=
"@brief Calculate a given set of amplitudes.
@param amps A set of class level amplitudes as generated by 
FeynArts`.`CreateFeynAmp[] (with colour indices removed)
form:
FeynAmpList[___][FeynAmp[
   GraphID[__],
   Integral[mom_],
   amp_,
   {whatIsInAmp___}->Insertion[Classes][{howToReplace___}..]]..]
@param genericInsertions the list of generic insertions for the amplitudes
@param regularizationScheme the regularization scheme for the calculation
@param zeroExternalMomenta True if external momenta should be set to zero and 
False otherwise
@returns a list of the format {fsAmplitudes, subexpressions} where 
fsAmplitudes denote the calculated amplitudes and subexpressions denote 
the subexpressions used to simplify the expressions";
CalculateAmplitudes[
   amps:FeynArts`FeynAmpList[___,FeynArts`Process->proc_,___][feynAmps:_[__]..],
   genericInsertions_List,
   regularizationScheme_,
   zeroExternalMomenta_,
   onShellFlag_] :=
Module[
   {
      combinatorialFactors = CombinatorialFactorsForClasses /@ {feynAmps},
      ampsGen = FeynArts`PickLevel[Generic][amps],
      numExtParticles = Plus@@Length/@proc,
      calculatedAmplitudes,abbreviations,subexpressions,
      zeroedRules
   },
   ampsGen = If[zeroExternalMomenta,
      FormCalc`OffShell[ampsGen, Sequence@@Array[#->0&,numExtParticles] ],
      ampsGen];
      
   Print["FORM calculation started ..."];
   calculatedAmplitudes = applyAndPrint[
      FormCalc`CalcFeynAmp[Head[ampsGen][#],
         FormCalc`Dimension -> Switch[regularizationScheme,
            DimensionalReduction, 4,
            DimensionalRegularization, D],
         FormCalc`OnShell -> onShellFlag,
         FormCalc`FermionChains -> FormCalc`Chiral,
         FormCalc`FermionOrder -> Switch[getNumberOfChains@ampsGen,
            2, FormCalc`Fierz,
            _, None],
         FormCalc`Invariants -> False]&,
      ampsGen] //. FormCalc`GenericList[];
   Print["FORM calculation done."];
   
   calculatedAmplitudes = ToGenericSum /@ calculatedAmplitudes;

   abbreviations = identifySpinors[FormCalc`Abbr[] //. FormCalc`GenericList[],ampsGen];
   subexpressions = FormCalc`Subexpr[] //. FormCalc`GenericList[];
   If[zeroExternalMomenta,
      abbreviations = setZeroExternalMomentaInChains@abbreviations;
      zeroedRules = Cases[FormCalc`Abbr[],
         Rule[_,pair:FormCalc`Pair[FormCalc`k[_], FormCalc`k[_]]]
         :> (pair->0)];
      {abbreviations, zeroedRules} = ZeroRules[abbreviations, zeroedRules];
      {subexpressions, zeroedRules} = ZeroRules[subexpressions, zeroedRules];
      calculatedAmplitudes = calculatedAmplitudes /. zeroedRules;];

   FCAmplitudesToFSConvention[
      {calculatedAmplitudes, genericInsertions, combinatorialFactors},
      abbreviations, subexpressions]
];

setZeroExternalMomentaInChains::usage =
"@brief Sets FormCalc`k[i] to zero inside fermioinic chains.
@param abbreviations list of rules.
@returns Changed list of rules.";
setZeroExternalMomentaInChains::errUnknownInput =
"Input should be
setZeroExternalMomentaInChains@@{ <list of rules> }
and not
setZeroExternalMomentaInChains@@`1`";
setZeroExternalMomentaInChains[abbreviations:{Rule[_,_]...}] :=
Module[
   {
      replaceMomenta,temp,setZeroChainToZero
   },
   replaceMomenta[expr_] := expr/.FormCalc`k[_Integer]:>0;
   temp = abbreviations/.chain:FormCalc`DiracChain[__] :> replaceMomenta@chain;
   setZeroChainToZero[FormCalc`DiracChain[__,0,__]] := 0;
   setZeroChainToZero[chain:FormCalc`DiracChain[__]] := chain;
   temp/.chain:FormCalc`DiracChain[__] :> setZeroChainToZero@chain
]; 
setZeroExternalMomentaInChains[x___] := 
Utils`AssertOrQuit[False,setZeroExternalMomentaInChains::errUnknownInput,{x}];
SetAttributes[setZeroExternalMomentaInChains,{Protected,Locked}];

identifySpinors::usage =
"@brief Inserts the names of fermionic fields inside FormCalc`DicaChain structures.
@param inp List of abbreviations to modify | FormCalc`DiracChain chain to modify.
@param ampsGen FeynArts`FeynAmpList with information of process 
@returns DiracChain with inserted fermion names | Expression with new DiracChains.
@note DiracChains live only inside FormCalc`Abbr.
@note Should NOT be used for Automatic FormCalc`FermionOrder.";
identifySpinors::errUnknownInput =
"Input should be
identifySpinors@@{ <list of rules>, <feynamplist> } OR
identifySpinors@@{ <diracchain>, <feynamplist> }
and not
identifySpinors@@`1`";
identifySpinors[
   inp:{Rule[_,_]...},
   ampsGen:FeynArts`FeynAmpList[
      ___,
      (FeynArts`Process->Rule[{{__}..},{{__}..}]),
      ___,
      FeynArts`AmplitudeLevel->{Generic},
      ___][___]] := 
inp/.ch:FormCalc`DiracChain[__]:>identifySpinors[ch,ampsGen];
identifySpinors[
   FormCalc`DiracChain[
      FormCalc`Spinor[FormCalc`k[fermion1_Integer],mass1_,_Integer],
      seqOfElems___,
      FormCalc`Spinor[FormCalc`k[fermion2_Integer],mass2_,_Integer]],
   FeynArts`FeynAmpList[
      ___,
      process:(FeynArts`Process->Rule[{{__}..},{{__}..}]),
      ___,
      FeynArts`AmplitudeLevel->{Generic},
      ___][___]
] :=
Module[
   {
      identificationRules = getFermionPositionRules@process
   },
   FormCalc`DiracChain[
   FormCalc`Spinor[fermion1/.identificationRules,FormCalc`k[fermion1],mass1],
   seqOfElems,
   FormCalc`Spinor[fermion2/.identificationRules,FormCalc`k[fermion2],mass2]]
];
identifySpinors[x___] :=
Utils`AssertOrQuit[False,identifySpinors::errUnknownInput,{x}];
SetAttributes[identifySpinors,{Protected,Locked}];

getFermionPositionRules::usage =
"@brief Gives rules of the form number_of_input_field->name_of_fermion.
@param FeynArts`Process->Rule[_,_].
@returns Rules of the form number_of_input_field->name_of_fermion.";
getFermionPositionRules::errUnknownInput =
"Input should be
getFermionPositionRules@@{ FeynArts`Process->Rule[_,_] }
and not
getFermionPositionRules@@`1`";
getFermionPositionRules[
   FeynArts`Process->Rule[in:{{__}..},out:{{__}..}]
] :=
Module[
   {
      particleList = Join[in[[All,1]],out[[All,1]]],
      current = 1
   },
   Flatten[ Reap[Do[
      Sow@Cases[{particleList[[current]]},fermion:FeynArts`F[__]:>(current->fermion),{1}];
      Sow@Cases[{particleList[[current]]},fermion:-FeynArts`F[__]:>(current->SARAH`bar[-fermion]),{1}];
      current++,
      Length@particleList]][[2]] ] //. fieldNameToFSRules
];
getFermionPositionRules[x___] :=
Utils`AssertOrQuit[False,getFermionPositionRules::errUnknownInput,{x}]
SetAttributes[getFermionPositionRules,{Protected,Locked}];

getNumberOfChains::usage =
"@brief Is used to calculate number of opened fermion chains.
@param FeynArts`FeynAmpList[..][..]
@returns Number of opened fermion chains.";
getNumberOfChains::errNumberOfFermions =
"During evaluation unexpected value of fermions `1` was calculated.";
getNumberOfChains::errUnknownInput =
"Input should be
getNumberOfExternalFermions@@{ FeynArts`FeynAmpList[___][___] }
and not
getNumberOfExternalFermions@@`1`";
getNumberOfChains[
   FeynArts`FeynAmpList[
      ___,
      FeynArts`Process->Rule[in:{{__}..},out:{{__}..}],
      ___,
      FeynArts`AmplitudeLevel->{Generic},
      ___][___]
] :=
Module[{numberOfChains = 0},
   Cases[Join[in[[All,1]],out[[All,1]]],FeynArts`F[__]|-FeynArts`F[__]:>numberOfChains++,{1}];
   numberOfChains /= 2;
   If[IntegerQ@numberOfChains && numberOfChains >= 0,
      numberOfChains,
      Utils`AssertOrQuit[False,getNumberOfChains::errNumberOfFermions,numberOfChains]
   ]
];
getNumberOfChains[x___] :=
Utils`AssertOrQuit[False,getNumberOfChains::errUnknownInput,{x}]
SetAttributes[getNumberOfChains,{Protected,Locked}];

applyAndPrint[func_,expr_,defLength_Integer:70] :=
Module[
   {
      now = 1,
      totL = Length@expr,
      write,
      percent,
      numOfEq,
      restL
   },
   restL=defLength-2*IntegerLength@totL-11;
   write[args__] := WriteLine[OutputStream["stdout", 1],args];
   Reap[
      Do[
      percent = now/totL;
      numOfEq = If[#<0,0,#]&[ Floor[percent*restL]-1 ];
      write[StringJoin[
         "[",StringJoin@@Array[" "&,IntegerLength@totL-IntegerLength@now],ToString@now,"/",ToString@totL,"]"," ",
         "[",StringJoin@@Array["="&,numOfEq],">",StringJoin@@Array[" "&,restL-numOfEq-1],"] ",ToString@Floor[100*percent],"%"]];
      Sow@func[ expr[[now]] ];
      write@"\033[A\033[K\033[A\033[A\033[K\033[A\033[A\033[A";
      now++;
      ,totL]
   ][[2,1]]
];

CombinatorialFactorsForClasses::usage=
"@brief takes generic amplitude and finds numerical combinatirical factors
which arise at class level
@returns list of combinatorical factors for a given generic amplitude
@param FeynArts`.`FeynAmp[__]";
CombinatorialFactorsForClasses[
   FeynArts`FeynAmp[_,_,_,rules_->_[_][classReplacements__]]
]:=
Module[{position = Position[rules, FeynArts`RelativeCF]},
   {classReplacements}[[ All,position[[1,1]] ]] /. FeynArts`SumOver[__] -> 1
];

ToGenericSum::usage=
"@brief Given a generic amplitude, determine the generic fields over which it
needs to be summed and return a corresponding GenericSum[] object.
@param FormCalc`Amp[_->_][amp_] the given generic amplitude
@returns {S|F|V|U|T[GenericIndex[number of index]]...}.";
ToGenericSum[FormCalc`Amp[_->_][amp_]] :=
Module[
   {
      sortSumFields = Sort@DeleteDuplicates[Cases[amp,
         _?(FAFieldQ)[FeynArts`Index[Generic,_Integer]],
         Infinity]],
      replSumFields
   },
   replSumFields = sortSumFields /. f_[_[_,i_]]:>f@GenericIndex@i;
   GenericSum[amp, replSumFields]
];
SetAttributes[ToGenericSum,{Protected,Locked}];

FAFieldQ::usage=
"@brief Checks whether symbol belongs to FeynArts` field names or not.
@param Symbol to check.
@returns True if symbol belongs to FeynArts` field names, False otherwise.";
FAFieldQ = 
   MemberQ[{FeynArts`S,FeynArts`F,FeynArts`V,FeynArts`U,FeynArts`T},#]&;
SetAttributes[FAFieldQ,{Protected,Locked}];

ZeroRules::usage=
"@brief Given a set of rules that map to zero and a set that does
not map to zero, apply the zero rules to the non-zero ones
recursively until the non-zero rules do not change anymore.
@param nonzeroRules the list of nonzero rules
@param zeroRules the list of zero rules
@returns a list of rules that map the same expressions as the initial rules.
The return value is of the form {{Rule[_,_]...},{Rule[_,0]...}}";
ZeroRules[nonzeroRules:{Rule[_,_]...}, zeroRules:{Rule[_,0]...}] :=
Module[{newNonzero, newZeroRules},
   newNonzero = Thread[
      Rule[nonzeroRules[[All,1]],nonzeroRules[[All,2]] /. zeroRules]];

   If[newNonzero === nonzeroRules, Return[{nonzeroRules, zeroRules}]];

   newZeroRules = Cases[newNonzero,HoldPattern[_->0]];
   newNonzero = Complement[newNonzero, newZeroRules];

   ZeroRules[newNonzero, Join[zeroRules,newZeroRules]]
];

FCAmplitudesToFSConvention::usage=
"@brief Tranlate a list of FormCalc amplitudes and their abbreviations and
subexpressions into FlexibleSUSY language.
@param amplitudes the given list of amplitudes
@param abbreviations list of abbreviations
@param aubexpressions list of subexpressions
@returns a list of the form
`{fsAmplitudes, Join[fsAbbreviations,fsSubexpressions]}`
where all FlexibleSUSY conventions have been applied.";
FCAmplitudesToFSConvention[amplitudes_, abbreviations_, subexpressions_] :=
Module[{fsAmplitudes, fsAbbreviations, fsSubexpressions},
   fsAmplitudes = amplitudes //. amplitudeToFSRules;
   fsAbbreviations = abbreviations //. subexpressionToFSRules;
   fsSubexpressions = subexpressions //. subexpressionToFSRules;

   {fsAmplitudes, Join[fsAbbreviations,fsSubexpressions]}
];

SetAttributes[
   {
   SetFSConventionRules,
   NPointFunctionFAFC,
   GenericInsertionsForDiagram,FindGenericInsertions,StripParticleIndices,
   ColourFactorForDiagram,
   CombinatorialFactorsForClasses,
   ZeroRules,FCAmplitudesToFSConvention
   }, 
   {Protected, Locked}];

End[];
EndPackage[];
