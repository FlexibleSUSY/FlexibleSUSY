(* :Copyright:

   ====================================================================
   This file is part of FlexibleSUSY.

   FlexibleSUSY is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published
   by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   FlexibleSUSY is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with FlexibleSUSY.  If not, see
   <http://www.gnu.org/licenses/>.
   ====================================================================

*)

BeginPackage@"NPointFunctions`";
Begin@"`Private`";

topologies[{2, 2}] = {
   treeS -> {1,0,1,0,0,1,0,1,0,1,0},
   treeT -> {1,0,0,1,1,0,0,1,0,1,0},
   treeU -> {1,0,0,1,0,1,1,0,0,1,0},
   treeAll -> {treeS, treeT, treeU},
   triangleT -> {1,0,0,0,0,1,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,1,0},
   inSelfT -> {1,0,0,0,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,2,0,1,0,0,1,0},
   outSelfT -> {1,0,0,0,0,1,0,0,0,0,1,0,0,1,0,0,0,1,0,1,0,0,0,0,2,0},
   penguinT -> {triangleT, inSelfT, outSelfT},
   boxS -> {1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,0,1,0,1,0},
   boxT -> {1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,1,0,0,1,0},
   boxU -> {1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0},
   boxAll -> {boxS, boxT, boxU}
};

adjace::usage = "
@brief In order to generate new topology, please apply this function onto
       desired one from the set, generated by ``FeynArts`CreateTopologies``.";
adjace[topology:type`topology] :=
Module[{propagatorPattern, needNewNumbers, adjacencies, matrix, ext},
   ext = Count[topology, FeynArts`Incoming|FeynArts`Outgoing|FeynArts`External,
      Infinity, Heads -> True];
   propagatorPattern[i_,j_,f___] := _[_][_[_][i],_[_][j],f];
   needNewNumbers = And[
      Max@@(topology/.propagatorPattern[i_,j_,___]:>Sequence[i,j])>100,
      MatchQ[List@@topology,{propagatorPattern[_,_]..}]];
   adjacencies = Tally[
      (List@@#)/.propagatorPattern[i_,j_,___]:>{{i,j},{j,i}}] &@
         If[needNewNumbers,FeynArts`TopologySort@#,#] &@ topology;
   matrix = Normal@SparseArray@Flatten[{#[[1,1]]->#[[2]],#[[1,2]]->#[[2]]} &/@
      adjacencies];
   Flatten@Table[Drop[#[[i]], i-1+Max[ext-i+1, 0]], {i, Length@#}]&@matrix];
adjace // secure;

define[topologies] :=
Module[{all, single, combined},
   all = topologies@`options`observable@Outer;
   If[Head@all =!= List, Return[]];
   combined = Select[all, FreeQ[#, _Integer]&];
   single = Complement[all, combined];
   If[single =!= {}, defineSingle/@ single];
   If[combined =!= {}, defineCombined/@ combined];
];

defineSingle[name_Symbol -> adjacencyVector:{__Integer}] :=
With[{function = name, vector = adjacencyVector},
   function[t:type`topology] := adjace@t === vector;
   function // secure;
];
defineSingle // secure;

defineCombined[name_Symbol -> singleTopologies:{__Symbol}] :=
With[{function = name, list = singleTopologies},
   function[t:type`topology] := Or@@ Through@list@t;
   function // secure;
];
defineCombined // secure;

getTopology[d:type`diagram] := First@d;
getTopology // secure;

getExcludeTopologies::usage = "
@brief Registers a function, whose outcome (``True`` or everything else)
       determines whether the topology is kept or not.
@param keep A list of processes to keep.
@returns A name of generated function.";
getExcludeTopologies[] :=
Module[{all, name, set, topologyReplacements},
   topologyReplacements = {
      "Irreducible" -> (FreeQ[#, FeynArts`Internal]&),
      "Triangles"   -> (FreeQ[FeynArts`ToTree@#, FeynArts`Centre@Except@3]&)
   };
   set = If[MatchQ[#, {__}], #, {}]&[topologies@`options`loops[]];
   set = Rule[SymbolName@First@#, Last@#]&/@ set;
   all = Join[topologyReplacements, set];
   FeynArts`$ExcludeTopologies[name] = Function[Or@@Through[
      (`options`processes[]/.all)@#]];
   name];
getExcludeTopologies // secure;

End[];
EndPackage[];
