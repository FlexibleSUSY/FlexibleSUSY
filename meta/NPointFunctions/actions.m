(* :Copyright:

   ====================================================================
   This file is part of FlexibleSUSY.

   FlexibleSUSY is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published
   by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   FlexibleSUSY is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with FlexibleSUSY.  If not, see
   <http://www.gnu.org/licenses/>.
   ====================================================================

*)

BeginPackage@"NPointFunctions`";
Begin@"NPointFunctions`internal`";

getActions::usage = "
@brief Gets actions generated by `settings`diagrams or `settings`amplitudes.
       `settings`diagrams A function (of InsertFields-diargams), which defines
                          how to modify diagrams.
       `settings`amplitudes A function (of InsertFields-diagrams), which defines
                            how to modify CreateFeynAmp-amplitudes and
                            corresponding diagrams.
       The structure of them is the following:
          {  <symbol> -> {  {  <if-in-$Processes action>
                               ...},
                            {  <if-not-in-$Processes action>
                               ...}}
             ..}
       <symbol> is any symbol, which defines, which <action> should be done
                with diagrams if it's present or absent in $Processes.
       <`settings`diagrams action> has the following syntax:
          {  <topologyQ function name>,
             <2-arg function name>,
             <selection criteria for 2-arg function>,
             <string comment>}
       <`settings`amplitudes action> has the following syntax:
          {  <string comment>,
             <topologyQ function name>,
             {  <2-arg function>,
                <some class variable>,
                <comparable value>},
             <string comment>}
@param settings An entry to define actions.
@returns A set of settings.";
getActions[settings:Default] := {};
getActions[settings:{Rule[_,{{___},{___}}]..}] :=
Module[{positiveRules, negativeRules, discardProcesses, actions},
   positiveRules = settings /. Rule[s:_, {p:_, _}] :> Rule[s, p];
   negativeRules = settings /. Rule[s:_, {_, n:_}] :> Rule[s, n];
   discardProcesses = Complement[settings[[All, 1]], $Processes];
   actions = DeleteDuplicates@Join[
      DeleteDuplicates@Flatten[$Processes /. positiveRules, 1],
      DeleteDuplicates@Flatten[discardProcesses /. negativeRules, 1]]];
getActions // secure;

getTruePositions::usage = "
@brief Converts a list with a boolean variables to the list of positions for
       all true entries.
@param list A list of booleans.
@returns A list of integers (of an empty one)."
define[getTruePositions, {list:{(True|False)...}} :> Flatten@Position[list, True]];

applyAction[{diagrams:`type`diagramSet, amplitudes:`type`amplitudeSet},
   {text:_String, topologyQ:_, {function:UnsameQ, name:_, value:_}}] :=
Module[{
      daPairs = getAmplitudeNumbers[diagrams, topologyQ],
      amplitudeNumbers, saveClassRules, viPairs, insertions, res},
   amplitudeNumbers = Cases[daPairs, Rule[True, {e:__}] :> e];
   saveClassRules = Table[
      viPairs = getClassRules@amplitudes[[i]];
      insertions = Cases[viPairs, (name -> {e:__}) :> e, Infinity ];
      i -> getTruePositions[function[#, value] &/@ insertions] /. {} -> All,
      {i, amplitudeNumbers}];
   res =
   {  deleteClasses[diagrams, daPairs, saveClassRules],
      deleteClasses[amplitudes, daPairs, saveClassRules]};
   Print@text;
   printDiagramsInfo@res[[1]];
   res];
applyAction[diagrams:`type`diagramSet,
   {topologyQ:_, function:_, crit:_, text:_String}] :=
Module[{d = diagrams},
   d = If[topologyQ@#[[1]], Part[#,1] -> function[Part[#,2], crit], #] &/@ d;
   d = removeTopologiesWithoutInsertions@d;
   Print@text;
   printDiagramsInfo@d;
   d];

`action`sum = Sequence[d:`type`diagramSet,
   {s:_String, t:_Symbol, {n:_Integer, f:_}}];
`action`hold = Sequence[d:`type`diagramSet,
   {s:_String, t:_Symbol, {Hold, e:_Integer}}];
`action`append = Sequence[d:`type`diagramSet,
   {s:_String, t:_Symbol, {Append, (f:`type`field)[n:_Integer] :> e:_Integer}}];

Module[{template},
   template[text:_, topologyQ:_, realization:_] :=
   If[topologyQ@getTopology@#,
      Print@text;
      getTopology@# -> foreach[realization&, getInsertions@#],
      (##&)[]]&;

   Module[{restrict},
      restrict[field_, number_] := {number -> Or[field, -field]};
      applyAction@`action`sum := List@@Map[template[s, t, restrict[f, n]], d];];

   Module[{delete},
      delete[e_] := With[{pos = {{2*e}, {2*e-1}}}, Delete[#, pos]&];
      applyAction@`action`hold := Sequence@@Map[template[s, t, delete@e], d];];

   Module[{append},
      append[field_, number:_, e_] := With[{
            rhs = (First /@ getZeroMassRules[])[[2*e-1]]},
         Append[#, genericMass[field, number] :> rhs]&];
      applyAction@`action`append :=
         Sequence@@Map[template[s, t, append[f, n, e]], d];];];
applyAction // secure;

End[];
EndPackage[];
