(* ::Package:: *)

(* :Copyright:

   ====================================================================
   This file is part of FlexibleSUSY.

   FlexibleSUSY is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published
   by the Free Software Foundation, either version 3 of the License,
   or (at your option) any later version.

   FlexibleSUSY is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with FlexibleSUSY.  If not, see
   <http://www.gnu.org/licenses/>.
   ====================================================================

*)

BeginPackage@"LToLConversion`";

create::usage = "";

Begin["`internal`"];

`type`lepton = _Symbol?TreeMasses`IsLepton;
`type`lepton ~ SetAttributes ~ {Protected, Locked};

`type`contribution = Alternatives[
   All,NPointFunctions`FourFermionScalarPenguins,
   NPointFunctions`FourFermionMassiveVectorPenguins,
   NPointFunctions`FourFermionFlavourChangingBoxes
];
`type`contribution ~ SetAttributes ~ {Protected, Locked};

`type`observable = FlexibleSUSYObservable`LToLConversion[
   (lIn:`type`lepton)[_Integer]->(lOut:`type`lepton)[_Integer],
   _Symbol,
   con:`type`contribution,
   CoefficientList->True
];
`type`observable ~ SetAttributes ~ {Protected, Locked};

`cxx`in = "";
`cxx`in // Protect;

setIn[lIn:`type`lepton] := (
   Unprotect@`cxx`in;
   `cxx`in = CConversion`ToValidCSymbolString@lIn;
   Protect@`cxx`in;
);
setIn // Utils`MakeUnknownInputDefinition;
setIn ~ SetAttributes ~ {Protected, Locked};

`cxx`out = "";
`cxx`out // Protect;

setOut[lOut:`type`lepton] := (
   Unprotect@`cxx`out;
   `cxx`out = CConversion`ToValidCSymbolString@lOut;
   Protect@`cxx`out;
);
setOut // Utils`MakeUnknownInputDefinition;
setOut ~ SetAttributes ~ {Protected, Locked};

`cxx`con = "";
`cxx`con // Protect;

setCon[con:`type`contribution] := (
   Unprotect@`cxx`con;
   `cxx`con = CConversion`ToValidCSymbolString@con;
   Protect@`cxx`con;
);
setCon // Utils`MakeUnknownInputDefinition;
setCon ~ SetAttributes ~ {Protected, Locked};

{`cxx`up, `cxx`down} := {
   CConversion`ToValidCSymbolString@SARAH`UpQuark,
   CConversion`ToValidCSymbolString@SARAH`DownQuark
};
{`cxx`up, `cxx`down} ~ SetAttributes ~ {Protected, Locked};

`cxx`prototype :=
   "Eigen::Array<std::complex<double>,10,1>"<>
   " calculate_"<>`cxx`in<>"_to_"<>`cxx`out<>"_for_"<>`cxx`con<>"(\n"<>
   "   int generationIndex1,\n"<>
   "   int generationIndex2,\n"<>
   "   const " <> FlexibleSUSY`FSModelName <>
      "_l_to_l_conversion::Nucleus nucleus,\n" <>
   "   const " <> FlexibleSUSY`FSModelName <>
      "_mass_eigenstates& model, const softsusy::QedQcd& qedqcd)";
`cxx`prototype ~ SetAttributes ~ {Protected, Locked};

create::usage =
"@brief Main entrance point for the canculation.";
create[obs:`type`observable] :=
Module[
   {
      npfVertices, npfHeader, npfDefinition,
      calculatePrototype = getPrototype[lIn->lOut,contribution],
      calculateDefinition
   },
   setIn@lIn;
   setOut@lOut;
   setCon@con;

   {npfVertices, npfHeader, npfDefinition} = `npf`create[obs];

   calculateDefinition = `cxx`prototype <> " {\n" <>
   "   return Eigen::Array<std::complex<double>,10,1>::Zero();\n"<>
   "}\n";

   {
      {},
      {npfHeader,npfDefinition},
      {`cxx`prototype <> ";", calculateDefinition}
   }
];

create[list:{__}] :=
   {
      DeleteDuplicates[ Join@@#[[All,1]] ],
      {
         #[[1,2,1]],
         StringJoin@Riffle[#[[All,2,2]], "\n\n"]
      },
      {
         StringJoin@Riffle[#[[All,3,1]], "\n\n"],
         StringJoin@Riffle[#[[All,3,2]], "\n\n"]
      }
   } & [create /@ list];

create // Utils`MakeUnknownInputDefinition;

`npf`create[`type`observable] :=
Module[
   {
      parsedCon = Switch[con,
         All, {
               NPointFunctions`FourFermionMassiveVectorPenguins,
               NPointFunctions`FourFermionScalarPenguins,
               NPointFunctions`FourFermionFlavourChangingBoxes
            },
         _, con
      ],
      cxxClassU = "conversion_"<>`cxx`in<>`cxx`up<>"_to_"<>
         `cxx`out<>`cxx`up<>"_for_"<>`cxx`con,
      cxxClassD = "conversion_"<>`cxx`in<>`cxx`down<>"_to_"<>
         `cxx`out<>`cxx`down<>"_for_"<>`cxx`con,
      cxxHeader=NPointFunctions`CreateCXXHeaders[],

      npfU, npfD, (*@note objects, generated by NPointFunction*)

      l=SARAH`Lorentz, p=SARAH`Mom, m=SARAH`Mass, (*@note synonyms*)
      dc = NPointFunctions`internal`dc, (*@note current name for dirac chain*)

      fiG, foG, uiG, uoG, diG, doG, (*@note particle | inc/out | generation*)
      regulator, (*@note arbitrary sqr(3-momenta) of quarks*)
      inner, sp, dim6,

      codeU,codeD
   },

   Print["<<npf<< calculation for ",`cxx`in," to ",`cxx`out," conversion started ..."];

   {npfU, npfD} = NPointFunctions`NPointFunction[
      {lIn,#},{lOut,#},
      NPointFunctions`OnShellFlag -> True,
      NPointFunctions`UseCache -> False,
      NPointFunctions`ZeroExternalMomenta -> NPointFunctions`OperatorsOnly,
      NPointFunctions`KeepProcesses -> parsedCon] &/@ {SARAH`UpQuark,SARAH`DownQuark};

   {fiG, uiG, foG, uoG} = Flatten@NPointFunctions`internal`getProcess@npfU;
   {fiG, diG, foG, doG} = Flatten@NPointFunctions`internal`getProcess@npfD;
   regulator = m@fiG^2;

   inner = SARAH`sum[i_,1,4,SARAH`g[i_,i_]*p[#1,i_]*p[#2,i_]]&;
   {npfU, npfD} = {npfU, npfD} //. {
         inner[fiG,foG] :> m@fiG^2,
         inner[uiG,fiG] :> m@fiG*Sqrt[m@uiG^2+regulator],
         inner[uoG,fiG] :> inner[uiG,fiG],
         inner[uoG,foG] :> m@fiG^2/2+inner[uiG,fiG],
         inner[diG,fiG] :> m@fiG*Sqrt[m@diG^2+regulator],
         inner[doG,fiG] :> inner[diG,fiG],
         inner[doG,foG] :> m@fiG^2/2+inner[diG,fiG]
      };

   sp[particle:_,num:_Integer] := SARAH`DiracSpinor[#,p@num,m@#] &@
      particle@{Symbol["SARAH`gt"<>ToString@num]};

   dim6[i_,o_,q_,qn_String] := {
      (*@note 6 means PR, 7 means PL.*)
      ("S_LL_"<>qn) -> dc[o~sp~3,7,i~sp~1] dc[q~sp~4,7,q~sp~2],
      ("S_LR_"<>qn) -> dc[o~sp~3,7,i~sp~1] dc[q~sp~4,6,q~sp~2],
      ("S_RL_"<>qn) -> dc[o~sp~3,6,i~sp~1] dc[q~sp~4,7,q~sp~2],
      ("S_RR_"<>qn) -> dc[o~sp~3,6,i~sp~1] dc[q~sp~4,6,q~sp~2],
      (*@note names are correct, one just need to commute projectors with
       *Dirac matrices. It changes 6 to 7 or 7 to 6.*)
      ("V_LL_"<>qn) -> dc[o~sp~3,6,l@1,i~sp~1] dc[q~sp~4,6,l@1,q~sp~2],
      ("V_LR_"<>qn) -> dc[o~sp~3,6,l@1,i~sp~1] dc[q~sp~4,7,l@1,q~sp~2],
      ("V_RL_"<>qn) -> dc[o~sp~3,7,l@1,i~sp~1] dc[q~sp~4,6,l@1,q~sp~2],
      ("V_RR_"<>qn) -> dc[o~sp~3,7,l@1,i~sp~1] dc[q~sp~4,7,l@1,q~sp~2],
      (*@note Minus, because FormCalc`s -6,Lor[1],Lor[2] is ours
       *-I*sigma[1,2] (according to FC definition of antisymmetrization), when
       *taking this twice we get I*I=-1. FC cites [Ni05] for Fierz identities,
       *where our conventions are used, but in FC manual on the page 20
       *weird convention for sigma_munu is shown.*)
      ("minus_T_LL_"<>qn) -> dc[o~sp~3,-7,l@1,l@2,i~sp~1] dc[q~sp~4,-7,l@1,l@2,q~sp~2],
      ("minus_T_RR_"<>qn) -> dc[o~sp~3,-6,l@1,l@2,i~sp~1] dc[q~sp~4,-6,l@1,l@2,q~sp~2]
   };
   npfU = npfU~WilsonCoeffs`InterfaceToMatching~dim6[lIn,lOut,SARAH`UpQuark,`cxx`up];
   npfD = npfD~WilsonCoeffs`InterfaceToMatching~dim6[lIn,lOut,SARAH`DownQuark,`cxx`down];

   Print[">>npf>> calculation for ",`cxx`in," to ",`cxx`out," conversion done."];

   Print["<<npf<< c++ code calculation for ",`cxx`in," to ",`cxx`out," conversion started ..."];

   codeU = NPointFunctions`CreateCXXFunctions[
      npfU,
      cxxClassU,
      SARAH`Delta,
      dim6[lIn,lOut,SARAH`UpQuark,`cxx`up]
   ][[2]];
   codeD = NPointFunctions`CreateCXXFunctions[
      npfD,
      cxxClassD,
      SARAH`Delta,
      dim6[lIn,lOut,SARAH`DownQuark,`cxx`down]
   ][[2]];

   Print[">>npf>> c++ code calculation for ",`cxx`in," to ",`cxx`out," conversion done."];
   {
      DeleteDuplicates@Join[
         NPointFunctions`VerticesForNPointFunction@npfU,
         NPointFunctions`VerticesForNPointFunction@npfD
      ],
      cxxHeader,
      codeU<>"\n\n"<>codeD
   }
];
`npf`create // Utils`MakeUnknownInputDefinition;
`npf`create ~ SetAttributes ~ {Locked,Protected};

End[];
EndPackage[];
